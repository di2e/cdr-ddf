//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package org.isotc211._2005.gmd;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.isotc211._2005.gco.BooleanPropertyType;
import org.isotc211._2005.gco.CharacterStringPropertyType;
import org.isotc211._2005.gss.GMPointPropertyType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for MD_Georectified_Type complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="MD_Georectified_Type"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.isotc211.org/2005/gmd}MD_GridSpatialRepresentation_Type"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="checkPointAvailability" type="{http://www.isotc211.org/2005/gco}Boolean_PropertyType"/&gt;
 *         &lt;element name="checkPointDescription" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="cornerPoints" type="{http://www.isotc211.org/2005/gss}GM_Point_PropertyType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="centerPoint" type="{http://www.isotc211.org/2005/gss}GM_Point_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="pointInPixel" type="{http://www.isotc211.org/2005/gmd}MD_PixelOrientationCode_PropertyType"/&gt;
 *         &lt;element name="transformationDimensionDescription" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="transformationDimensionMapping" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" maxOccurs="2" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "MD_Georectified_Type", propOrder = {
    "checkPointAvailability",
    "checkPointDescription",
    "cornerPoints",
    "centerPoint",
    "pointInPixel",
    "transformationDimensionDescription",
    "transformationDimensionMapping"
})
public class MDGeorectifiedType
    extends MDGridSpatialRepresentationType
    implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlElement(required = true)
    @NotNull(message = "MDGeorectifiedType.checkPointAvailability {javax.validation.constraints.NotNull.message}")
    @Valid
    protected BooleanPropertyType checkPointAvailability;
    @Valid
    protected CharacterStringPropertyType checkPointDescription;
    @Valid
    protected List<GMPointPropertyType> cornerPoints;
    @Valid
    protected GMPointPropertyType centerPoint;
    @XmlElement(required = true)
    @NotNull(message = "MDGeorectifiedType.pointInPixel {javax.validation.constraints.NotNull.message}")
    @Valid
    protected MDPixelOrientationCodePropertyType pointInPixel;
    @Valid
    protected CharacterStringPropertyType transformationDimensionDescription;
    @Size(min = 0, max = 2)
    @Valid
    protected List<CharacterStringPropertyType> transformationDimensionMapping;

    /**
     * Gets the value of the checkPointAvailability property.
     * 
     * @return
     *     possible object is
     *     {@link BooleanPropertyType }
     *     
     */
    public BooleanPropertyType getCheckPointAvailability() {
        return checkPointAvailability;
    }

    /**
     * Sets the value of the checkPointAvailability property.
     * 
     * @param value
     *     allowed object is
     *     {@link BooleanPropertyType }
     *     
     */
    public void setCheckPointAvailability(BooleanPropertyType value) {
        this.checkPointAvailability = value;
    }

    public boolean isSetCheckPointAvailability() {
        return (this.checkPointAvailability!= null);
    }

    /**
     * Gets the value of the checkPointDescription property.
     * 
     * @return
     *     possible object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public CharacterStringPropertyType getCheckPointDescription() {
        return checkPointDescription;
    }

    /**
     * Sets the value of the checkPointDescription property.
     * 
     * @param value
     *     allowed object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public void setCheckPointDescription(CharacterStringPropertyType value) {
        this.checkPointDescription = value;
    }

    public boolean isSetCheckPointDescription() {
        return (this.checkPointDescription!= null);
    }

    /**
     * Gets the value of the cornerPoints property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the cornerPoints property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCornerPoints().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GMPointPropertyType }
     * 
     * 
     */
    public List<GMPointPropertyType> getCornerPoints() {
        if (cornerPoints == null) {
            cornerPoints = new ArrayList<GMPointPropertyType>();
        }
        return this.cornerPoints;
    }

    public boolean isSetCornerPoints() {
        return ((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty()));
    }

    public void unsetCornerPoints() {
        this.cornerPoints = null;
    }

    /**
     * Gets the value of the centerPoint property.
     * 
     * @return
     *     possible object is
     *     {@link GMPointPropertyType }
     *     
     */
    public GMPointPropertyType getCenterPoint() {
        return centerPoint;
    }

    /**
     * Sets the value of the centerPoint property.
     * 
     * @param value
     *     allowed object is
     *     {@link GMPointPropertyType }
     *     
     */
    public void setCenterPoint(GMPointPropertyType value) {
        this.centerPoint = value;
    }

    public boolean isSetCenterPoint() {
        return (this.centerPoint!= null);
    }

    /**
     * Gets the value of the pointInPixel property.
     * 
     * @return
     *     possible object is
     *     {@link MDPixelOrientationCodePropertyType }
     *     
     */
    public MDPixelOrientationCodePropertyType getPointInPixel() {
        return pointInPixel;
    }

    /**
     * Sets the value of the pointInPixel property.
     * 
     * @param value
     *     allowed object is
     *     {@link MDPixelOrientationCodePropertyType }
     *     
     */
    public void setPointInPixel(MDPixelOrientationCodePropertyType value) {
        this.pointInPixel = value;
    }

    public boolean isSetPointInPixel() {
        return (this.pointInPixel!= null);
    }

    /**
     * Gets the value of the transformationDimensionDescription property.
     * 
     * @return
     *     possible object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public CharacterStringPropertyType getTransformationDimensionDescription() {
        return transformationDimensionDescription;
    }

    /**
     * Sets the value of the transformationDimensionDescription property.
     * 
     * @param value
     *     allowed object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public void setTransformationDimensionDescription(CharacterStringPropertyType value) {
        this.transformationDimensionDescription = value;
    }

    public boolean isSetTransformationDimensionDescription() {
        return (this.transformationDimensionDescription!= null);
    }

    /**
     * Gets the value of the transformationDimensionMapping property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the transformationDimensionMapping property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTransformationDimensionMapping().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CharacterStringPropertyType }
     * 
     * 
     */
    public List<CharacterStringPropertyType> getTransformationDimensionMapping() {
        if (transformationDimensionMapping == null) {
            transformationDimensionMapping = new ArrayList<CharacterStringPropertyType>();
        }
        return this.transformationDimensionMapping;
    }

    public boolean isSetTransformationDimensionMapping() {
        return ((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty()));
    }

    public void unsetTransformationDimensionMapping() {
        this.transformationDimensionMapping = null;
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            BooleanPropertyType theCheckPointAvailability;
            theCheckPointAvailability = this.getCheckPointAvailability();
            strategy.appendField(locator, this, "checkPointAvailability", buffer, theCheckPointAvailability, this.isSetCheckPointAvailability());
        }
        {
            CharacterStringPropertyType theCheckPointDescription;
            theCheckPointDescription = this.getCheckPointDescription();
            strategy.appendField(locator, this, "checkPointDescription", buffer, theCheckPointDescription, this.isSetCheckPointDescription());
        }
        {
            List<GMPointPropertyType> theCornerPoints;
            theCornerPoints = (this.isSetCornerPoints()?this.getCornerPoints():null);
            strategy.appendField(locator, this, "cornerPoints", buffer, theCornerPoints, this.isSetCornerPoints());
        }
        {
            GMPointPropertyType theCenterPoint;
            theCenterPoint = this.getCenterPoint();
            strategy.appendField(locator, this, "centerPoint", buffer, theCenterPoint, this.isSetCenterPoint());
        }
        {
            MDPixelOrientationCodePropertyType thePointInPixel;
            thePointInPixel = this.getPointInPixel();
            strategy.appendField(locator, this, "pointInPixel", buffer, thePointInPixel, this.isSetPointInPixel());
        }
        {
            CharacterStringPropertyType theTransformationDimensionDescription;
            theTransformationDimensionDescription = this.getTransformationDimensionDescription();
            strategy.appendField(locator, this, "transformationDimensionDescription", buffer, theTransformationDimensionDescription, this.isSetTransformationDimensionDescription());
        }
        {
            List<CharacterStringPropertyType> theTransformationDimensionMapping;
            theTransformationDimensionMapping = (this.isSetTransformationDimensionMapping()?this.getTransformationDimensionMapping():null);
            strategy.appendField(locator, this, "transformationDimensionMapping", buffer, theTransformationDimensionMapping, this.isSetTransformationDimensionMapping());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final MDGeorectifiedType that = ((MDGeorectifiedType) object);
        {
            BooleanPropertyType lhsCheckPointAvailability;
            lhsCheckPointAvailability = this.getCheckPointAvailability();
            BooleanPropertyType rhsCheckPointAvailability;
            rhsCheckPointAvailability = that.getCheckPointAvailability();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "checkPointAvailability", lhsCheckPointAvailability), LocatorUtils.property(thatLocator, "checkPointAvailability", rhsCheckPointAvailability), lhsCheckPointAvailability, rhsCheckPointAvailability, this.isSetCheckPointAvailability(), that.isSetCheckPointAvailability())) {
                return false;
            }
        }
        {
            CharacterStringPropertyType lhsCheckPointDescription;
            lhsCheckPointDescription = this.getCheckPointDescription();
            CharacterStringPropertyType rhsCheckPointDescription;
            rhsCheckPointDescription = that.getCheckPointDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "checkPointDescription", lhsCheckPointDescription), LocatorUtils.property(thatLocator, "checkPointDescription", rhsCheckPointDescription), lhsCheckPointDescription, rhsCheckPointDescription, this.isSetCheckPointDescription(), that.isSetCheckPointDescription())) {
                return false;
            }
        }
        {
            List<GMPointPropertyType> lhsCornerPoints;
            lhsCornerPoints = (this.isSetCornerPoints()?this.getCornerPoints():null);
            List<GMPointPropertyType> rhsCornerPoints;
            rhsCornerPoints = (that.isSetCornerPoints()?that.getCornerPoints():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "cornerPoints", lhsCornerPoints), LocatorUtils.property(thatLocator, "cornerPoints", rhsCornerPoints), lhsCornerPoints, rhsCornerPoints, this.isSetCornerPoints(), that.isSetCornerPoints())) {
                return false;
            }
        }
        {
            GMPointPropertyType lhsCenterPoint;
            lhsCenterPoint = this.getCenterPoint();
            GMPointPropertyType rhsCenterPoint;
            rhsCenterPoint = that.getCenterPoint();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "centerPoint", lhsCenterPoint), LocatorUtils.property(thatLocator, "centerPoint", rhsCenterPoint), lhsCenterPoint, rhsCenterPoint, this.isSetCenterPoint(), that.isSetCenterPoint())) {
                return false;
            }
        }
        {
            MDPixelOrientationCodePropertyType lhsPointInPixel;
            lhsPointInPixel = this.getPointInPixel();
            MDPixelOrientationCodePropertyType rhsPointInPixel;
            rhsPointInPixel = that.getPointInPixel();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "pointInPixel", lhsPointInPixel), LocatorUtils.property(thatLocator, "pointInPixel", rhsPointInPixel), lhsPointInPixel, rhsPointInPixel, this.isSetPointInPixel(), that.isSetPointInPixel())) {
                return false;
            }
        }
        {
            CharacterStringPropertyType lhsTransformationDimensionDescription;
            lhsTransformationDimensionDescription = this.getTransformationDimensionDescription();
            CharacterStringPropertyType rhsTransformationDimensionDescription;
            rhsTransformationDimensionDescription = that.getTransformationDimensionDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transformationDimensionDescription", lhsTransformationDimensionDescription), LocatorUtils.property(thatLocator, "transformationDimensionDescription", rhsTransformationDimensionDescription), lhsTransformationDimensionDescription, rhsTransformationDimensionDescription, this.isSetTransformationDimensionDescription(), that.isSetTransformationDimensionDescription())) {
                return false;
            }
        }
        {
            List<CharacterStringPropertyType> lhsTransformationDimensionMapping;
            lhsTransformationDimensionMapping = (this.isSetTransformationDimensionMapping()?this.getTransformationDimensionMapping():null);
            List<CharacterStringPropertyType> rhsTransformationDimensionMapping;
            rhsTransformationDimensionMapping = (that.isSetTransformationDimensionMapping()?that.getTransformationDimensionMapping():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transformationDimensionMapping", lhsTransformationDimensionMapping), LocatorUtils.property(thatLocator, "transformationDimensionMapping", rhsTransformationDimensionMapping), lhsTransformationDimensionMapping, rhsTransformationDimensionMapping, this.isSetTransformationDimensionMapping(), that.isSetTransformationDimensionMapping())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            BooleanPropertyType theCheckPointAvailability;
            theCheckPointAvailability = this.getCheckPointAvailability();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "checkPointAvailability", theCheckPointAvailability), currentHashCode, theCheckPointAvailability, this.isSetCheckPointAvailability());
        }
        {
            CharacterStringPropertyType theCheckPointDescription;
            theCheckPointDescription = this.getCheckPointDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "checkPointDescription", theCheckPointDescription), currentHashCode, theCheckPointDescription, this.isSetCheckPointDescription());
        }
        {
            List<GMPointPropertyType> theCornerPoints;
            theCornerPoints = (this.isSetCornerPoints()?this.getCornerPoints():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "cornerPoints", theCornerPoints), currentHashCode, theCornerPoints, this.isSetCornerPoints());
        }
        {
            GMPointPropertyType theCenterPoint;
            theCenterPoint = this.getCenterPoint();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "centerPoint", theCenterPoint), currentHashCode, theCenterPoint, this.isSetCenterPoint());
        }
        {
            MDPixelOrientationCodePropertyType thePointInPixel;
            thePointInPixel = this.getPointInPixel();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pointInPixel", thePointInPixel), currentHashCode, thePointInPixel, this.isSetPointInPixel());
        }
        {
            CharacterStringPropertyType theTransformationDimensionDescription;
            theTransformationDimensionDescription = this.getTransformationDimensionDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transformationDimensionDescription", theTransformationDimensionDescription), currentHashCode, theTransformationDimensionDescription, this.isSetTransformationDimensionDescription());
        }
        {
            List<CharacterStringPropertyType> theTransformationDimensionMapping;
            theTransformationDimensionMapping = (this.isSetTransformationDimensionMapping()?this.getTransformationDimensionMapping():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transformationDimensionMapping", theTransformationDimensionMapping), currentHashCode, theTransformationDimensionMapping, this.isSetTransformationDimensionMapping());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        super.copyTo(locator, draftCopy, strategy);
        if (draftCopy instanceof MDGeorectifiedType) {
            final MDGeorectifiedType copy = ((MDGeorectifiedType) draftCopy);
            {
                Boolean checkPointAvailabilityShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCheckPointAvailability());
                if (checkPointAvailabilityShouldBeCopiedAndSet == Boolean.TRUE) {
                    BooleanPropertyType sourceCheckPointAvailability;
                    sourceCheckPointAvailability = this.getCheckPointAvailability();
                    BooleanPropertyType copyCheckPointAvailability = ((BooleanPropertyType) strategy.copy(LocatorUtils.property(locator, "checkPointAvailability", sourceCheckPointAvailability), sourceCheckPointAvailability, this.isSetCheckPointAvailability()));
                    copy.setCheckPointAvailability(copyCheckPointAvailability);
                } else {
                    if (checkPointAvailabilityShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.checkPointAvailability = null;
                    }
                }
            }
            {
                Boolean checkPointDescriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCheckPointDescription());
                if (checkPointDescriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    CharacterStringPropertyType sourceCheckPointDescription;
                    sourceCheckPointDescription = this.getCheckPointDescription();
                    CharacterStringPropertyType copyCheckPointDescription = ((CharacterStringPropertyType) strategy.copy(LocatorUtils.property(locator, "checkPointDescription", sourceCheckPointDescription), sourceCheckPointDescription, this.isSetCheckPointDescription()));
                    copy.setCheckPointDescription(copyCheckPointDescription);
                } else {
                    if (checkPointDescriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.checkPointDescription = null;
                    }
                }
            }
            {
                Boolean cornerPointsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCornerPoints());
                if (cornerPointsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<GMPointPropertyType> sourceCornerPoints;
                    sourceCornerPoints = (this.isSetCornerPoints()?this.getCornerPoints():null);
                    @SuppressWarnings("unchecked")
                    List<GMPointPropertyType> copyCornerPoints = ((List<GMPointPropertyType> ) strategy.copy(LocatorUtils.property(locator, "cornerPoints", sourceCornerPoints), sourceCornerPoints, this.isSetCornerPoints()));
                    copy.unsetCornerPoints();
                    if (copyCornerPoints!= null) {
                        List<GMPointPropertyType> uniqueCornerPointsl = copy.getCornerPoints();
                        uniqueCornerPointsl.addAll(copyCornerPoints);
                    }
                } else {
                    if (cornerPointsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetCornerPoints();
                    }
                }
            }
            {
                Boolean centerPointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCenterPoint());
                if (centerPointShouldBeCopiedAndSet == Boolean.TRUE) {
                    GMPointPropertyType sourceCenterPoint;
                    sourceCenterPoint = this.getCenterPoint();
                    GMPointPropertyType copyCenterPoint = ((GMPointPropertyType) strategy.copy(LocatorUtils.property(locator, "centerPoint", sourceCenterPoint), sourceCenterPoint, this.isSetCenterPoint()));
                    copy.setCenterPoint(copyCenterPoint);
                } else {
                    if (centerPointShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.centerPoint = null;
                    }
                }
            }
            {
                Boolean pointInPixelShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPointInPixel());
                if (pointInPixelShouldBeCopiedAndSet == Boolean.TRUE) {
                    MDPixelOrientationCodePropertyType sourcePointInPixel;
                    sourcePointInPixel = this.getPointInPixel();
                    MDPixelOrientationCodePropertyType copyPointInPixel = ((MDPixelOrientationCodePropertyType) strategy.copy(LocatorUtils.property(locator, "pointInPixel", sourcePointInPixel), sourcePointInPixel, this.isSetPointInPixel()));
                    copy.setPointInPixel(copyPointInPixel);
                } else {
                    if (pointInPixelShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.pointInPixel = null;
                    }
                }
            }
            {
                Boolean transformationDimensionDescriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTransformationDimensionDescription());
                if (transformationDimensionDescriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    CharacterStringPropertyType sourceTransformationDimensionDescription;
                    sourceTransformationDimensionDescription = this.getTransformationDimensionDescription();
                    CharacterStringPropertyType copyTransformationDimensionDescription = ((CharacterStringPropertyType) strategy.copy(LocatorUtils.property(locator, "transformationDimensionDescription", sourceTransformationDimensionDescription), sourceTransformationDimensionDescription, this.isSetTransformationDimensionDescription()));
                    copy.setTransformationDimensionDescription(copyTransformationDimensionDescription);
                } else {
                    if (transformationDimensionDescriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.transformationDimensionDescription = null;
                    }
                }
            }
            {
                Boolean transformationDimensionMappingShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTransformationDimensionMapping());
                if (transformationDimensionMappingShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CharacterStringPropertyType> sourceTransformationDimensionMapping;
                    sourceTransformationDimensionMapping = (this.isSetTransformationDimensionMapping()?this.getTransformationDimensionMapping():null);
                    @SuppressWarnings("unchecked")
                    List<CharacterStringPropertyType> copyTransformationDimensionMapping = ((List<CharacterStringPropertyType> ) strategy.copy(LocatorUtils.property(locator, "transformationDimensionMapping", sourceTransformationDimensionMapping), sourceTransformationDimensionMapping, this.isSetTransformationDimensionMapping()));
                    copy.unsetTransformationDimensionMapping();
                    if (copyTransformationDimensionMapping!= null) {
                        List<CharacterStringPropertyType> uniqueTransformationDimensionMappingl = copy.getTransformationDimensionMapping();
                        uniqueTransformationDimensionMappingl.addAll(copyTransformationDimensionMapping);
                    }
                } else {
                    if (transformationDimensionMappingShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetTransformationDimensionMapping();
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new MDGeorectifiedType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        super.mergeFrom(leftLocator, rightLocator, left, right, strategy);
        if (right instanceof MDGeorectifiedType) {
            final MDGeorectifiedType target = this;
            final MDGeorectifiedType leftObject = ((MDGeorectifiedType) left);
            final MDGeorectifiedType rightObject = ((MDGeorectifiedType) right);
            {
                Boolean checkPointAvailabilityShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCheckPointAvailability(), rightObject.isSetCheckPointAvailability());
                if (checkPointAvailabilityShouldBeMergedAndSet == Boolean.TRUE) {
                    BooleanPropertyType lhsCheckPointAvailability;
                    lhsCheckPointAvailability = leftObject.getCheckPointAvailability();
                    BooleanPropertyType rhsCheckPointAvailability;
                    rhsCheckPointAvailability = rightObject.getCheckPointAvailability();
                    BooleanPropertyType mergedCheckPointAvailability = ((BooleanPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "checkPointAvailability", lhsCheckPointAvailability), LocatorUtils.property(rightLocator, "checkPointAvailability", rhsCheckPointAvailability), lhsCheckPointAvailability, rhsCheckPointAvailability, leftObject.isSetCheckPointAvailability(), rightObject.isSetCheckPointAvailability()));
                    target.setCheckPointAvailability(mergedCheckPointAvailability);
                } else {
                    if (checkPointAvailabilityShouldBeMergedAndSet == Boolean.FALSE) {
                        target.checkPointAvailability = null;
                    }
                }
            }
            {
                Boolean checkPointDescriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCheckPointDescription(), rightObject.isSetCheckPointDescription());
                if (checkPointDescriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    CharacterStringPropertyType lhsCheckPointDescription;
                    lhsCheckPointDescription = leftObject.getCheckPointDescription();
                    CharacterStringPropertyType rhsCheckPointDescription;
                    rhsCheckPointDescription = rightObject.getCheckPointDescription();
                    CharacterStringPropertyType mergedCheckPointDescription = ((CharacterStringPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "checkPointDescription", lhsCheckPointDescription), LocatorUtils.property(rightLocator, "checkPointDescription", rhsCheckPointDescription), lhsCheckPointDescription, rhsCheckPointDescription, leftObject.isSetCheckPointDescription(), rightObject.isSetCheckPointDescription()));
                    target.setCheckPointDescription(mergedCheckPointDescription);
                } else {
                    if (checkPointDescriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.checkPointDescription = null;
                    }
                }
            }
            {
                Boolean cornerPointsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCornerPoints(), rightObject.isSetCornerPoints());
                if (cornerPointsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<GMPointPropertyType> lhsCornerPoints;
                    lhsCornerPoints = (leftObject.isSetCornerPoints()?leftObject.getCornerPoints():null);
                    List<GMPointPropertyType> rhsCornerPoints;
                    rhsCornerPoints = (rightObject.isSetCornerPoints()?rightObject.getCornerPoints():null);
                    List<GMPointPropertyType> mergedCornerPoints = ((List<GMPointPropertyType> ) strategy.merge(LocatorUtils.property(leftLocator, "cornerPoints", lhsCornerPoints), LocatorUtils.property(rightLocator, "cornerPoints", rhsCornerPoints), lhsCornerPoints, rhsCornerPoints, leftObject.isSetCornerPoints(), rightObject.isSetCornerPoints()));
                    target.unsetCornerPoints();
                    if (mergedCornerPoints!= null) {
                        List<GMPointPropertyType> uniqueCornerPointsl = target.getCornerPoints();
                        uniqueCornerPointsl.addAll(mergedCornerPoints);
                    }
                } else {
                    if (cornerPointsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetCornerPoints();
                    }
                }
            }
            {
                Boolean centerPointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCenterPoint(), rightObject.isSetCenterPoint());
                if (centerPointShouldBeMergedAndSet == Boolean.TRUE) {
                    GMPointPropertyType lhsCenterPoint;
                    lhsCenterPoint = leftObject.getCenterPoint();
                    GMPointPropertyType rhsCenterPoint;
                    rhsCenterPoint = rightObject.getCenterPoint();
                    GMPointPropertyType mergedCenterPoint = ((GMPointPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "centerPoint", lhsCenterPoint), LocatorUtils.property(rightLocator, "centerPoint", rhsCenterPoint), lhsCenterPoint, rhsCenterPoint, leftObject.isSetCenterPoint(), rightObject.isSetCenterPoint()));
                    target.setCenterPoint(mergedCenterPoint);
                } else {
                    if (centerPointShouldBeMergedAndSet == Boolean.FALSE) {
                        target.centerPoint = null;
                    }
                }
            }
            {
                Boolean pointInPixelShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPointInPixel(), rightObject.isSetPointInPixel());
                if (pointInPixelShouldBeMergedAndSet == Boolean.TRUE) {
                    MDPixelOrientationCodePropertyType lhsPointInPixel;
                    lhsPointInPixel = leftObject.getPointInPixel();
                    MDPixelOrientationCodePropertyType rhsPointInPixel;
                    rhsPointInPixel = rightObject.getPointInPixel();
                    MDPixelOrientationCodePropertyType mergedPointInPixel = ((MDPixelOrientationCodePropertyType) strategy.merge(LocatorUtils.property(leftLocator, "pointInPixel", lhsPointInPixel), LocatorUtils.property(rightLocator, "pointInPixel", rhsPointInPixel), lhsPointInPixel, rhsPointInPixel, leftObject.isSetPointInPixel(), rightObject.isSetPointInPixel()));
                    target.setPointInPixel(mergedPointInPixel);
                } else {
                    if (pointInPixelShouldBeMergedAndSet == Boolean.FALSE) {
                        target.pointInPixel = null;
                    }
                }
            }
            {
                Boolean transformationDimensionDescriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTransformationDimensionDescription(), rightObject.isSetTransformationDimensionDescription());
                if (transformationDimensionDescriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    CharacterStringPropertyType lhsTransformationDimensionDescription;
                    lhsTransformationDimensionDescription = leftObject.getTransformationDimensionDescription();
                    CharacterStringPropertyType rhsTransformationDimensionDescription;
                    rhsTransformationDimensionDescription = rightObject.getTransformationDimensionDescription();
                    CharacterStringPropertyType mergedTransformationDimensionDescription = ((CharacterStringPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "transformationDimensionDescription", lhsTransformationDimensionDescription), LocatorUtils.property(rightLocator, "transformationDimensionDescription", rhsTransformationDimensionDescription), lhsTransformationDimensionDescription, rhsTransformationDimensionDescription, leftObject.isSetTransformationDimensionDescription(), rightObject.isSetTransformationDimensionDescription()));
                    target.setTransformationDimensionDescription(mergedTransformationDimensionDescription);
                } else {
                    if (transformationDimensionDescriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.transformationDimensionDescription = null;
                    }
                }
            }
            {
                Boolean transformationDimensionMappingShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTransformationDimensionMapping(), rightObject.isSetTransformationDimensionMapping());
                if (transformationDimensionMappingShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CharacterStringPropertyType> lhsTransformationDimensionMapping;
                    lhsTransformationDimensionMapping = (leftObject.isSetTransformationDimensionMapping()?leftObject.getTransformationDimensionMapping():null);
                    List<CharacterStringPropertyType> rhsTransformationDimensionMapping;
                    rhsTransformationDimensionMapping = (rightObject.isSetTransformationDimensionMapping()?rightObject.getTransformationDimensionMapping():null);
                    List<CharacterStringPropertyType> mergedTransformationDimensionMapping = ((List<CharacterStringPropertyType> ) strategy.merge(LocatorUtils.property(leftLocator, "transformationDimensionMapping", lhsTransformationDimensionMapping), LocatorUtils.property(rightLocator, "transformationDimensionMapping", rhsTransformationDimensionMapping), lhsTransformationDimensionMapping, rhsTransformationDimensionMapping, leftObject.isSetTransformationDimensionMapping(), rightObject.isSetTransformationDimensionMapping()));
                    target.unsetTransformationDimensionMapping();
                    if (mergedTransformationDimensionMapping!= null) {
                        List<CharacterStringPropertyType> uniqueTransformationDimensionMappingl = target.getTransformationDimensionMapping();
                        uniqueTransformationDimensionMappingl.addAll(mergedTransformationDimensionMapping);
                    }
                } else {
                    if (transformationDimensionMappingShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetTransformationDimensionMapping();
                    }
                }
            }
        }
    }

    public void setCornerPoints(List<GMPointPropertyType> value) {
        this.cornerPoints = null;
        if (value!= null) {
            List<GMPointPropertyType> draftl = this.getCornerPoints();
            draftl.addAll(value);
        }
    }

    public void setTransformationDimensionMapping(List<CharacterStringPropertyType> value) {
        this.transformationDimensionMapping = null;
        if (value!= null) {
            List<CharacterStringPropertyType> draftl = this.getTransformationDimensionMapping();
            draftl.addAll(value);
        }
    }

}
