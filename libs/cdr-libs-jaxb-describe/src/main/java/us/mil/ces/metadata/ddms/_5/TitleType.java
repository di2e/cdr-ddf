//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.datatype.XMLGregorianCalendar;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import us.gov.ic.cvenum.ism._25x.CVEnumISM25X;
import us.gov.ic.cvenum.ism.classification.all.CVEnumISMClassificationAll;
import us.gov.ic.cvenum.ism.dissem.CVEnumISMDissemValues;
import us.gov.ic.cvenum.ism.nonic.CVEnumISMNonICValues;
import us.gov.ic.cvenum.ism.nonuscontrols.CVEnumISMNonUSControlsValues;
import us.gov.ic.cvenum.ism.scicontrols.CVEnumISMSCIControlsValues;


/**
 * <p>Java class for TitleType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="TitleType"&gt;
 *   &lt;simpleContent&gt;
 *     &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;simpleTokenType"&gt;
 *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
 *     &lt;/extension&gt;
 *   &lt;/simpleContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "TitleType", propOrder = {
    "value"
})
public class TitleType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlValue
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @Size(min = 1)
    protected String value;
    @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism", required = true)
    @NotNull(message = "TitleType.classification {javax.validation.constraints.NotNull.message}")
    protected CVEnumISMClassificationAll classification;
    @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism", required = true)
    @NotNull(message = "TitleType.ownerProducer {javax.validation.constraints.NotNull.message}")
    protected List<String> ownerProducer;
    @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
    protected Boolean joint;
    @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMSCIControlsValues> scIcontrols;
    @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
    protected List<String> sarIdentifier;
    @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
    protected List<String> atomicEnergyMarkings;
    @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMDissemValues> disseminationControls;
    @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> displayOnlyTo;
    @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceOpen;
    @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceProtected;
    @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> releasableTo;
    @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonICValues> nonICmarkings;
    @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String classifiedBy;
    @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String compilationReason;
    @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivativelyClassifiedBy;
    @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 4096)
    protected String classificationReason;
    @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonUSControlsValues> nonUSControls;
    @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivedFrom;
    @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
    protected XMLGregorianCalendar declassDate;
    @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String declassEvent;
    @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
    protected CVEnumISM25X declassException;

    /**
     * type created to ensure an element / attribute is comprised of more than whitespace, tab, newline, etc.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setValue(String value) {
        this.value = value;
    }

    public boolean isSetValue() {
        return (this.value!= null);
    }

    /**
     * Gets the value of the classification property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public CVEnumISMClassificationAll getClassification() {
        return classification;
    }

    /**
     * Sets the value of the classification property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public void setClassification(CVEnumISMClassificationAll value) {
        this.classification = value;
    }

    public boolean isSetClassification() {
        return (this.classification!= null);
    }

    /**
     * Gets the value of the ownerProducer property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOwnerProducer().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getOwnerProducer() {
        if (ownerProducer == null) {
            ownerProducer = new ArrayList<String>();
        }
        return this.ownerProducer;
    }

    public boolean isSetOwnerProducer() {
        return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
    }

    public void unsetOwnerProducer() {
        this.ownerProducer = null;
    }

    /**
     * Gets the value of the joint property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean getJoint() {
        return joint;
    }

    /**
     * Sets the value of the joint property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setJoint(boolean value) {
        this.joint = value;
    }

    public boolean isSetJoint() {
        return (this.joint!= null);
    }

    public void unsetJoint() {
        this.joint = null;
    }

    /**
     * Gets the value of the scIcontrols property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSCIcontrols().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMSCIControlsValues }
     * 
     * 
     */
    public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
        if (scIcontrols == null) {
            scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
        }
        return this.scIcontrols;
    }

    public boolean isSetSCIcontrols() {
        return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
    }

    public void unsetSCIcontrols() {
        this.scIcontrols = null;
    }

    /**
     * Gets the value of the sarIdentifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSARIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSARIdentifier() {
        if (sarIdentifier == null) {
            sarIdentifier = new ArrayList<String>();
        }
        return this.sarIdentifier;
    }

    public boolean isSetSARIdentifier() {
        return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
    }

    public void unsetSARIdentifier() {
        this.sarIdentifier = null;
    }

    /**
     * Gets the value of the atomicEnergyMarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAtomicEnergyMarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getAtomicEnergyMarkings() {
        if (atomicEnergyMarkings == null) {
            atomicEnergyMarkings = new ArrayList<String>();
        }
        return this.atomicEnergyMarkings;
    }

    public boolean isSetAtomicEnergyMarkings() {
        return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
    }

    public void unsetAtomicEnergyMarkings() {
        this.atomicEnergyMarkings = null;
    }

    /**
     * Gets the value of the disseminationControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisseminationControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMDissemValues }
     * 
     * 
     */
    public List<CVEnumISMDissemValues> getDisseminationControls() {
        if (disseminationControls == null) {
            disseminationControls = new ArrayList<CVEnumISMDissemValues>();
        }
        return this.disseminationControls;
    }

    public boolean isSetDisseminationControls() {
        return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
    }

    public void unsetDisseminationControls() {
        this.disseminationControls = null;
    }

    /**
     * Gets the value of the displayOnlyTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisplayOnlyTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getDisplayOnlyTo() {
        if (displayOnlyTo == null) {
            displayOnlyTo = new ArrayList<String>();
        }
        return this.displayOnlyTo;
    }

    public boolean isSetDisplayOnlyTo() {
        return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
    }

    public void unsetDisplayOnlyTo() {
        this.displayOnlyTo = null;
    }

    /**
     * Gets the value of the fgIsourceOpen property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceOpen().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceOpen() {
        if (fgIsourceOpen == null) {
            fgIsourceOpen = new ArrayList<String>();
        }
        return this.fgIsourceOpen;
    }

    public boolean isSetFGIsourceOpen() {
        return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
    }

    public void unsetFGIsourceOpen() {
        this.fgIsourceOpen = null;
    }

    /**
     * Gets the value of the fgIsourceProtected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceProtected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceProtected() {
        if (fgIsourceProtected == null) {
            fgIsourceProtected = new ArrayList<String>();
        }
        return this.fgIsourceProtected;
    }

    public boolean isSetFGIsourceProtected() {
        return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
    }

    public void unsetFGIsourceProtected() {
        this.fgIsourceProtected = null;
    }

    /**
     * Gets the value of the releasableTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReleasableTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getReleasableTo() {
        if (releasableTo == null) {
            releasableTo = new ArrayList<String>();
        }
        return this.releasableTo;
    }

    public boolean isSetReleasableTo() {
        return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
    }

    public void unsetReleasableTo() {
        this.releasableTo = null;
    }

    /**
     * Gets the value of the nonICmarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonICmarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonICValues }
     * 
     * 
     */
    public List<CVEnumISMNonICValues> getNonICmarkings() {
        if (nonICmarkings == null) {
            nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
        }
        return this.nonICmarkings;
    }

    public boolean isSetNonICmarkings() {
        return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
    }

    public void unsetNonICmarkings() {
        this.nonICmarkings = null;
    }

    /**
     * Gets the value of the classifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassifiedBy() {
        return classifiedBy;
    }

    /**
     * Sets the value of the classifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassifiedBy(String value) {
        this.classifiedBy = value;
    }

    public boolean isSetClassifiedBy() {
        return (this.classifiedBy!= null);
    }

    /**
     * Gets the value of the compilationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getCompilationReason() {
        return compilationReason;
    }

    /**
     * Sets the value of the compilationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCompilationReason(String value) {
        this.compilationReason = value;
    }

    public boolean isSetCompilationReason() {
        return (this.compilationReason!= null);
    }

    /**
     * Gets the value of the derivativelyClassifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivativelyClassifiedBy() {
        return derivativelyClassifiedBy;
    }

    /**
     * Sets the value of the derivativelyClassifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivativelyClassifiedBy(String value) {
        this.derivativelyClassifiedBy = value;
    }

    public boolean isSetDerivativelyClassifiedBy() {
        return (this.derivativelyClassifiedBy!= null);
    }

    /**
     * Gets the value of the classificationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassificationReason() {
        return classificationReason;
    }

    /**
     * Sets the value of the classificationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassificationReason(String value) {
        this.classificationReason = value;
    }

    public boolean isSetClassificationReason() {
        return (this.classificationReason!= null);
    }

    /**
     * Gets the value of the nonUSControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonUSControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonUSControlsValues }
     * 
     * 
     */
    public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
        if (nonUSControls == null) {
            nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
        }
        return this.nonUSControls;
    }

    public boolean isSetNonUSControls() {
        return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
    }

    public void unsetNonUSControls() {
        this.nonUSControls = null;
    }

    /**
     * Gets the value of the derivedFrom property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivedFrom() {
        return derivedFrom;
    }

    /**
     * Sets the value of the derivedFrom property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivedFrom(String value) {
        this.derivedFrom = value;
    }

    public boolean isSetDerivedFrom() {
        return (this.derivedFrom!= null);
    }

    /**
     * Gets the value of the declassDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getDeclassDate() {
        return declassDate;
    }

    /**
     * Sets the value of the declassDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setDeclassDate(XMLGregorianCalendar value) {
        this.declassDate = value;
    }

    public boolean isSetDeclassDate() {
        return (this.declassDate!= null);
    }

    /**
     * Gets the value of the declassEvent property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDeclassEvent() {
        return declassEvent;
    }

    /**
     * Sets the value of the declassEvent property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDeclassEvent(String value) {
        this.declassEvent = value;
    }

    public boolean isSetDeclassEvent() {
        return (this.declassEvent!= null);
    }

    /**
     * Gets the value of the declassException property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISM25X }
     *     
     */
    public CVEnumISM25X getDeclassException() {
        return declassException;
    }

    /**
     * Sets the value of the declassException property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISM25X }
     *     
     */
    public void setDeclassException(CVEnumISM25X value) {
        this.declassException = value;
    }

    public boolean isSetDeclassException() {
        return (this.declassException!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            String theValue;
            theValue = this.getValue();
            strategy.appendField(locator, this, "value", buffer, theValue, this.isSetValue());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final TitleType that = ((TitleType) object);
        {
            String lhsValue;
            lhsValue = this.getValue();
            String rhsValue;
            rhsValue = that.getValue();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "value", lhsValue), LocatorUtils.property(thatLocator, "value", rhsValue), lhsValue, rhsValue, this.isSetValue(), that.isSetValue())) {
                return false;
            }
        }
        {
            CVEnumISMClassificationAll lhsClassification;
            lhsClassification = this.getClassification();
            CVEnumISMClassificationAll rhsClassification;
            rhsClassification = that.getClassification();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                return false;
            }
        }
        {
            List<String> lhsOwnerProducer;
            lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            List<String> rhsOwnerProducer;
            rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                return false;
            }
        }
        {
            boolean lhsJoint;
            lhsJoint = (this.isSetJoint()?this.getJoint():false);
            boolean rhsJoint;
            rhsJoint = (that.isSetJoint()?that.getJoint():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                return false;
            }
        }
        {
            List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
            lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
            rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                return false;
            }
        }
        {
            List<String> lhsSARIdentifier;
            lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            List<String> rhsSARIdentifier;
            rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                return false;
            }
        }
        {
            List<String> lhsAtomicEnergyMarkings;
            lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            List<String> rhsAtomicEnergyMarkings;
            rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                return false;
            }
        }
        {
            List<CVEnumISMDissemValues> lhsDisseminationControls;
            lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            List<CVEnumISMDissemValues> rhsDisseminationControls;
            rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                return false;
            }
        }
        {
            List<String> lhsDisplayOnlyTo;
            lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            List<String> rhsDisplayOnlyTo;
            rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceOpen;
            lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            List<String> rhsFGIsourceOpen;
            rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceProtected;
            lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            List<String> rhsFGIsourceProtected;
            rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                return false;
            }
        }
        {
            List<String> lhsReleasableTo;
            lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            List<String> rhsReleasableTo;
            rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonICValues> lhsNonICmarkings;
            lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            List<CVEnumISMNonICValues> rhsNonICmarkings;
            rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                return false;
            }
        }
        {
            String lhsClassifiedBy;
            lhsClassifiedBy = this.getClassifiedBy();
            String rhsClassifiedBy;
            rhsClassifiedBy = that.getClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsCompilationReason;
            lhsCompilationReason = this.getCompilationReason();
            String rhsCompilationReason;
            rhsCompilationReason = that.getCompilationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                return false;
            }
        }
        {
            String lhsDerivativelyClassifiedBy;
            lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            String rhsDerivativelyClassifiedBy;
            rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsClassificationReason;
            lhsClassificationReason = this.getClassificationReason();
            String rhsClassificationReason;
            rhsClassificationReason = that.getClassificationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
            lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
            rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                return false;
            }
        }
        {
            String lhsDerivedFrom;
            lhsDerivedFrom = this.getDerivedFrom();
            String rhsDerivedFrom;
            rhsDerivedFrom = that.getDerivedFrom();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                return false;
            }
        }
        {
            XMLGregorianCalendar lhsDeclassDate;
            lhsDeclassDate = this.getDeclassDate();
            XMLGregorianCalendar rhsDeclassDate;
            rhsDeclassDate = that.getDeclassDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                return false;
            }
        }
        {
            String lhsDeclassEvent;
            lhsDeclassEvent = this.getDeclassEvent();
            String rhsDeclassEvent;
            rhsDeclassEvent = that.getDeclassEvent();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                return false;
            }
        }
        {
            CVEnumISM25X lhsDeclassException;
            lhsDeclassException = this.getDeclassException();
            CVEnumISM25X rhsDeclassException;
            rhsDeclassException = that.getDeclassException();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            String theValue;
            theValue = this.getValue();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "value", theValue), currentHashCode, theValue, this.isSetValue());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof TitleType) {
            final TitleType copy = ((TitleType) draftCopy);
            {
                Boolean valueShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetValue());
                if (valueShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceValue;
                    sourceValue = this.getValue();
                    String copyValue = ((String) strategy.copy(LocatorUtils.property(locator, "value", sourceValue), sourceValue, this.isSetValue()));
                    copy.setValue(copyValue);
                } else {
                    if (valueShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.value = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll sourceClassification;
                    sourceClassification = this.getClassification();
                    CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                    copy.setClassification(copyClassification);
                } else {
                    if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceOwnerProducer;
                    sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                    copy.unsetOwnerProducer();
                    if (copyOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(copyOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                    boolean sourceJoint;
                    sourceJoint = (this.isSetJoint()?this.getJoint():false);
                    boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                    copy.setJoint(copyJoint);
                } else {
                    if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                    sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                    copy.unsetSCIcontrols();
                    if (copySCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(copySCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceSARIdentifier;
                    sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                    @SuppressWarnings("unchecked")
                    List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                    copy.unsetSARIdentifier();
                    if (copySARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(copySARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceAtomicEnergyMarkings;
                    sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                    copy.unsetAtomicEnergyMarkings();
                    if (copyAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> sourceDisseminationControls;
                    sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                    copy.unsetDisseminationControls();
                    if (copyDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceDisplayOnlyTo;
                    sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                    copy.unsetDisplayOnlyTo();
                    if (copyDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceOpen;
                    sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                    copy.unsetFGIsourceOpen();
                    if (copyFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceProtected;
                    sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                    copy.unsetFGIsourceProtected();
                    if (copyFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceReleasableTo;
                    sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                    copy.unsetReleasableTo();
                    if (copyReleasableTo!= null) {
                        List<String> uniqueReleasableTol = copy.getReleasableTo();
                        uniqueReleasableTol.addAll(copyReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> sourceNonICmarkings;
                    sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                    copy.unsetNonICmarkings();
                    if (copyNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassifiedBy;
                    sourceClassifiedBy = this.getClassifiedBy();
                    String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                    copy.setClassifiedBy(copyClassifiedBy);
                } else {
                    if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceCompilationReason;
                    sourceCompilationReason = this.getCompilationReason();
                    String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                    copy.setCompilationReason(copyCompilationReason);
                } else {
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivativelyClassifiedBy;
                    sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                    String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                    copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassificationReason;
                    sourceClassificationReason = this.getClassificationReason();
                    String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                    copy.setClassificationReason(copyClassificationReason);
                } else {
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                    sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                    copy.unsetNonUSControls();
                    if (copyNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                        uniqueNonUSControlsl.addAll(copyNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivedFrom;
                    sourceDerivedFrom = this.getDerivedFrom();
                    String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                    copy.setDerivedFrom(copyDerivedFrom);
                } else {
                    if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar sourceDeclassDate;
                    sourceDeclassDate = this.getDeclassDate();
                    XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                    copy.setDeclassDate(copyDeclassDate);
                } else {
                    if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDeclassEvent;
                    sourceDeclassEvent = this.getDeclassEvent();
                    String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                    copy.setDeclassEvent(copyDeclassEvent);
                } else {
                    if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISM25X sourceDeclassException;
                    sourceDeclassException = this.getDeclassException();
                    CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                    copy.setDeclassException(copyDeclassException);
                } else {
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassException = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new TitleType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof TitleType) {
            final TitleType target = this;
            final TitleType leftObject = ((TitleType) left);
            final TitleType rightObject = ((TitleType) right);
            {
                Boolean valueShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetValue(), rightObject.isSetValue());
                if (valueShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsValue;
                    lhsValue = leftObject.getValue();
                    String rhsValue;
                    rhsValue = rightObject.getValue();
                    String mergedValue = ((String) strategy.merge(LocatorUtils.property(leftLocator, "value", lhsValue), LocatorUtils.property(rightLocator, "value", rhsValue), lhsValue, rhsValue, leftObject.isSetValue(), rightObject.isSetValue()));
                    target.setValue(mergedValue);
                } else {
                    if (valueShouldBeMergedAndSet == Boolean.FALSE) {
                        target.value = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll lhsClassification;
                    lhsClassification = leftObject.getClassification();
                    CVEnumISMClassificationAll rhsClassification;
                    rhsClassification = rightObject.getClassification();
                    CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                    target.setClassification(mergedClassification);
                } else {
                    if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsOwnerProducer;
                    lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                    List<String> rhsOwnerProducer;
                    rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                    List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                    target.unsetOwnerProducer();
                    if (mergedOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                    boolean lhsJoint;
                    lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                    boolean rhsJoint;
                    rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                    boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                    target.setJoint(mergedJoint);
                } else {
                    if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                    lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                    rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                    target.unsetSCIcontrols();
                    if (mergedSCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsSARIdentifier;
                    lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                    List<String> rhsSARIdentifier;
                    rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                    List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                    target.unsetSARIdentifier();
                    if (mergedSARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsAtomicEnergyMarkings;
                    lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                    List<String> rhsAtomicEnergyMarkings;
                    rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                    List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                    target.unsetAtomicEnergyMarkings();
                    if (mergedAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> lhsDisseminationControls;
                    lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> rhsDisseminationControls;
                    rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                    target.unsetDisseminationControls();
                    if (mergedDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsDisplayOnlyTo;
                    lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                    List<String> rhsDisplayOnlyTo;
                    rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                    List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                    target.unsetDisplayOnlyTo();
                    if (mergedDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceOpen;
                    lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                    List<String> rhsFGIsourceOpen;
                    rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                    List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                    target.unsetFGIsourceOpen();
                    if (mergedFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceProtected;
                    lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                    List<String> rhsFGIsourceProtected;
                    rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                    List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                    target.unsetFGIsourceProtected();
                    if (mergedFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsReleasableTo;
                    lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                    List<String> rhsReleasableTo;
                    rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                    List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                    target.unsetReleasableTo();
                    if (mergedReleasableTo!= null) {
                        List<String> uniqueReleasableTol = target.getReleasableTo();
                        uniqueReleasableTol.addAll(mergedReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> lhsNonICmarkings;
                    lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> rhsNonICmarkings;
                    rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                    target.unsetNonICmarkings();
                    if (mergedNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassifiedBy;
                    lhsClassifiedBy = leftObject.getClassifiedBy();
                    String rhsClassifiedBy;
                    rhsClassifiedBy = rightObject.getClassifiedBy();
                    String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                    target.setClassifiedBy(mergedClassifiedBy);
                } else {
                    if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsCompilationReason;
                    lhsCompilationReason = leftObject.getCompilationReason();
                    String rhsCompilationReason;
                    rhsCompilationReason = rightObject.getCompilationReason();
                    String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                    target.setCompilationReason(mergedCompilationReason);
                } else {
                    if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivativelyClassifiedBy;
                    lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                    String rhsDerivativelyClassifiedBy;
                    rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                    String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                    target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassificationReason;
                    lhsClassificationReason = leftObject.getClassificationReason();
                    String rhsClassificationReason;
                    rhsClassificationReason = rightObject.getClassificationReason();
                    String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                    target.setClassificationReason(mergedClassificationReason);
                } else {
                    if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                    lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                    rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                    target.unsetNonUSControls();
                    if (mergedNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                        uniqueNonUSControlsl.addAll(mergedNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivedFrom;
                    lhsDerivedFrom = leftObject.getDerivedFrom();
                    String rhsDerivedFrom;
                    rhsDerivedFrom = rightObject.getDerivedFrom();
                    String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                    target.setDerivedFrom(mergedDerivedFrom);
                } else {
                    if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar lhsDeclassDate;
                    lhsDeclassDate = leftObject.getDeclassDate();
                    XMLGregorianCalendar rhsDeclassDate;
                    rhsDeclassDate = rightObject.getDeclassDate();
                    XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                    target.setDeclassDate(mergedDeclassDate);
                } else {
                    if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDeclassEvent;
                    lhsDeclassEvent = leftObject.getDeclassEvent();
                    String rhsDeclassEvent;
                    rhsDeclassEvent = rightObject.getDeclassEvent();
                    String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                    target.setDeclassEvent(mergedDeclassEvent);
                } else {
                    if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISM25X lhsDeclassException;
                    lhsDeclassException = leftObject.getDeclassException();
                    CVEnumISM25X rhsDeclassException;
                    rhsDeclassException = rightObject.getDeclassException();
                    CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                    target.setDeclassException(mergedDeclassException);
                } else {
                    if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassException = null;
                    }
                }
            }
        }
    }

    public void setOwnerProducer(List<String> value) {
        this.ownerProducer = null;
        if (value!= null) {
            List<String> draftl = this.getOwnerProducer();
            draftl.addAll(value);
        }
    }

    public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
        this.scIcontrols = null;
        if (value!= null) {
            List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
            draftl.addAll(value);
        }
    }

    public void setSARIdentifier(List<String> value) {
        this.sarIdentifier = null;
        if (value!= null) {
            List<String> draftl = this.getSARIdentifier();
            draftl.addAll(value);
        }
    }

    public void setAtomicEnergyMarkings(List<String> value) {
        this.atomicEnergyMarkings = null;
        if (value!= null) {
            List<String> draftl = this.getAtomicEnergyMarkings();
            draftl.addAll(value);
        }
    }

    public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
        this.disseminationControls = null;
        if (value!= null) {
            List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
            draftl.addAll(value);
        }
    }

    public void setDisplayOnlyTo(List<String> value) {
        this.displayOnlyTo = null;
        if (value!= null) {
            List<String> draftl = this.getDisplayOnlyTo();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceOpen(List<String> value) {
        this.fgIsourceOpen = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceOpen();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceProtected(List<String> value) {
        this.fgIsourceProtected = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceProtected();
            draftl.addAll(value);
        }
    }

    public void setReleasableTo(List<String> value) {
        this.releasableTo = null;
        if (value!= null) {
            List<String> draftl = this.getReleasableTo();
            draftl.addAll(value);
        }
    }

    public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
        this.nonICmarkings = null;
        if (value!= null) {
            List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
            draftl.addAll(value);
        }
    }

    public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
        this.nonUSControls = null;
        if (value!= null) {
            List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
            draftl.addAll(value);
        }
    }

}
