//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
import javax.validation.constraints.Size;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import us.gov.ic.cvenum.ism._25x.CVEnumISM25X;
import us.gov.ic.cvenum.ism.classification.all.CVEnumISMClassificationAll;
import us.gov.ic.cvenum.ism.dissem.CVEnumISMDissemValues;
import us.gov.ic.cvenum.ism.nonic.CVEnumISMNonICValues;
import us.gov.ic.cvenum.ism.nonuscontrols.CVEnumISMNonUSControlsValues;
import us.gov.ic.cvenum.ism.scicontrols.CVEnumISMSCIControlsValues;


/**
 * <p>Java class for MetacardInfoType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="MetacardInfoType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence minOccurs="0"&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}identifier" maxOccurs="unbounded"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}dates"/&gt;
 *         &lt;choice maxOccurs="unbounded"&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}creator" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}publisher" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}contributor" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}pointOfContact" maxOccurs="unbounded"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}description" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}processingInfo" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}revisionRecall" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}recordsManagementInfo" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesOptionGroup"/&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "MetacardInfoType", propOrder = {
    "identifier",
    "dates",
    "creatorOrPublisherOrContributor",
    "description",
    "processingInfo",
    "revisionRecall",
    "recordsManagementInfo"
})
public class MetacardInfoType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @Size(min = 1)
    @Valid
    protected List<CompoundResourceIdentifierType> identifier;
    @Valid
    protected DatesType dates;
    @XmlElementRefs({
        @XmlElementRef(name = "publisher", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "contributor", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "pointOfContact", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "creator", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<ContactInfoType>> creatorOrPublisherOrContributor;
    @Valid
    protected DescriptionType description;
    @Valid
    protected List<ProcessingInfoType> processingInfo;
    @Valid
    protected RevisionRecallType revisionRecall;
    @Valid
    protected RecordsManagementInfoType recordsManagementInfo;
    @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism")
    protected CVEnumISMClassificationAll classification;
    @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism")
    protected List<String> ownerProducer;
    @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
    protected Boolean joint;
    @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMSCIControlsValues> scIcontrols;
    @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
    protected List<String> sarIdentifier;
    @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
    protected List<String> atomicEnergyMarkings;
    @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMDissemValues> disseminationControls;
    @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> displayOnlyTo;
    @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceOpen;
    @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceProtected;
    @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> releasableTo;
    @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonICValues> nonICmarkings;
    @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String classifiedBy;
    @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String compilationReason;
    @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivativelyClassifiedBy;
    @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 4096)
    protected String classificationReason;
    @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonUSControlsValues> nonUSControls;
    @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivedFrom;
    @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
    protected XMLGregorianCalendar declassDate;
    @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String declassEvent;
    @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
    protected CVEnumISM25X declassException;

    /**
     * Gets the value of the identifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CompoundResourceIdentifierType }
     * 
     * 
     */
    public List<CompoundResourceIdentifierType> getIdentifier() {
        if (identifier == null) {
            identifier = new ArrayList<CompoundResourceIdentifierType>();
        }
        return this.identifier;
    }

    public boolean isSetIdentifier() {
        return ((this.identifier!= null)&&(!this.identifier.isEmpty()));
    }

    public void unsetIdentifier() {
        this.identifier = null;
    }

    /**
     * Gets the value of the dates property.
     * 
     * @return
     *     possible object is
     *     {@link DatesType }
     *     
     */
    public DatesType getDates() {
        return dates;
    }

    /**
     * Sets the value of the dates property.
     * 
     * @param value
     *     allowed object is
     *     {@link DatesType }
     *     
     */
    public void setDates(DatesType value) {
        this.dates = value;
    }

    public boolean isSetDates() {
        return (this.dates!= null);
    }

    /**
     * Gets the value of the creatorOrPublisherOrContributor property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the creatorOrPublisherOrContributor property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCreatorOrPublisherOrContributor().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * 
     * 
     */
    public List<JAXBElement<ContactInfoType>> getCreatorOrPublisherOrContributor() {
        if (creatorOrPublisherOrContributor == null) {
            creatorOrPublisherOrContributor = new ArrayList<JAXBElement<ContactInfoType>>();
        }
        return this.creatorOrPublisherOrContributor;
    }

    public boolean isSetCreatorOrPublisherOrContributor() {
        return ((this.creatorOrPublisherOrContributor!= null)&&(!this.creatorOrPublisherOrContributor.isEmpty()));
    }

    public void unsetCreatorOrPublisherOrContributor() {
        this.creatorOrPublisherOrContributor = null;
    }

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link DescriptionType }
     *     
     */
    public DescriptionType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link DescriptionType }
     *     
     */
    public void setDescription(DescriptionType value) {
        this.description = value;
    }

    public boolean isSetDescription() {
        return (this.description!= null);
    }

    /**
     * Gets the value of the processingInfo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the processingInfo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProcessingInfo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcessingInfoType }
     * 
     * 
     */
    public List<ProcessingInfoType> getProcessingInfo() {
        if (processingInfo == null) {
            processingInfo = new ArrayList<ProcessingInfoType>();
        }
        return this.processingInfo;
    }

    public boolean isSetProcessingInfo() {
        return ((this.processingInfo!= null)&&(!this.processingInfo.isEmpty()));
    }

    public void unsetProcessingInfo() {
        this.processingInfo = null;
    }

    /**
     * Gets the value of the revisionRecall property.
     * 
     * @return
     *     possible object is
     *     {@link RevisionRecallType }
     *     
     */
    public RevisionRecallType getRevisionRecall() {
        return revisionRecall;
    }

    /**
     * Sets the value of the revisionRecall property.
     * 
     * @param value
     *     allowed object is
     *     {@link RevisionRecallType }
     *     
     */
    public void setRevisionRecall(RevisionRecallType value) {
        this.revisionRecall = value;
    }

    public boolean isSetRevisionRecall() {
        return (this.revisionRecall!= null);
    }

    /**
     * Gets the value of the recordsManagementInfo property.
     * 
     * @return
     *     possible object is
     *     {@link RecordsManagementInfoType }
     *     
     */
    public RecordsManagementInfoType getRecordsManagementInfo() {
        return recordsManagementInfo;
    }

    /**
     * Sets the value of the recordsManagementInfo property.
     * 
     * @param value
     *     allowed object is
     *     {@link RecordsManagementInfoType }
     *     
     */
    public void setRecordsManagementInfo(RecordsManagementInfoType value) {
        this.recordsManagementInfo = value;
    }

    public boolean isSetRecordsManagementInfo() {
        return (this.recordsManagementInfo!= null);
    }

    /**
     * Gets the value of the classification property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public CVEnumISMClassificationAll getClassification() {
        return classification;
    }

    /**
     * Sets the value of the classification property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public void setClassification(CVEnumISMClassificationAll value) {
        this.classification = value;
    }

    public boolean isSetClassification() {
        return (this.classification!= null);
    }

    /**
     * Gets the value of the ownerProducer property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOwnerProducer().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getOwnerProducer() {
        if (ownerProducer == null) {
            ownerProducer = new ArrayList<String>();
        }
        return this.ownerProducer;
    }

    public boolean isSetOwnerProducer() {
        return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
    }

    public void unsetOwnerProducer() {
        this.ownerProducer = null;
    }

    /**
     * Gets the value of the joint property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean getJoint() {
        return joint;
    }

    /**
     * Sets the value of the joint property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setJoint(boolean value) {
        this.joint = value;
    }

    public boolean isSetJoint() {
        return (this.joint!= null);
    }

    public void unsetJoint() {
        this.joint = null;
    }

    /**
     * Gets the value of the scIcontrols property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSCIcontrols().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMSCIControlsValues }
     * 
     * 
     */
    public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
        if (scIcontrols == null) {
            scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
        }
        return this.scIcontrols;
    }

    public boolean isSetSCIcontrols() {
        return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
    }

    public void unsetSCIcontrols() {
        this.scIcontrols = null;
    }

    /**
     * Gets the value of the sarIdentifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSARIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSARIdentifier() {
        if (sarIdentifier == null) {
            sarIdentifier = new ArrayList<String>();
        }
        return this.sarIdentifier;
    }

    public boolean isSetSARIdentifier() {
        return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
    }

    public void unsetSARIdentifier() {
        this.sarIdentifier = null;
    }

    /**
     * Gets the value of the atomicEnergyMarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAtomicEnergyMarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getAtomicEnergyMarkings() {
        if (atomicEnergyMarkings == null) {
            atomicEnergyMarkings = new ArrayList<String>();
        }
        return this.atomicEnergyMarkings;
    }

    public boolean isSetAtomicEnergyMarkings() {
        return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
    }

    public void unsetAtomicEnergyMarkings() {
        this.atomicEnergyMarkings = null;
    }

    /**
     * Gets the value of the disseminationControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisseminationControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMDissemValues }
     * 
     * 
     */
    public List<CVEnumISMDissemValues> getDisseminationControls() {
        if (disseminationControls == null) {
            disseminationControls = new ArrayList<CVEnumISMDissemValues>();
        }
        return this.disseminationControls;
    }

    public boolean isSetDisseminationControls() {
        return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
    }

    public void unsetDisseminationControls() {
        this.disseminationControls = null;
    }

    /**
     * Gets the value of the displayOnlyTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisplayOnlyTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getDisplayOnlyTo() {
        if (displayOnlyTo == null) {
            displayOnlyTo = new ArrayList<String>();
        }
        return this.displayOnlyTo;
    }

    public boolean isSetDisplayOnlyTo() {
        return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
    }

    public void unsetDisplayOnlyTo() {
        this.displayOnlyTo = null;
    }

    /**
     * Gets the value of the fgIsourceOpen property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceOpen().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceOpen() {
        if (fgIsourceOpen == null) {
            fgIsourceOpen = new ArrayList<String>();
        }
        return this.fgIsourceOpen;
    }

    public boolean isSetFGIsourceOpen() {
        return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
    }

    public void unsetFGIsourceOpen() {
        this.fgIsourceOpen = null;
    }

    /**
     * Gets the value of the fgIsourceProtected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceProtected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceProtected() {
        if (fgIsourceProtected == null) {
            fgIsourceProtected = new ArrayList<String>();
        }
        return this.fgIsourceProtected;
    }

    public boolean isSetFGIsourceProtected() {
        return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
    }

    public void unsetFGIsourceProtected() {
        this.fgIsourceProtected = null;
    }

    /**
     * Gets the value of the releasableTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReleasableTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getReleasableTo() {
        if (releasableTo == null) {
            releasableTo = new ArrayList<String>();
        }
        return this.releasableTo;
    }

    public boolean isSetReleasableTo() {
        return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
    }

    public void unsetReleasableTo() {
        this.releasableTo = null;
    }

    /**
     * Gets the value of the nonICmarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonICmarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonICValues }
     * 
     * 
     */
    public List<CVEnumISMNonICValues> getNonICmarkings() {
        if (nonICmarkings == null) {
            nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
        }
        return this.nonICmarkings;
    }

    public boolean isSetNonICmarkings() {
        return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
    }

    public void unsetNonICmarkings() {
        this.nonICmarkings = null;
    }

    /**
     * Gets the value of the classifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassifiedBy() {
        return classifiedBy;
    }

    /**
     * Sets the value of the classifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassifiedBy(String value) {
        this.classifiedBy = value;
    }

    public boolean isSetClassifiedBy() {
        return (this.classifiedBy!= null);
    }

    /**
     * Gets the value of the compilationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getCompilationReason() {
        return compilationReason;
    }

    /**
     * Sets the value of the compilationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCompilationReason(String value) {
        this.compilationReason = value;
    }

    public boolean isSetCompilationReason() {
        return (this.compilationReason!= null);
    }

    /**
     * Gets the value of the derivativelyClassifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivativelyClassifiedBy() {
        return derivativelyClassifiedBy;
    }

    /**
     * Sets the value of the derivativelyClassifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivativelyClassifiedBy(String value) {
        this.derivativelyClassifiedBy = value;
    }

    public boolean isSetDerivativelyClassifiedBy() {
        return (this.derivativelyClassifiedBy!= null);
    }

    /**
     * Gets the value of the classificationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassificationReason() {
        return classificationReason;
    }

    /**
     * Sets the value of the classificationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassificationReason(String value) {
        this.classificationReason = value;
    }

    public boolean isSetClassificationReason() {
        return (this.classificationReason!= null);
    }

    /**
     * Gets the value of the nonUSControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonUSControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonUSControlsValues }
     * 
     * 
     */
    public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
        if (nonUSControls == null) {
            nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
        }
        return this.nonUSControls;
    }

    public boolean isSetNonUSControls() {
        return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
    }

    public void unsetNonUSControls() {
        this.nonUSControls = null;
    }

    /**
     * Gets the value of the derivedFrom property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivedFrom() {
        return derivedFrom;
    }

    /**
     * Sets the value of the derivedFrom property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivedFrom(String value) {
        this.derivedFrom = value;
    }

    public boolean isSetDerivedFrom() {
        return (this.derivedFrom!= null);
    }

    /**
     * Gets the value of the declassDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getDeclassDate() {
        return declassDate;
    }

    /**
     * Sets the value of the declassDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setDeclassDate(XMLGregorianCalendar value) {
        this.declassDate = value;
    }

    public boolean isSetDeclassDate() {
        return (this.declassDate!= null);
    }

    /**
     * Gets the value of the declassEvent property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDeclassEvent() {
        return declassEvent;
    }

    /**
     * Sets the value of the declassEvent property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDeclassEvent(String value) {
        this.declassEvent = value;
    }

    public boolean isSetDeclassEvent() {
        return (this.declassEvent!= null);
    }

    /**
     * Gets the value of the declassException property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISM25X }
     *     
     */
    public CVEnumISM25X getDeclassException() {
        return declassException;
    }

    /**
     * Sets the value of the declassException property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISM25X }
     *     
     */
    public void setDeclassException(CVEnumISM25X value) {
        this.declassException = value;
    }

    public boolean isSetDeclassException() {
        return (this.declassException!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            List<CompoundResourceIdentifierType> theIdentifier;
            theIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            strategy.appendField(locator, this, "identifier", buffer, theIdentifier, this.isSetIdentifier());
        }
        {
            DatesType theDates;
            theDates = this.getDates();
            strategy.appendField(locator, this, "dates", buffer, theDates, this.isSetDates());
        }
        {
            List<JAXBElement<ContactInfoType>> theCreatorOrPublisherOrContributor;
            theCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            strategy.appendField(locator, this, "creatorOrPublisherOrContributor", buffer, theCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            strategy.appendField(locator, this, "description", buffer, theDescription, this.isSetDescription());
        }
        {
            List<ProcessingInfoType> theProcessingInfo;
            theProcessingInfo = (this.isSetProcessingInfo()?this.getProcessingInfo():null);
            strategy.appendField(locator, this, "processingInfo", buffer, theProcessingInfo, this.isSetProcessingInfo());
        }
        {
            RevisionRecallType theRevisionRecall;
            theRevisionRecall = this.getRevisionRecall();
            strategy.appendField(locator, this, "revisionRecall", buffer, theRevisionRecall, this.isSetRevisionRecall());
        }
        {
            RecordsManagementInfoType theRecordsManagementInfo;
            theRecordsManagementInfo = this.getRecordsManagementInfo();
            strategy.appendField(locator, this, "recordsManagementInfo", buffer, theRecordsManagementInfo, this.isSetRecordsManagementInfo());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final MetacardInfoType that = ((MetacardInfoType) object);
        {
            List<CompoundResourceIdentifierType> lhsIdentifier;
            lhsIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            List<CompoundResourceIdentifierType> rhsIdentifier;
            rhsIdentifier = (that.isSetIdentifier()?that.getIdentifier():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "identifier", lhsIdentifier), LocatorUtils.property(thatLocator, "identifier", rhsIdentifier), lhsIdentifier, rhsIdentifier, this.isSetIdentifier(), that.isSetIdentifier())) {
                return false;
            }
        }
        {
            DatesType lhsDates;
            lhsDates = this.getDates();
            DatesType rhsDates;
            rhsDates = that.getDates();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "dates", lhsDates), LocatorUtils.property(thatLocator, "dates", rhsDates), lhsDates, rhsDates, this.isSetDates(), that.isSetDates())) {
                return false;
            }
        }
        {
            List<JAXBElement<ContactInfoType>> lhsCreatorOrPublisherOrContributor;
            lhsCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            List<JAXBElement<ContactInfoType>> rhsCreatorOrPublisherOrContributor;
            rhsCreatorOrPublisherOrContributor = (that.isSetCreatorOrPublisherOrContributor()?that.getCreatorOrPublisherOrContributor():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "creatorOrPublisherOrContributor", lhsCreatorOrPublisherOrContributor), LocatorUtils.property(thatLocator, "creatorOrPublisherOrContributor", rhsCreatorOrPublisherOrContributor), lhsCreatorOrPublisherOrContributor, rhsCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor(), that.isSetCreatorOrPublisherOrContributor())) {
                return false;
            }
        }
        {
            DescriptionType lhsDescription;
            lhsDescription = this.getDescription();
            DescriptionType rhsDescription;
            rhsDescription = that.getDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription, this.isSetDescription(), that.isSetDescription())) {
                return false;
            }
        }
        {
            List<ProcessingInfoType> lhsProcessingInfo;
            lhsProcessingInfo = (this.isSetProcessingInfo()?this.getProcessingInfo():null);
            List<ProcessingInfoType> rhsProcessingInfo;
            rhsProcessingInfo = (that.isSetProcessingInfo()?that.getProcessingInfo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "processingInfo", lhsProcessingInfo), LocatorUtils.property(thatLocator, "processingInfo", rhsProcessingInfo), lhsProcessingInfo, rhsProcessingInfo, this.isSetProcessingInfo(), that.isSetProcessingInfo())) {
                return false;
            }
        }
        {
            RevisionRecallType lhsRevisionRecall;
            lhsRevisionRecall = this.getRevisionRecall();
            RevisionRecallType rhsRevisionRecall;
            rhsRevisionRecall = that.getRevisionRecall();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "revisionRecall", lhsRevisionRecall), LocatorUtils.property(thatLocator, "revisionRecall", rhsRevisionRecall), lhsRevisionRecall, rhsRevisionRecall, this.isSetRevisionRecall(), that.isSetRevisionRecall())) {
                return false;
            }
        }
        {
            RecordsManagementInfoType lhsRecordsManagementInfo;
            lhsRecordsManagementInfo = this.getRecordsManagementInfo();
            RecordsManagementInfoType rhsRecordsManagementInfo;
            rhsRecordsManagementInfo = that.getRecordsManagementInfo();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "recordsManagementInfo", lhsRecordsManagementInfo), LocatorUtils.property(thatLocator, "recordsManagementInfo", rhsRecordsManagementInfo), lhsRecordsManagementInfo, rhsRecordsManagementInfo, this.isSetRecordsManagementInfo(), that.isSetRecordsManagementInfo())) {
                return false;
            }
        }
        {
            CVEnumISMClassificationAll lhsClassification;
            lhsClassification = this.getClassification();
            CVEnumISMClassificationAll rhsClassification;
            rhsClassification = that.getClassification();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                return false;
            }
        }
        {
            List<String> lhsOwnerProducer;
            lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            List<String> rhsOwnerProducer;
            rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                return false;
            }
        }
        {
            boolean lhsJoint;
            lhsJoint = (this.isSetJoint()?this.getJoint():false);
            boolean rhsJoint;
            rhsJoint = (that.isSetJoint()?that.getJoint():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                return false;
            }
        }
        {
            List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
            lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
            rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                return false;
            }
        }
        {
            List<String> lhsSARIdentifier;
            lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            List<String> rhsSARIdentifier;
            rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                return false;
            }
        }
        {
            List<String> lhsAtomicEnergyMarkings;
            lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            List<String> rhsAtomicEnergyMarkings;
            rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                return false;
            }
        }
        {
            List<CVEnumISMDissemValues> lhsDisseminationControls;
            lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            List<CVEnumISMDissemValues> rhsDisseminationControls;
            rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                return false;
            }
        }
        {
            List<String> lhsDisplayOnlyTo;
            lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            List<String> rhsDisplayOnlyTo;
            rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceOpen;
            lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            List<String> rhsFGIsourceOpen;
            rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceProtected;
            lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            List<String> rhsFGIsourceProtected;
            rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                return false;
            }
        }
        {
            List<String> lhsReleasableTo;
            lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            List<String> rhsReleasableTo;
            rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonICValues> lhsNonICmarkings;
            lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            List<CVEnumISMNonICValues> rhsNonICmarkings;
            rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                return false;
            }
        }
        {
            String lhsClassifiedBy;
            lhsClassifiedBy = this.getClassifiedBy();
            String rhsClassifiedBy;
            rhsClassifiedBy = that.getClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsCompilationReason;
            lhsCompilationReason = this.getCompilationReason();
            String rhsCompilationReason;
            rhsCompilationReason = that.getCompilationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                return false;
            }
        }
        {
            String lhsDerivativelyClassifiedBy;
            lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            String rhsDerivativelyClassifiedBy;
            rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsClassificationReason;
            lhsClassificationReason = this.getClassificationReason();
            String rhsClassificationReason;
            rhsClassificationReason = that.getClassificationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
            lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
            rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                return false;
            }
        }
        {
            String lhsDerivedFrom;
            lhsDerivedFrom = this.getDerivedFrom();
            String rhsDerivedFrom;
            rhsDerivedFrom = that.getDerivedFrom();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                return false;
            }
        }
        {
            XMLGregorianCalendar lhsDeclassDate;
            lhsDeclassDate = this.getDeclassDate();
            XMLGregorianCalendar rhsDeclassDate;
            rhsDeclassDate = that.getDeclassDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                return false;
            }
        }
        {
            String lhsDeclassEvent;
            lhsDeclassEvent = this.getDeclassEvent();
            String rhsDeclassEvent;
            rhsDeclassEvent = that.getDeclassEvent();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                return false;
            }
        }
        {
            CVEnumISM25X lhsDeclassException;
            lhsDeclassException = this.getDeclassException();
            CVEnumISM25X rhsDeclassException;
            rhsDeclassException = that.getDeclassException();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            List<CompoundResourceIdentifierType> theIdentifier;
            theIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "identifier", theIdentifier), currentHashCode, theIdentifier, this.isSetIdentifier());
        }
        {
            DatesType theDates;
            theDates = this.getDates();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "dates", theDates), currentHashCode, theDates, this.isSetDates());
        }
        {
            List<JAXBElement<ContactInfoType>> theCreatorOrPublisherOrContributor;
            theCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "creatorOrPublisherOrContributor", theCreatorOrPublisherOrContributor), currentHashCode, theCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription, this.isSetDescription());
        }
        {
            List<ProcessingInfoType> theProcessingInfo;
            theProcessingInfo = (this.isSetProcessingInfo()?this.getProcessingInfo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "processingInfo", theProcessingInfo), currentHashCode, theProcessingInfo, this.isSetProcessingInfo());
        }
        {
            RevisionRecallType theRevisionRecall;
            theRevisionRecall = this.getRevisionRecall();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "revisionRecall", theRevisionRecall), currentHashCode, theRevisionRecall, this.isSetRevisionRecall());
        }
        {
            RecordsManagementInfoType theRecordsManagementInfo;
            theRecordsManagementInfo = this.getRecordsManagementInfo();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "recordsManagementInfo", theRecordsManagementInfo), currentHashCode, theRecordsManagementInfo, this.isSetRecordsManagementInfo());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof MetacardInfoType) {
            final MetacardInfoType copy = ((MetacardInfoType) draftCopy);
            {
                Boolean identifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetIdentifier());
                if (identifierShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CompoundResourceIdentifierType> sourceIdentifier;
                    sourceIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
                    @SuppressWarnings("unchecked")
                    List<CompoundResourceIdentifierType> copyIdentifier = ((List<CompoundResourceIdentifierType> ) strategy.copy(LocatorUtils.property(locator, "identifier", sourceIdentifier), sourceIdentifier, this.isSetIdentifier()));
                    copy.unsetIdentifier();
                    if (copyIdentifier!= null) {
                        List<CompoundResourceIdentifierType> uniqueIdentifierl = copy.getIdentifier();
                        uniqueIdentifierl.addAll(copyIdentifier);
                    }
                } else {
                    if (identifierShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetIdentifier();
                    }
                }
            }
            {
                Boolean datesShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDates());
                if (datesShouldBeCopiedAndSet == Boolean.TRUE) {
                    DatesType sourceDates;
                    sourceDates = this.getDates();
                    DatesType copyDates = ((DatesType) strategy.copy(LocatorUtils.property(locator, "dates", sourceDates), sourceDates, this.isSetDates()));
                    copy.setDates(copyDates);
                } else {
                    if (datesShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.dates = null;
                    }
                }
            }
            {
                Boolean creatorOrPublisherOrContributorShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCreatorOrPublisherOrContributor());
                if (creatorOrPublisherOrContributorShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<JAXBElement<ContactInfoType>> sourceCreatorOrPublisherOrContributor;
                    sourceCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
                    @SuppressWarnings("unchecked")
                    List<JAXBElement<ContactInfoType>> copyCreatorOrPublisherOrContributor = ((List<JAXBElement<ContactInfoType>> ) strategy.copy(LocatorUtils.property(locator, "creatorOrPublisherOrContributor", sourceCreatorOrPublisherOrContributor), sourceCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor()));
                    copy.unsetCreatorOrPublisherOrContributor();
                    if (copyCreatorOrPublisherOrContributor!= null) {
                        List<JAXBElement<ContactInfoType>> uniqueCreatorOrPublisherOrContributorl = copy.getCreatorOrPublisherOrContributor();
                        uniqueCreatorOrPublisherOrContributorl.addAll(copyCreatorOrPublisherOrContributor);
                    }
                } else {
                    if (creatorOrPublisherOrContributorShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetCreatorOrPublisherOrContributor();
                    }
                }
            }
            {
                Boolean descriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDescription());
                if (descriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    DescriptionType sourceDescription;
                    sourceDescription = this.getDescription();
                    DescriptionType copyDescription = ((DescriptionType) strategy.copy(LocatorUtils.property(locator, "description", sourceDescription), sourceDescription, this.isSetDescription()));
                    copy.setDescription(copyDescription);
                } else {
                    if (descriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.description = null;
                    }
                }
            }
            {
                Boolean processingInfoShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetProcessingInfo());
                if (processingInfoShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<ProcessingInfoType> sourceProcessingInfo;
                    sourceProcessingInfo = (this.isSetProcessingInfo()?this.getProcessingInfo():null);
                    @SuppressWarnings("unchecked")
                    List<ProcessingInfoType> copyProcessingInfo = ((List<ProcessingInfoType> ) strategy.copy(LocatorUtils.property(locator, "processingInfo", sourceProcessingInfo), sourceProcessingInfo, this.isSetProcessingInfo()));
                    copy.unsetProcessingInfo();
                    if (copyProcessingInfo!= null) {
                        List<ProcessingInfoType> uniqueProcessingInfol = copy.getProcessingInfo();
                        uniqueProcessingInfol.addAll(copyProcessingInfo);
                    }
                } else {
                    if (processingInfoShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetProcessingInfo();
                    }
                }
            }
            {
                Boolean revisionRecallShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRevisionRecall());
                if (revisionRecallShouldBeCopiedAndSet == Boolean.TRUE) {
                    RevisionRecallType sourceRevisionRecall;
                    sourceRevisionRecall = this.getRevisionRecall();
                    RevisionRecallType copyRevisionRecall = ((RevisionRecallType) strategy.copy(LocatorUtils.property(locator, "revisionRecall", sourceRevisionRecall), sourceRevisionRecall, this.isSetRevisionRecall()));
                    copy.setRevisionRecall(copyRevisionRecall);
                } else {
                    if (revisionRecallShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.revisionRecall = null;
                    }
                }
            }
            {
                Boolean recordsManagementInfoShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRecordsManagementInfo());
                if (recordsManagementInfoShouldBeCopiedAndSet == Boolean.TRUE) {
                    RecordsManagementInfoType sourceRecordsManagementInfo;
                    sourceRecordsManagementInfo = this.getRecordsManagementInfo();
                    RecordsManagementInfoType copyRecordsManagementInfo = ((RecordsManagementInfoType) strategy.copy(LocatorUtils.property(locator, "recordsManagementInfo", sourceRecordsManagementInfo), sourceRecordsManagementInfo, this.isSetRecordsManagementInfo()));
                    copy.setRecordsManagementInfo(copyRecordsManagementInfo);
                } else {
                    if (recordsManagementInfoShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.recordsManagementInfo = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll sourceClassification;
                    sourceClassification = this.getClassification();
                    CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                    copy.setClassification(copyClassification);
                } else {
                    if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceOwnerProducer;
                    sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                    copy.unsetOwnerProducer();
                    if (copyOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(copyOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                    boolean sourceJoint;
                    sourceJoint = (this.isSetJoint()?this.getJoint():false);
                    boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                    copy.setJoint(copyJoint);
                } else {
                    if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                    sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                    copy.unsetSCIcontrols();
                    if (copySCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(copySCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceSARIdentifier;
                    sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                    @SuppressWarnings("unchecked")
                    List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                    copy.unsetSARIdentifier();
                    if (copySARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(copySARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceAtomicEnergyMarkings;
                    sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                    copy.unsetAtomicEnergyMarkings();
                    if (copyAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> sourceDisseminationControls;
                    sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                    copy.unsetDisseminationControls();
                    if (copyDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceDisplayOnlyTo;
                    sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                    copy.unsetDisplayOnlyTo();
                    if (copyDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceOpen;
                    sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                    copy.unsetFGIsourceOpen();
                    if (copyFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceProtected;
                    sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                    copy.unsetFGIsourceProtected();
                    if (copyFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceReleasableTo;
                    sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                    copy.unsetReleasableTo();
                    if (copyReleasableTo!= null) {
                        List<String> uniqueReleasableTol = copy.getReleasableTo();
                        uniqueReleasableTol.addAll(copyReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> sourceNonICmarkings;
                    sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                    copy.unsetNonICmarkings();
                    if (copyNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassifiedBy;
                    sourceClassifiedBy = this.getClassifiedBy();
                    String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                    copy.setClassifiedBy(copyClassifiedBy);
                } else {
                    if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceCompilationReason;
                    sourceCompilationReason = this.getCompilationReason();
                    String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                    copy.setCompilationReason(copyCompilationReason);
                } else {
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivativelyClassifiedBy;
                    sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                    String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                    copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassificationReason;
                    sourceClassificationReason = this.getClassificationReason();
                    String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                    copy.setClassificationReason(copyClassificationReason);
                } else {
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                    sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                    copy.unsetNonUSControls();
                    if (copyNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                        uniqueNonUSControlsl.addAll(copyNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivedFrom;
                    sourceDerivedFrom = this.getDerivedFrom();
                    String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                    copy.setDerivedFrom(copyDerivedFrom);
                } else {
                    if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar sourceDeclassDate;
                    sourceDeclassDate = this.getDeclassDate();
                    XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                    copy.setDeclassDate(copyDeclassDate);
                } else {
                    if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDeclassEvent;
                    sourceDeclassEvent = this.getDeclassEvent();
                    String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                    copy.setDeclassEvent(copyDeclassEvent);
                } else {
                    if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISM25X sourceDeclassException;
                    sourceDeclassException = this.getDeclassException();
                    CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                    copy.setDeclassException(copyDeclassException);
                } else {
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassException = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new MetacardInfoType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof MetacardInfoType) {
            final MetacardInfoType target = this;
            final MetacardInfoType leftObject = ((MetacardInfoType) left);
            final MetacardInfoType rightObject = ((MetacardInfoType) right);
            {
                Boolean identifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetIdentifier(), rightObject.isSetIdentifier());
                if (identifierShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CompoundResourceIdentifierType> lhsIdentifier;
                    lhsIdentifier = (leftObject.isSetIdentifier()?leftObject.getIdentifier():null);
                    List<CompoundResourceIdentifierType> rhsIdentifier;
                    rhsIdentifier = (rightObject.isSetIdentifier()?rightObject.getIdentifier():null);
                    List<CompoundResourceIdentifierType> mergedIdentifier = ((List<CompoundResourceIdentifierType> ) strategy.merge(LocatorUtils.property(leftLocator, "identifier", lhsIdentifier), LocatorUtils.property(rightLocator, "identifier", rhsIdentifier), lhsIdentifier, rhsIdentifier, leftObject.isSetIdentifier(), rightObject.isSetIdentifier()));
                    target.unsetIdentifier();
                    if (mergedIdentifier!= null) {
                        List<CompoundResourceIdentifierType> uniqueIdentifierl = target.getIdentifier();
                        uniqueIdentifierl.addAll(mergedIdentifier);
                    }
                } else {
                    if (identifierShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetIdentifier();
                    }
                }
            }
            {
                Boolean datesShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDates(), rightObject.isSetDates());
                if (datesShouldBeMergedAndSet == Boolean.TRUE) {
                    DatesType lhsDates;
                    lhsDates = leftObject.getDates();
                    DatesType rhsDates;
                    rhsDates = rightObject.getDates();
                    DatesType mergedDates = ((DatesType) strategy.merge(LocatorUtils.property(leftLocator, "dates", lhsDates), LocatorUtils.property(rightLocator, "dates", rhsDates), lhsDates, rhsDates, leftObject.isSetDates(), rightObject.isSetDates()));
                    target.setDates(mergedDates);
                } else {
                    if (datesShouldBeMergedAndSet == Boolean.FALSE) {
                        target.dates = null;
                    }
                }
            }
            {
                Boolean creatorOrPublisherOrContributorShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCreatorOrPublisherOrContributor(), rightObject.isSetCreatorOrPublisherOrContributor());
                if (creatorOrPublisherOrContributorShouldBeMergedAndSet == Boolean.TRUE) {
                    List<JAXBElement<ContactInfoType>> lhsCreatorOrPublisherOrContributor;
                    lhsCreatorOrPublisherOrContributor = (leftObject.isSetCreatorOrPublisherOrContributor()?leftObject.getCreatorOrPublisherOrContributor():null);
                    List<JAXBElement<ContactInfoType>> rhsCreatorOrPublisherOrContributor;
                    rhsCreatorOrPublisherOrContributor = (rightObject.isSetCreatorOrPublisherOrContributor()?rightObject.getCreatorOrPublisherOrContributor():null);
                    List<JAXBElement<ContactInfoType>> mergedCreatorOrPublisherOrContributor = ((List<JAXBElement<ContactInfoType>> ) strategy.merge(LocatorUtils.property(leftLocator, "creatorOrPublisherOrContributor", lhsCreatorOrPublisherOrContributor), LocatorUtils.property(rightLocator, "creatorOrPublisherOrContributor", rhsCreatorOrPublisherOrContributor), lhsCreatorOrPublisherOrContributor, rhsCreatorOrPublisherOrContributor, leftObject.isSetCreatorOrPublisherOrContributor(), rightObject.isSetCreatorOrPublisherOrContributor()));
                    target.unsetCreatorOrPublisherOrContributor();
                    if (mergedCreatorOrPublisherOrContributor!= null) {
                        List<JAXBElement<ContactInfoType>> uniqueCreatorOrPublisherOrContributorl = target.getCreatorOrPublisherOrContributor();
                        uniqueCreatorOrPublisherOrContributorl.addAll(mergedCreatorOrPublisherOrContributor);
                    }
                } else {
                    if (creatorOrPublisherOrContributorShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetCreatorOrPublisherOrContributor();
                    }
                }
            }
            {
                Boolean descriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDescription(), rightObject.isSetDescription());
                if (descriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    DescriptionType lhsDescription;
                    lhsDescription = leftObject.getDescription();
                    DescriptionType rhsDescription;
                    rhsDescription = rightObject.getDescription();
                    DescriptionType mergedDescription = ((DescriptionType) strategy.merge(LocatorUtils.property(leftLocator, "description", lhsDescription), LocatorUtils.property(rightLocator, "description", rhsDescription), lhsDescription, rhsDescription, leftObject.isSetDescription(), rightObject.isSetDescription()));
                    target.setDescription(mergedDescription);
                } else {
                    if (descriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.description = null;
                    }
                }
            }
            {
                Boolean processingInfoShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetProcessingInfo(), rightObject.isSetProcessingInfo());
                if (processingInfoShouldBeMergedAndSet == Boolean.TRUE) {
                    List<ProcessingInfoType> lhsProcessingInfo;
                    lhsProcessingInfo = (leftObject.isSetProcessingInfo()?leftObject.getProcessingInfo():null);
                    List<ProcessingInfoType> rhsProcessingInfo;
                    rhsProcessingInfo = (rightObject.isSetProcessingInfo()?rightObject.getProcessingInfo():null);
                    List<ProcessingInfoType> mergedProcessingInfo = ((List<ProcessingInfoType> ) strategy.merge(LocatorUtils.property(leftLocator, "processingInfo", lhsProcessingInfo), LocatorUtils.property(rightLocator, "processingInfo", rhsProcessingInfo), lhsProcessingInfo, rhsProcessingInfo, leftObject.isSetProcessingInfo(), rightObject.isSetProcessingInfo()));
                    target.unsetProcessingInfo();
                    if (mergedProcessingInfo!= null) {
                        List<ProcessingInfoType> uniqueProcessingInfol = target.getProcessingInfo();
                        uniqueProcessingInfol.addAll(mergedProcessingInfo);
                    }
                } else {
                    if (processingInfoShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetProcessingInfo();
                    }
                }
            }
            {
                Boolean revisionRecallShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRevisionRecall(), rightObject.isSetRevisionRecall());
                if (revisionRecallShouldBeMergedAndSet == Boolean.TRUE) {
                    RevisionRecallType lhsRevisionRecall;
                    lhsRevisionRecall = leftObject.getRevisionRecall();
                    RevisionRecallType rhsRevisionRecall;
                    rhsRevisionRecall = rightObject.getRevisionRecall();
                    RevisionRecallType mergedRevisionRecall = ((RevisionRecallType) strategy.merge(LocatorUtils.property(leftLocator, "revisionRecall", lhsRevisionRecall), LocatorUtils.property(rightLocator, "revisionRecall", rhsRevisionRecall), lhsRevisionRecall, rhsRevisionRecall, leftObject.isSetRevisionRecall(), rightObject.isSetRevisionRecall()));
                    target.setRevisionRecall(mergedRevisionRecall);
                } else {
                    if (revisionRecallShouldBeMergedAndSet == Boolean.FALSE) {
                        target.revisionRecall = null;
                    }
                }
            }
            {
                Boolean recordsManagementInfoShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRecordsManagementInfo(), rightObject.isSetRecordsManagementInfo());
                if (recordsManagementInfoShouldBeMergedAndSet == Boolean.TRUE) {
                    RecordsManagementInfoType lhsRecordsManagementInfo;
                    lhsRecordsManagementInfo = leftObject.getRecordsManagementInfo();
                    RecordsManagementInfoType rhsRecordsManagementInfo;
                    rhsRecordsManagementInfo = rightObject.getRecordsManagementInfo();
                    RecordsManagementInfoType mergedRecordsManagementInfo = ((RecordsManagementInfoType) strategy.merge(LocatorUtils.property(leftLocator, "recordsManagementInfo", lhsRecordsManagementInfo), LocatorUtils.property(rightLocator, "recordsManagementInfo", rhsRecordsManagementInfo), lhsRecordsManagementInfo, rhsRecordsManagementInfo, leftObject.isSetRecordsManagementInfo(), rightObject.isSetRecordsManagementInfo()));
                    target.setRecordsManagementInfo(mergedRecordsManagementInfo);
                } else {
                    if (recordsManagementInfoShouldBeMergedAndSet == Boolean.FALSE) {
                        target.recordsManagementInfo = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll lhsClassification;
                    lhsClassification = leftObject.getClassification();
                    CVEnumISMClassificationAll rhsClassification;
                    rhsClassification = rightObject.getClassification();
                    CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                    target.setClassification(mergedClassification);
                } else {
                    if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsOwnerProducer;
                    lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                    List<String> rhsOwnerProducer;
                    rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                    List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                    target.unsetOwnerProducer();
                    if (mergedOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                    boolean lhsJoint;
                    lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                    boolean rhsJoint;
                    rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                    boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                    target.setJoint(mergedJoint);
                } else {
                    if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                    lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                    rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                    target.unsetSCIcontrols();
                    if (mergedSCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsSARIdentifier;
                    lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                    List<String> rhsSARIdentifier;
                    rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                    List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                    target.unsetSARIdentifier();
                    if (mergedSARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsAtomicEnergyMarkings;
                    lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                    List<String> rhsAtomicEnergyMarkings;
                    rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                    List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                    target.unsetAtomicEnergyMarkings();
                    if (mergedAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> lhsDisseminationControls;
                    lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> rhsDisseminationControls;
                    rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                    target.unsetDisseminationControls();
                    if (mergedDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsDisplayOnlyTo;
                    lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                    List<String> rhsDisplayOnlyTo;
                    rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                    List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                    target.unsetDisplayOnlyTo();
                    if (mergedDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceOpen;
                    lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                    List<String> rhsFGIsourceOpen;
                    rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                    List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                    target.unsetFGIsourceOpen();
                    if (mergedFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceProtected;
                    lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                    List<String> rhsFGIsourceProtected;
                    rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                    List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                    target.unsetFGIsourceProtected();
                    if (mergedFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsReleasableTo;
                    lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                    List<String> rhsReleasableTo;
                    rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                    List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                    target.unsetReleasableTo();
                    if (mergedReleasableTo!= null) {
                        List<String> uniqueReleasableTol = target.getReleasableTo();
                        uniqueReleasableTol.addAll(mergedReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> lhsNonICmarkings;
                    lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> rhsNonICmarkings;
                    rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                    target.unsetNonICmarkings();
                    if (mergedNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassifiedBy;
                    lhsClassifiedBy = leftObject.getClassifiedBy();
                    String rhsClassifiedBy;
                    rhsClassifiedBy = rightObject.getClassifiedBy();
                    String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                    target.setClassifiedBy(mergedClassifiedBy);
                } else {
                    if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsCompilationReason;
                    lhsCompilationReason = leftObject.getCompilationReason();
                    String rhsCompilationReason;
                    rhsCompilationReason = rightObject.getCompilationReason();
                    String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                    target.setCompilationReason(mergedCompilationReason);
                } else {
                    if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivativelyClassifiedBy;
                    lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                    String rhsDerivativelyClassifiedBy;
                    rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                    String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                    target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassificationReason;
                    lhsClassificationReason = leftObject.getClassificationReason();
                    String rhsClassificationReason;
                    rhsClassificationReason = rightObject.getClassificationReason();
                    String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                    target.setClassificationReason(mergedClassificationReason);
                } else {
                    if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                    lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                    rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                    target.unsetNonUSControls();
                    if (mergedNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                        uniqueNonUSControlsl.addAll(mergedNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivedFrom;
                    lhsDerivedFrom = leftObject.getDerivedFrom();
                    String rhsDerivedFrom;
                    rhsDerivedFrom = rightObject.getDerivedFrom();
                    String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                    target.setDerivedFrom(mergedDerivedFrom);
                } else {
                    if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar lhsDeclassDate;
                    lhsDeclassDate = leftObject.getDeclassDate();
                    XMLGregorianCalendar rhsDeclassDate;
                    rhsDeclassDate = rightObject.getDeclassDate();
                    XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                    target.setDeclassDate(mergedDeclassDate);
                } else {
                    if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDeclassEvent;
                    lhsDeclassEvent = leftObject.getDeclassEvent();
                    String rhsDeclassEvent;
                    rhsDeclassEvent = rightObject.getDeclassEvent();
                    String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                    target.setDeclassEvent(mergedDeclassEvent);
                } else {
                    if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISM25X lhsDeclassException;
                    lhsDeclassException = leftObject.getDeclassException();
                    CVEnumISM25X rhsDeclassException;
                    rhsDeclassException = rightObject.getDeclassException();
                    CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                    target.setDeclassException(mergedDeclassException);
                } else {
                    if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassException = null;
                    }
                }
            }
        }
    }

    public void setIdentifier(List<CompoundResourceIdentifierType> value) {
        this.identifier = null;
        if (value!= null) {
            List<CompoundResourceIdentifierType> draftl = this.getIdentifier();
            draftl.addAll(value);
        }
    }

    public void setCreatorOrPublisherOrContributor(List<JAXBElement<ContactInfoType>> value) {
        this.creatorOrPublisherOrContributor = null;
        if (value!= null) {
            List<JAXBElement<ContactInfoType>> draftl = this.getCreatorOrPublisherOrContributor();
            draftl.addAll(value);
        }
    }

    public void setProcessingInfo(List<ProcessingInfoType> value) {
        this.processingInfo = null;
        if (value!= null) {
            List<ProcessingInfoType> draftl = this.getProcessingInfo();
            draftl.addAll(value);
        }
    }

    public void setOwnerProducer(List<String> value) {
        this.ownerProducer = null;
        if (value!= null) {
            List<String> draftl = this.getOwnerProducer();
            draftl.addAll(value);
        }
    }

    public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
        this.scIcontrols = null;
        if (value!= null) {
            List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
            draftl.addAll(value);
        }
    }

    public void setSARIdentifier(List<String> value) {
        this.sarIdentifier = null;
        if (value!= null) {
            List<String> draftl = this.getSARIdentifier();
            draftl.addAll(value);
        }
    }

    public void setAtomicEnergyMarkings(List<String> value) {
        this.atomicEnergyMarkings = null;
        if (value!= null) {
            List<String> draftl = this.getAtomicEnergyMarkings();
            draftl.addAll(value);
        }
    }

    public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
        this.disseminationControls = null;
        if (value!= null) {
            List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
            draftl.addAll(value);
        }
    }

    public void setDisplayOnlyTo(List<String> value) {
        this.displayOnlyTo = null;
        if (value!= null) {
            List<String> draftl = this.getDisplayOnlyTo();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceOpen(List<String> value) {
        this.fgIsourceOpen = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceOpen();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceProtected(List<String> value) {
        this.fgIsourceProtected = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceProtected();
            draftl.addAll(value);
        }
    }

    public void setReleasableTo(List<String> value) {
        this.releasableTo = null;
        if (value!= null) {
            List<String> draftl = this.getReleasableTo();
            draftl.addAll(value);
        }
    }

    public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
        this.nonICmarkings = null;
        if (value!= null) {
            List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
            draftl.addAll(value);
        }
    }

    public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
        this.nonUSControls = null;
        if (value!= null) {
            List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
            draftl.addAll(value);
        }
    }

}
