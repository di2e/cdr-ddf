//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import javax.validation.Valid;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for ApproximableDateType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ApproximableDateType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;all&gt;
 *         &lt;element name="description" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" minOccurs="0"/&gt;
 *         &lt;element name="approximableDate" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;simpleContent&gt;
 *               &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;CombinedDateType"&gt;
 *                 &lt;attribute name="approximation" type="{urn:us:mil:ces:metadata:ddms:5}DateApproximationEnumerationType" /&gt;
 *               &lt;/extension&gt;
 *             &lt;/simpleContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="searchableDate" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence minOccurs="0"&gt;
 *                   &lt;element name="start" type="{urn:us:mil:ces:metadata:ddms:5}CombinedDateType" minOccurs="0"/&gt;
 *                   &lt;element name="end" type="{urn:us:mil:ces:metadata:ddms:5}CombinedDateType" minOccurs="0"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *       &lt;/all&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ApproximableDateType", propOrder = {

})
public class ApproximableDateType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "token")
    @Size(min = 1)
    protected String description;
    @Valid
    protected ApproximableDateType.ApproximableDate approximableDate;
    @Valid
    protected ApproximableDateType.SearchableDate searchableDate;

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDescription(String value) {
        this.description = value;
    }

    public boolean isSetDescription() {
        return (this.description!= null);
    }

    /**
     * Gets the value of the approximableDate property.
     * 
     * @return
     *     possible object is
     *     {@link ApproximableDateType.ApproximableDate }
     *     
     */
    public ApproximableDateType.ApproximableDate getApproximableDate() {
        return approximableDate;
    }

    /**
     * Sets the value of the approximableDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link ApproximableDateType.ApproximableDate }
     *     
     */
    public void setApproximableDate(ApproximableDateType.ApproximableDate value) {
        this.approximableDate = value;
    }

    public boolean isSetApproximableDate() {
        return (this.approximableDate!= null);
    }

    /**
     * Gets the value of the searchableDate property.
     * 
     * @return
     *     possible object is
     *     {@link ApproximableDateType.SearchableDate }
     *     
     */
    public ApproximableDateType.SearchableDate getSearchableDate() {
        return searchableDate;
    }

    /**
     * Sets the value of the searchableDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link ApproximableDateType.SearchableDate }
     *     
     */
    public void setSearchableDate(ApproximableDateType.SearchableDate value) {
        this.searchableDate = value;
    }

    public boolean isSetSearchableDate() {
        return (this.searchableDate!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            String theDescription;
            theDescription = this.getDescription();
            strategy.appendField(locator, this, "description", buffer, theDescription, this.isSetDescription());
        }
        {
            ApproximableDateType.ApproximableDate theApproximableDate;
            theApproximableDate = this.getApproximableDate();
            strategy.appendField(locator, this, "approximableDate", buffer, theApproximableDate, this.isSetApproximableDate());
        }
        {
            ApproximableDateType.SearchableDate theSearchableDate;
            theSearchableDate = this.getSearchableDate();
            strategy.appendField(locator, this, "searchableDate", buffer, theSearchableDate, this.isSetSearchableDate());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final ApproximableDateType that = ((ApproximableDateType) object);
        {
            String lhsDescription;
            lhsDescription = this.getDescription();
            String rhsDescription;
            rhsDescription = that.getDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription, this.isSetDescription(), that.isSetDescription())) {
                return false;
            }
        }
        {
            ApproximableDateType.ApproximableDate lhsApproximableDate;
            lhsApproximableDate = this.getApproximableDate();
            ApproximableDateType.ApproximableDate rhsApproximableDate;
            rhsApproximableDate = that.getApproximableDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "approximableDate", lhsApproximableDate), LocatorUtils.property(thatLocator, "approximableDate", rhsApproximableDate), lhsApproximableDate, rhsApproximableDate, this.isSetApproximableDate(), that.isSetApproximableDate())) {
                return false;
            }
        }
        {
            ApproximableDateType.SearchableDate lhsSearchableDate;
            lhsSearchableDate = this.getSearchableDate();
            ApproximableDateType.SearchableDate rhsSearchableDate;
            rhsSearchableDate = that.getSearchableDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "searchableDate", lhsSearchableDate), LocatorUtils.property(thatLocator, "searchableDate", rhsSearchableDate), lhsSearchableDate, rhsSearchableDate, this.isSetSearchableDate(), that.isSetSearchableDate())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            String theDescription;
            theDescription = this.getDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription, this.isSetDescription());
        }
        {
            ApproximableDateType.ApproximableDate theApproximableDate;
            theApproximableDate = this.getApproximableDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "approximableDate", theApproximableDate), currentHashCode, theApproximableDate, this.isSetApproximableDate());
        }
        {
            ApproximableDateType.SearchableDate theSearchableDate;
            theSearchableDate = this.getSearchableDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "searchableDate", theSearchableDate), currentHashCode, theSearchableDate, this.isSetSearchableDate());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof ApproximableDateType) {
            final ApproximableDateType copy = ((ApproximableDateType) draftCopy);
            {
                Boolean descriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDescription());
                if (descriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDescription;
                    sourceDescription = this.getDescription();
                    String copyDescription = ((String) strategy.copy(LocatorUtils.property(locator, "description", sourceDescription), sourceDescription, this.isSetDescription()));
                    copy.setDescription(copyDescription);
                } else {
                    if (descriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.description = null;
                    }
                }
            }
            {
                Boolean approximableDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetApproximableDate());
                if (approximableDateShouldBeCopiedAndSet == Boolean.TRUE) {
                    ApproximableDateType.ApproximableDate sourceApproximableDate;
                    sourceApproximableDate = this.getApproximableDate();
                    ApproximableDateType.ApproximableDate copyApproximableDate = ((ApproximableDateType.ApproximableDate) strategy.copy(LocatorUtils.property(locator, "approximableDate", sourceApproximableDate), sourceApproximableDate, this.isSetApproximableDate()));
                    copy.setApproximableDate(copyApproximableDate);
                } else {
                    if (approximableDateShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.approximableDate = null;
                    }
                }
            }
            {
                Boolean searchableDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSearchableDate());
                if (searchableDateShouldBeCopiedAndSet == Boolean.TRUE) {
                    ApproximableDateType.SearchableDate sourceSearchableDate;
                    sourceSearchableDate = this.getSearchableDate();
                    ApproximableDateType.SearchableDate copySearchableDate = ((ApproximableDateType.SearchableDate) strategy.copy(LocatorUtils.property(locator, "searchableDate", sourceSearchableDate), sourceSearchableDate, this.isSetSearchableDate()));
                    copy.setSearchableDate(copySearchableDate);
                } else {
                    if (searchableDateShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.searchableDate = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new ApproximableDateType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof ApproximableDateType) {
            final ApproximableDateType target = this;
            final ApproximableDateType leftObject = ((ApproximableDateType) left);
            final ApproximableDateType rightObject = ((ApproximableDateType) right);
            {
                Boolean descriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDescription(), rightObject.isSetDescription());
                if (descriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDescription;
                    lhsDescription = leftObject.getDescription();
                    String rhsDescription;
                    rhsDescription = rightObject.getDescription();
                    String mergedDescription = ((String) strategy.merge(LocatorUtils.property(leftLocator, "description", lhsDescription), LocatorUtils.property(rightLocator, "description", rhsDescription), lhsDescription, rhsDescription, leftObject.isSetDescription(), rightObject.isSetDescription()));
                    target.setDescription(mergedDescription);
                } else {
                    if (descriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.description = null;
                    }
                }
            }
            {
                Boolean approximableDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetApproximableDate(), rightObject.isSetApproximableDate());
                if (approximableDateShouldBeMergedAndSet == Boolean.TRUE) {
                    ApproximableDateType.ApproximableDate lhsApproximableDate;
                    lhsApproximableDate = leftObject.getApproximableDate();
                    ApproximableDateType.ApproximableDate rhsApproximableDate;
                    rhsApproximableDate = rightObject.getApproximableDate();
                    ApproximableDateType.ApproximableDate mergedApproximableDate = ((ApproximableDateType.ApproximableDate) strategy.merge(LocatorUtils.property(leftLocator, "approximableDate", lhsApproximableDate), LocatorUtils.property(rightLocator, "approximableDate", rhsApproximableDate), lhsApproximableDate, rhsApproximableDate, leftObject.isSetApproximableDate(), rightObject.isSetApproximableDate()));
                    target.setApproximableDate(mergedApproximableDate);
                } else {
                    if (approximableDateShouldBeMergedAndSet == Boolean.FALSE) {
                        target.approximableDate = null;
                    }
                }
            }
            {
                Boolean searchableDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSearchableDate(), rightObject.isSetSearchableDate());
                if (searchableDateShouldBeMergedAndSet == Boolean.TRUE) {
                    ApproximableDateType.SearchableDate lhsSearchableDate;
                    lhsSearchableDate = leftObject.getSearchableDate();
                    ApproximableDateType.SearchableDate rhsSearchableDate;
                    rhsSearchableDate = rightObject.getSearchableDate();
                    ApproximableDateType.SearchableDate mergedSearchableDate = ((ApproximableDateType.SearchableDate) strategy.merge(LocatorUtils.property(leftLocator, "searchableDate", lhsSearchableDate), LocatorUtils.property(rightLocator, "searchableDate", rhsSearchableDate), lhsSearchableDate, rhsSearchableDate, leftObject.isSetSearchableDate(), rightObject.isSetSearchableDate()));
                    target.setSearchableDate(mergedSearchableDate);
                } else {
                    if (searchableDateShouldBeMergedAndSet == Boolean.FALSE) {
                        target.searchableDate = null;
                    }
                }
            }
        }
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;simpleContent&gt;
     *     &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;CombinedDateType"&gt;
     *       &lt;attribute name="approximation" type="{urn:us:mil:ces:metadata:ddms:5}DateApproximationEnumerationType" /&gt;
     *     &lt;/extension&gt;
     *   &lt;/simpleContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class ApproximableDate implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlValue
        protected String value;
        @XmlAttribute(name = "approximation", namespace = "urn:us:mil:ces:metadata:ddms:5")
        protected DateApproximationEnumerationType approximation;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        public boolean isSetValue() {
            return (this.value!= null);
        }

        /**
         * Gets the value of the approximation property.
         * 
         * @return
         *     possible object is
         *     {@link DateApproximationEnumerationType }
         *     
         */
        public DateApproximationEnumerationType getApproximation() {
            return approximation;
        }

        /**
         * Sets the value of the approximation property.
         * 
         * @param value
         *     allowed object is
         *     {@link DateApproximationEnumerationType }
         *     
         */
        public void setApproximation(DateApproximationEnumerationType value) {
            this.approximation = value;
        }

        public boolean isSetApproximation() {
            return (this.approximation!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                String theValue;
                theValue = this.getValue();
                strategy.appendField(locator, this, "value", buffer, theValue, this.isSetValue());
            }
            {
                DateApproximationEnumerationType theApproximation;
                theApproximation = this.getApproximation();
                strategy.appendField(locator, this, "approximation", buffer, theApproximation, this.isSetApproximation());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final ApproximableDateType.ApproximableDate that = ((ApproximableDateType.ApproximableDate) object);
            {
                String lhsValue;
                lhsValue = this.getValue();
                String rhsValue;
                rhsValue = that.getValue();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "value", lhsValue), LocatorUtils.property(thatLocator, "value", rhsValue), lhsValue, rhsValue, this.isSetValue(), that.isSetValue())) {
                    return false;
                }
            }
            {
                DateApproximationEnumerationType lhsApproximation;
                lhsApproximation = this.getApproximation();
                DateApproximationEnumerationType rhsApproximation;
                rhsApproximation = that.getApproximation();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "approximation", lhsApproximation), LocatorUtils.property(thatLocator, "approximation", rhsApproximation), lhsApproximation, rhsApproximation, this.isSetApproximation(), that.isSetApproximation())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                String theValue;
                theValue = this.getValue();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "value", theValue), currentHashCode, theValue, this.isSetValue());
            }
            {
                DateApproximationEnumerationType theApproximation;
                theApproximation = this.getApproximation();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "approximation", theApproximation), currentHashCode, theApproximation, this.isSetApproximation());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof ApproximableDateType.ApproximableDate) {
                final ApproximableDateType.ApproximableDate copy = ((ApproximableDateType.ApproximableDate) draftCopy);
                {
                    Boolean valueShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetValue());
                    if (valueShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceValue;
                        sourceValue = this.getValue();
                        String copyValue = ((String) strategy.copy(LocatorUtils.property(locator, "value", sourceValue), sourceValue, this.isSetValue()));
                        copy.setValue(copyValue);
                    } else {
                        if (valueShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.value = null;
                        }
                    }
                }
                {
                    Boolean approximationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetApproximation());
                    if (approximationShouldBeCopiedAndSet == Boolean.TRUE) {
                        DateApproximationEnumerationType sourceApproximation;
                        sourceApproximation = this.getApproximation();
                        DateApproximationEnumerationType copyApproximation = ((DateApproximationEnumerationType) strategy.copy(LocatorUtils.property(locator, "approximation", sourceApproximation), sourceApproximation, this.isSetApproximation()));
                        copy.setApproximation(copyApproximation);
                    } else {
                        if (approximationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.approximation = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new ApproximableDateType.ApproximableDate();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof ApproximableDateType.ApproximableDate) {
                final ApproximableDateType.ApproximableDate target = this;
                final ApproximableDateType.ApproximableDate leftObject = ((ApproximableDateType.ApproximableDate) left);
                final ApproximableDateType.ApproximableDate rightObject = ((ApproximableDateType.ApproximableDate) right);
                {
                    Boolean valueShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetValue(), rightObject.isSetValue());
                    if (valueShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsValue;
                        lhsValue = leftObject.getValue();
                        String rhsValue;
                        rhsValue = rightObject.getValue();
                        String mergedValue = ((String) strategy.merge(LocatorUtils.property(leftLocator, "value", lhsValue), LocatorUtils.property(rightLocator, "value", rhsValue), lhsValue, rhsValue, leftObject.isSetValue(), rightObject.isSetValue()));
                        target.setValue(mergedValue);
                    } else {
                        if (valueShouldBeMergedAndSet == Boolean.FALSE) {
                            target.value = null;
                        }
                    }
                }
                {
                    Boolean approximationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetApproximation(), rightObject.isSetApproximation());
                    if (approximationShouldBeMergedAndSet == Boolean.TRUE) {
                        DateApproximationEnumerationType lhsApproximation;
                        lhsApproximation = leftObject.getApproximation();
                        DateApproximationEnumerationType rhsApproximation;
                        rhsApproximation = rightObject.getApproximation();
                        DateApproximationEnumerationType mergedApproximation = ((DateApproximationEnumerationType) strategy.merge(LocatorUtils.property(leftLocator, "approximation", lhsApproximation), LocatorUtils.property(rightLocator, "approximation", rhsApproximation), lhsApproximation, rhsApproximation, leftObject.isSetApproximation(), rightObject.isSetApproximation()));
                        target.setApproximation(mergedApproximation);
                    } else {
                        if (approximationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.approximation = null;
                        }
                    }
                }
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence minOccurs="0"&gt;
     *         &lt;element name="start" type="{urn:us:mil:ces:metadata:ddms:5}CombinedDateType" minOccurs="0"/&gt;
     *         &lt;element name="end" type="{urn:us:mil:ces:metadata:ddms:5}CombinedDateType" minOccurs="0"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "start",
        "end"
    })
    public static class SearchableDate implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlSchemaType(name = "anySimpleType")
        protected String start;
        @XmlSchemaType(name = "anySimpleType")
        protected String end;

        /**
         * Gets the value of the start property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getStart() {
            return start;
        }

        /**
         * Sets the value of the start property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setStart(String value) {
            this.start = value;
        }

        public boolean isSetStart() {
            return (this.start!= null);
        }

        /**
         * Gets the value of the end property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getEnd() {
            return end;
        }

        /**
         * Sets the value of the end property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setEnd(String value) {
            this.end = value;
        }

        public boolean isSetEnd() {
            return (this.end!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                String theStart;
                theStart = this.getStart();
                strategy.appendField(locator, this, "start", buffer, theStart, this.isSetStart());
            }
            {
                String theEnd;
                theEnd = this.getEnd();
                strategy.appendField(locator, this, "end", buffer, theEnd, this.isSetEnd());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final ApproximableDateType.SearchableDate that = ((ApproximableDateType.SearchableDate) object);
            {
                String lhsStart;
                lhsStart = this.getStart();
                String rhsStart;
                rhsStart = that.getStart();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "start", lhsStart), LocatorUtils.property(thatLocator, "start", rhsStart), lhsStart, rhsStart, this.isSetStart(), that.isSetStart())) {
                    return false;
                }
            }
            {
                String lhsEnd;
                lhsEnd = this.getEnd();
                String rhsEnd;
                rhsEnd = that.getEnd();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "end", lhsEnd), LocatorUtils.property(thatLocator, "end", rhsEnd), lhsEnd, rhsEnd, this.isSetEnd(), that.isSetEnd())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                String theStart;
                theStart = this.getStart();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "start", theStart), currentHashCode, theStart, this.isSetStart());
            }
            {
                String theEnd;
                theEnd = this.getEnd();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "end", theEnd), currentHashCode, theEnd, this.isSetEnd());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof ApproximableDateType.SearchableDate) {
                final ApproximableDateType.SearchableDate copy = ((ApproximableDateType.SearchableDate) draftCopy);
                {
                    Boolean startShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetStart());
                    if (startShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceStart;
                        sourceStart = this.getStart();
                        String copyStart = ((String) strategy.copy(LocatorUtils.property(locator, "start", sourceStart), sourceStart, this.isSetStart()));
                        copy.setStart(copyStart);
                    } else {
                        if (startShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.start = null;
                        }
                    }
                }
                {
                    Boolean endShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetEnd());
                    if (endShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceEnd;
                        sourceEnd = this.getEnd();
                        String copyEnd = ((String) strategy.copy(LocatorUtils.property(locator, "end", sourceEnd), sourceEnd, this.isSetEnd()));
                        copy.setEnd(copyEnd);
                    } else {
                        if (endShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.end = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new ApproximableDateType.SearchableDate();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof ApproximableDateType.SearchableDate) {
                final ApproximableDateType.SearchableDate target = this;
                final ApproximableDateType.SearchableDate leftObject = ((ApproximableDateType.SearchableDate) left);
                final ApproximableDateType.SearchableDate rightObject = ((ApproximableDateType.SearchableDate) right);
                {
                    Boolean startShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetStart(), rightObject.isSetStart());
                    if (startShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsStart;
                        lhsStart = leftObject.getStart();
                        String rhsStart;
                        rhsStart = rightObject.getStart();
                        String mergedStart = ((String) strategy.merge(LocatorUtils.property(leftLocator, "start", lhsStart), LocatorUtils.property(rightLocator, "start", rhsStart), lhsStart, rhsStart, leftObject.isSetStart(), rightObject.isSetStart()));
                        target.setStart(mergedStart);
                    } else {
                        if (startShouldBeMergedAndSet == Boolean.FALSE) {
                            target.start = null;
                        }
                    }
                }
                {
                    Boolean endShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetEnd(), rightObject.isSetEnd());
                    if (endShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsEnd;
                        lhsEnd = leftObject.getEnd();
                        String rhsEnd;
                        rhsEnd = rightObject.getEnd();
                        String mergedEnd = ((String) strategy.merge(LocatorUtils.property(leftLocator, "end", lhsEnd), LocatorUtils.property(rightLocator, "end", rhsEnd), lhsEnd, rhsEnd, leftObject.isSetEnd(), rightObject.isSetEnd()));
                        target.setEnd(mergedEnd);
                    } else {
                        if (endShouldBeMergedAndSet == Boolean.FALSE) {
                            target.end = null;
                        }
                    }
                }
            }
        }

    }

}
