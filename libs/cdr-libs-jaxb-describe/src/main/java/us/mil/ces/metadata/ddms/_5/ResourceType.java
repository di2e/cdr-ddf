//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import us.gov.ic.virt.VirtualCoverageType;


/**
 * <p>Java class for ResourceType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ResourceType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}metacardInfo"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}identifier" maxOccurs="unbounded"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}title" maxOccurs="unbounded"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}subtitle" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}description" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}language" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}dates" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}rights" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}source" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}type" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded"&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}creator" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}publisher" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}contributor" maxOccurs="unbounded"/&gt;
 *           &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}pointOfContact" maxOccurs="unbounded"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}format" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}subjectCoverage" maxOccurs="unbounded"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}virtualCoverage" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}temporalCoverage" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}geospatialCoverage" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}relatedResource" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}resourceManagement" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="compliesWith" type="{http://www.w3.org/2001/XMLSchema}NMTOKENS" /&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ResourceType", propOrder = {
    "metacardInfo",
    "identifier",
    "title",
    "subtitle",
    "description",
    "language",
    "dates",
    "rights",
    "source",
    "type",
    "creatorOrPublisherOrContributor",
    "format",
    "subjectCoverage",
    "virtualCoverage",
    "temporalCoverage",
    "geospatialCoverage",
    "relatedResource",
    "resourceManagement"
})
public class ResourceType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlElement(required = true)
    @NotNull(message = "ResourceType.metacardInfo {javax.validation.constraints.NotNull.message}")
    @Valid
    protected MetacardInfoType metacardInfo;
    @XmlElement(required = true)
    @NotNull(message = "ResourceType.identifier {javax.validation.constraints.NotNull.message}")
    @Size(min = 1)
    @Valid
    protected List<CompoundResourceIdentifierType> identifier;
    @XmlElement(required = true)
    @NotNull(message = "ResourceType.title {javax.validation.constraints.NotNull.message}")
    @Size(min = 1)
    @Valid
    protected List<TitleType> title;
    @Valid
    protected List<SubtitleType> subtitle;
    @Valid
    protected DescriptionType description;
    @Valid
    protected List<CompoundLanguageIdentifierType> language;
    @Valid
    protected DatesType dates;
    @Valid
    protected RightsType rights;
    @Valid
    protected List<CompoundSourceIdentifierType> source;
    @Valid
    protected List<CompoundTypeIdentifierType> type;
    @XmlElementRefs({
        @XmlElementRef(name = "publisher", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "contributor", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "pointOfContact", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "creator", namespace = "urn:us:mil:ces:metadata:ddms:5", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<ContactInfoType>> creatorOrPublisherOrContributor;
    @Valid
    protected FormatType format;
    @XmlElement(required = true)
    @NotNull(message = "ResourceType.subjectCoverage {javax.validation.constraints.NotNull.message}")
    @Size(min = 1)
    @Valid
    protected List<SubjectType> subjectCoverage;
    @Valid
    protected List<VirtualCoverageType> virtualCoverage;
    @Valid
    protected List<TimePeriodType> temporalCoverage;
    @Valid
    protected List<PlaceType> geospatialCoverage;
    @Valid
    protected List<RelatedResourcesType> relatedResource;
    @Valid
    protected ResourceManagementType resourceManagement;
    @XmlAttribute(name = "compliesWith", namespace = "urn:us:mil:ces:metadata:ddms:5")
    @XmlSchemaType(name = "NMTOKENS")
    protected List<String> compliesWith;

    /**
     * Gets the value of the metacardInfo property.
     * 
     * @return
     *     possible object is
     *     {@link MetacardInfoType }
     *     
     */
    public MetacardInfoType getMetacardInfo() {
        return metacardInfo;
    }

    /**
     * Sets the value of the metacardInfo property.
     * 
     * @param value
     *     allowed object is
     *     {@link MetacardInfoType }
     *     
     */
    public void setMetacardInfo(MetacardInfoType value) {
        this.metacardInfo = value;
    }

    public boolean isSetMetacardInfo() {
        return (this.metacardInfo!= null);
    }

    /**
     * Gets the value of the identifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CompoundResourceIdentifierType }
     * 
     * 
     */
    public List<CompoundResourceIdentifierType> getIdentifier() {
        if (identifier == null) {
            identifier = new ArrayList<CompoundResourceIdentifierType>();
        }
        return this.identifier;
    }

    public boolean isSetIdentifier() {
        return ((this.identifier!= null)&&(!this.identifier.isEmpty()));
    }

    public void unsetIdentifier() {
        this.identifier = null;
    }

    /**
     * Gets the value of the title property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the title property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTitle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TitleType }
     * 
     * 
     */
    public List<TitleType> getTitle() {
        if (title == null) {
            title = new ArrayList<TitleType>();
        }
        return this.title;
    }

    public boolean isSetTitle() {
        return ((this.title!= null)&&(!this.title.isEmpty()));
    }

    public void unsetTitle() {
        this.title = null;
    }

    /**
     * Gets the value of the subtitle property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subtitle property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubtitle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SubtitleType }
     * 
     * 
     */
    public List<SubtitleType> getSubtitle() {
        if (subtitle == null) {
            subtitle = new ArrayList<SubtitleType>();
        }
        return this.subtitle;
    }

    public boolean isSetSubtitle() {
        return ((this.subtitle!= null)&&(!this.subtitle.isEmpty()));
    }

    public void unsetSubtitle() {
        this.subtitle = null;
    }

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link DescriptionType }
     *     
     */
    public DescriptionType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link DescriptionType }
     *     
     */
    public void setDescription(DescriptionType value) {
        this.description = value;
    }

    public boolean isSetDescription() {
        return (this.description!= null);
    }

    /**
     * Gets the value of the language property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the language property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLanguage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CompoundLanguageIdentifierType }
     * 
     * 
     */
    public List<CompoundLanguageIdentifierType> getLanguage() {
        if (language == null) {
            language = new ArrayList<CompoundLanguageIdentifierType>();
        }
        return this.language;
    }

    public boolean isSetLanguage() {
        return ((this.language!= null)&&(!this.language.isEmpty()));
    }

    public void unsetLanguage() {
        this.language = null;
    }

    /**
     * Gets the value of the dates property.
     * 
     * @return
     *     possible object is
     *     {@link DatesType }
     *     
     */
    public DatesType getDates() {
        return dates;
    }

    /**
     * Sets the value of the dates property.
     * 
     * @param value
     *     allowed object is
     *     {@link DatesType }
     *     
     */
    public void setDates(DatesType value) {
        this.dates = value;
    }

    public boolean isSetDates() {
        return (this.dates!= null);
    }

    /**
     * Gets the value of the rights property.
     * 
     * @return
     *     possible object is
     *     {@link RightsType }
     *     
     */
    public RightsType getRights() {
        return rights;
    }

    /**
     * Sets the value of the rights property.
     * 
     * @param value
     *     allowed object is
     *     {@link RightsType }
     *     
     */
    public void setRights(RightsType value) {
        this.rights = value;
    }

    public boolean isSetRights() {
        return (this.rights!= null);
    }

    /**
     * Gets the value of the source property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the source property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSource().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CompoundSourceIdentifierType }
     * 
     * 
     */
    public List<CompoundSourceIdentifierType> getSource() {
        if (source == null) {
            source = new ArrayList<CompoundSourceIdentifierType>();
        }
        return this.source;
    }

    public boolean isSetSource() {
        return ((this.source!= null)&&(!this.source.isEmpty()));
    }

    public void unsetSource() {
        this.source = null;
    }

    /**
     * Gets the value of the type property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the type property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getType().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CompoundTypeIdentifierType }
     * 
     * 
     */
    public List<CompoundTypeIdentifierType> getType() {
        if (type == null) {
            type = new ArrayList<CompoundTypeIdentifierType>();
        }
        return this.type;
    }

    public boolean isSetType() {
        return ((this.type!= null)&&(!this.type.isEmpty()));
    }

    public void unsetType() {
        this.type = null;
    }

    /**
     * Gets the value of the creatorOrPublisherOrContributor property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the creatorOrPublisherOrContributor property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCreatorOrPublisherOrContributor().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * {@link JAXBElement }{@code <}{@link ContactInfoType }{@code >}
     * 
     * 
     */
    public List<JAXBElement<ContactInfoType>> getCreatorOrPublisherOrContributor() {
        if (creatorOrPublisherOrContributor == null) {
            creatorOrPublisherOrContributor = new ArrayList<JAXBElement<ContactInfoType>>();
        }
        return this.creatorOrPublisherOrContributor;
    }

    public boolean isSetCreatorOrPublisherOrContributor() {
        return ((this.creatorOrPublisherOrContributor!= null)&&(!this.creatorOrPublisherOrContributor.isEmpty()));
    }

    public void unsetCreatorOrPublisherOrContributor() {
        this.creatorOrPublisherOrContributor = null;
    }

    /**
     * Gets the value of the format property.
     * 
     * @return
     *     possible object is
     *     {@link FormatType }
     *     
     */
    public FormatType getFormat() {
        return format;
    }

    /**
     * Sets the value of the format property.
     * 
     * @param value
     *     allowed object is
     *     {@link FormatType }
     *     
     */
    public void setFormat(FormatType value) {
        this.format = value;
    }

    public boolean isSetFormat() {
        return (this.format!= null);
    }

    /**
     * Gets the value of the subjectCoverage property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subjectCoverage property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubjectCoverage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SubjectType }
     * 
     * 
     */
    public List<SubjectType> getSubjectCoverage() {
        if (subjectCoverage == null) {
            subjectCoverage = new ArrayList<SubjectType>();
        }
        return this.subjectCoverage;
    }

    public boolean isSetSubjectCoverage() {
        return ((this.subjectCoverage!= null)&&(!this.subjectCoverage.isEmpty()));
    }

    public void unsetSubjectCoverage() {
        this.subjectCoverage = null;
    }

    /**
     * Gets the value of the virtualCoverage property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the virtualCoverage property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVirtualCoverage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link VirtualCoverageType }
     * 
     * 
     */
    public List<VirtualCoverageType> getVirtualCoverage() {
        if (virtualCoverage == null) {
            virtualCoverage = new ArrayList<VirtualCoverageType>();
        }
        return this.virtualCoverage;
    }

    public boolean isSetVirtualCoverage() {
        return ((this.virtualCoverage!= null)&&(!this.virtualCoverage.isEmpty()));
    }

    public void unsetVirtualCoverage() {
        this.virtualCoverage = null;
    }

    /**
     * Gets the value of the temporalCoverage property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the temporalCoverage property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTemporalCoverage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TimePeriodType }
     * 
     * 
     */
    public List<TimePeriodType> getTemporalCoverage() {
        if (temporalCoverage == null) {
            temporalCoverage = new ArrayList<TimePeriodType>();
        }
        return this.temporalCoverage;
    }

    public boolean isSetTemporalCoverage() {
        return ((this.temporalCoverage!= null)&&(!this.temporalCoverage.isEmpty()));
    }

    public void unsetTemporalCoverage() {
        this.temporalCoverage = null;
    }

    /**
     * Gets the value of the geospatialCoverage property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the geospatialCoverage property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeospatialCoverage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PlaceType }
     * 
     * 
     */
    public List<PlaceType> getGeospatialCoverage() {
        if (geospatialCoverage == null) {
            geospatialCoverage = new ArrayList<PlaceType>();
        }
        return this.geospatialCoverage;
    }

    public boolean isSetGeospatialCoverage() {
        return ((this.geospatialCoverage!= null)&&(!this.geospatialCoverage.isEmpty()));
    }

    public void unsetGeospatialCoverage() {
        this.geospatialCoverage = null;
    }

    /**
     * Gets the value of the relatedResource property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the relatedResource property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRelatedResource().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelatedResourcesType }
     * 
     * 
     */
    public List<RelatedResourcesType> getRelatedResource() {
        if (relatedResource == null) {
            relatedResource = new ArrayList<RelatedResourcesType>();
        }
        return this.relatedResource;
    }

    public boolean isSetRelatedResource() {
        return ((this.relatedResource!= null)&&(!this.relatedResource.isEmpty()));
    }

    public void unsetRelatedResource() {
        this.relatedResource = null;
    }

    /**
     * Gets the value of the resourceManagement property.
     * 
     * @return
     *     possible object is
     *     {@link ResourceManagementType }
     *     
     */
    public ResourceManagementType getResourceManagement() {
        return resourceManagement;
    }

    /**
     * Sets the value of the resourceManagement property.
     * 
     * @param value
     *     allowed object is
     *     {@link ResourceManagementType }
     *     
     */
    public void setResourceManagement(ResourceManagementType value) {
        this.resourceManagement = value;
    }

    public boolean isSetResourceManagement() {
        return (this.resourceManagement!= null);
    }

    /**
     * Gets the value of the compliesWith property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the compliesWith property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCompliesWith().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getCompliesWith() {
        if (compliesWith == null) {
            compliesWith = new ArrayList<String>();
        }
        return this.compliesWith;
    }

    public boolean isSetCompliesWith() {
        return ((this.compliesWith!= null)&&(!this.compliesWith.isEmpty()));
    }

    public void unsetCompliesWith() {
        this.compliesWith = null;
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            MetacardInfoType theMetacardInfo;
            theMetacardInfo = this.getMetacardInfo();
            strategy.appendField(locator, this, "metacardInfo", buffer, theMetacardInfo, this.isSetMetacardInfo());
        }
        {
            List<CompoundResourceIdentifierType> theIdentifier;
            theIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            strategy.appendField(locator, this, "identifier", buffer, theIdentifier, this.isSetIdentifier());
        }
        {
            List<TitleType> theTitle;
            theTitle = (this.isSetTitle()?this.getTitle():null);
            strategy.appendField(locator, this, "title", buffer, theTitle, this.isSetTitle());
        }
        {
            List<SubtitleType> theSubtitle;
            theSubtitle = (this.isSetSubtitle()?this.getSubtitle():null);
            strategy.appendField(locator, this, "subtitle", buffer, theSubtitle, this.isSetSubtitle());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            strategy.appendField(locator, this, "description", buffer, theDescription, this.isSetDescription());
        }
        {
            List<CompoundLanguageIdentifierType> theLanguage;
            theLanguage = (this.isSetLanguage()?this.getLanguage():null);
            strategy.appendField(locator, this, "language", buffer, theLanguage, this.isSetLanguage());
        }
        {
            DatesType theDates;
            theDates = this.getDates();
            strategy.appendField(locator, this, "dates", buffer, theDates, this.isSetDates());
        }
        {
            RightsType theRights;
            theRights = this.getRights();
            strategy.appendField(locator, this, "rights", buffer, theRights, this.isSetRights());
        }
        {
            List<CompoundSourceIdentifierType> theSource;
            theSource = (this.isSetSource()?this.getSource():null);
            strategy.appendField(locator, this, "source", buffer, theSource, this.isSetSource());
        }
        {
            List<CompoundTypeIdentifierType> theType;
            theType = (this.isSetType()?this.getType():null);
            strategy.appendField(locator, this, "type", buffer, theType, this.isSetType());
        }
        {
            List<JAXBElement<ContactInfoType>> theCreatorOrPublisherOrContributor;
            theCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            strategy.appendField(locator, this, "creatorOrPublisherOrContributor", buffer, theCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor());
        }
        {
            FormatType theFormat;
            theFormat = this.getFormat();
            strategy.appendField(locator, this, "format", buffer, theFormat, this.isSetFormat());
        }
        {
            List<SubjectType> theSubjectCoverage;
            theSubjectCoverage = (this.isSetSubjectCoverage()?this.getSubjectCoverage():null);
            strategy.appendField(locator, this, "subjectCoverage", buffer, theSubjectCoverage, this.isSetSubjectCoverage());
        }
        {
            List<VirtualCoverageType> theVirtualCoverage;
            theVirtualCoverage = (this.isSetVirtualCoverage()?this.getVirtualCoverage():null);
            strategy.appendField(locator, this, "virtualCoverage", buffer, theVirtualCoverage, this.isSetVirtualCoverage());
        }
        {
            List<TimePeriodType> theTemporalCoverage;
            theTemporalCoverage = (this.isSetTemporalCoverage()?this.getTemporalCoverage():null);
            strategy.appendField(locator, this, "temporalCoverage", buffer, theTemporalCoverage, this.isSetTemporalCoverage());
        }
        {
            List<PlaceType> theGeospatialCoverage;
            theGeospatialCoverage = (this.isSetGeospatialCoverage()?this.getGeospatialCoverage():null);
            strategy.appendField(locator, this, "geospatialCoverage", buffer, theGeospatialCoverage, this.isSetGeospatialCoverage());
        }
        {
            List<RelatedResourcesType> theRelatedResource;
            theRelatedResource = (this.isSetRelatedResource()?this.getRelatedResource():null);
            strategy.appendField(locator, this, "relatedResource", buffer, theRelatedResource, this.isSetRelatedResource());
        }
        {
            ResourceManagementType theResourceManagement;
            theResourceManagement = this.getResourceManagement();
            strategy.appendField(locator, this, "resourceManagement", buffer, theResourceManagement, this.isSetResourceManagement());
        }
        {
            List<String> theCompliesWith;
            theCompliesWith = (this.isSetCompliesWith()?this.getCompliesWith():null);
            strategy.appendField(locator, this, "compliesWith", buffer, theCompliesWith, this.isSetCompliesWith());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final ResourceType that = ((ResourceType) object);
        {
            MetacardInfoType lhsMetacardInfo;
            lhsMetacardInfo = this.getMetacardInfo();
            MetacardInfoType rhsMetacardInfo;
            rhsMetacardInfo = that.getMetacardInfo();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "metacardInfo", lhsMetacardInfo), LocatorUtils.property(thatLocator, "metacardInfo", rhsMetacardInfo), lhsMetacardInfo, rhsMetacardInfo, this.isSetMetacardInfo(), that.isSetMetacardInfo())) {
                return false;
            }
        }
        {
            List<CompoundResourceIdentifierType> lhsIdentifier;
            lhsIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            List<CompoundResourceIdentifierType> rhsIdentifier;
            rhsIdentifier = (that.isSetIdentifier()?that.getIdentifier():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "identifier", lhsIdentifier), LocatorUtils.property(thatLocator, "identifier", rhsIdentifier), lhsIdentifier, rhsIdentifier, this.isSetIdentifier(), that.isSetIdentifier())) {
                return false;
            }
        }
        {
            List<TitleType> lhsTitle;
            lhsTitle = (this.isSetTitle()?this.getTitle():null);
            List<TitleType> rhsTitle;
            rhsTitle = (that.isSetTitle()?that.getTitle():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "title", lhsTitle), LocatorUtils.property(thatLocator, "title", rhsTitle), lhsTitle, rhsTitle, this.isSetTitle(), that.isSetTitle())) {
                return false;
            }
        }
        {
            List<SubtitleType> lhsSubtitle;
            lhsSubtitle = (this.isSetSubtitle()?this.getSubtitle():null);
            List<SubtitleType> rhsSubtitle;
            rhsSubtitle = (that.isSetSubtitle()?that.getSubtitle():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "subtitle", lhsSubtitle), LocatorUtils.property(thatLocator, "subtitle", rhsSubtitle), lhsSubtitle, rhsSubtitle, this.isSetSubtitle(), that.isSetSubtitle())) {
                return false;
            }
        }
        {
            DescriptionType lhsDescription;
            lhsDescription = this.getDescription();
            DescriptionType rhsDescription;
            rhsDescription = that.getDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription, this.isSetDescription(), that.isSetDescription())) {
                return false;
            }
        }
        {
            List<CompoundLanguageIdentifierType> lhsLanguage;
            lhsLanguage = (this.isSetLanguage()?this.getLanguage():null);
            List<CompoundLanguageIdentifierType> rhsLanguage;
            rhsLanguage = (that.isSetLanguage()?that.getLanguage():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "language", lhsLanguage), LocatorUtils.property(thatLocator, "language", rhsLanguage), lhsLanguage, rhsLanguage, this.isSetLanguage(), that.isSetLanguage())) {
                return false;
            }
        }
        {
            DatesType lhsDates;
            lhsDates = this.getDates();
            DatesType rhsDates;
            rhsDates = that.getDates();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "dates", lhsDates), LocatorUtils.property(thatLocator, "dates", rhsDates), lhsDates, rhsDates, this.isSetDates(), that.isSetDates())) {
                return false;
            }
        }
        {
            RightsType lhsRights;
            lhsRights = this.getRights();
            RightsType rhsRights;
            rhsRights = that.getRights();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "rights", lhsRights), LocatorUtils.property(thatLocator, "rights", rhsRights), lhsRights, rhsRights, this.isSetRights(), that.isSetRights())) {
                return false;
            }
        }
        {
            List<CompoundSourceIdentifierType> lhsSource;
            lhsSource = (this.isSetSource()?this.getSource():null);
            List<CompoundSourceIdentifierType> rhsSource;
            rhsSource = (that.isSetSource()?that.getSource():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "source", lhsSource), LocatorUtils.property(thatLocator, "source", rhsSource), lhsSource, rhsSource, this.isSetSource(), that.isSetSource())) {
                return false;
            }
        }
        {
            List<CompoundTypeIdentifierType> lhsType;
            lhsType = (this.isSetType()?this.getType():null);
            List<CompoundTypeIdentifierType> rhsType;
            rhsType = (that.isSetType()?that.getType():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "type", lhsType), LocatorUtils.property(thatLocator, "type", rhsType), lhsType, rhsType, this.isSetType(), that.isSetType())) {
                return false;
            }
        }
        {
            List<JAXBElement<ContactInfoType>> lhsCreatorOrPublisherOrContributor;
            lhsCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            List<JAXBElement<ContactInfoType>> rhsCreatorOrPublisherOrContributor;
            rhsCreatorOrPublisherOrContributor = (that.isSetCreatorOrPublisherOrContributor()?that.getCreatorOrPublisherOrContributor():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "creatorOrPublisherOrContributor", lhsCreatorOrPublisherOrContributor), LocatorUtils.property(thatLocator, "creatorOrPublisherOrContributor", rhsCreatorOrPublisherOrContributor), lhsCreatorOrPublisherOrContributor, rhsCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor(), that.isSetCreatorOrPublisherOrContributor())) {
                return false;
            }
        }
        {
            FormatType lhsFormat;
            lhsFormat = this.getFormat();
            FormatType rhsFormat;
            rhsFormat = that.getFormat();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "format", lhsFormat), LocatorUtils.property(thatLocator, "format", rhsFormat), lhsFormat, rhsFormat, this.isSetFormat(), that.isSetFormat())) {
                return false;
            }
        }
        {
            List<SubjectType> lhsSubjectCoverage;
            lhsSubjectCoverage = (this.isSetSubjectCoverage()?this.getSubjectCoverage():null);
            List<SubjectType> rhsSubjectCoverage;
            rhsSubjectCoverage = (that.isSetSubjectCoverage()?that.getSubjectCoverage():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "subjectCoverage", lhsSubjectCoverage), LocatorUtils.property(thatLocator, "subjectCoverage", rhsSubjectCoverage), lhsSubjectCoverage, rhsSubjectCoverage, this.isSetSubjectCoverage(), that.isSetSubjectCoverage())) {
                return false;
            }
        }
        {
            List<VirtualCoverageType> lhsVirtualCoverage;
            lhsVirtualCoverage = (this.isSetVirtualCoverage()?this.getVirtualCoverage():null);
            List<VirtualCoverageType> rhsVirtualCoverage;
            rhsVirtualCoverage = (that.isSetVirtualCoverage()?that.getVirtualCoverage():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "virtualCoverage", lhsVirtualCoverage), LocatorUtils.property(thatLocator, "virtualCoverage", rhsVirtualCoverage), lhsVirtualCoverage, rhsVirtualCoverage, this.isSetVirtualCoverage(), that.isSetVirtualCoverage())) {
                return false;
            }
        }
        {
            List<TimePeriodType> lhsTemporalCoverage;
            lhsTemporalCoverage = (this.isSetTemporalCoverage()?this.getTemporalCoverage():null);
            List<TimePeriodType> rhsTemporalCoverage;
            rhsTemporalCoverage = (that.isSetTemporalCoverage()?that.getTemporalCoverage():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "temporalCoverage", lhsTemporalCoverage), LocatorUtils.property(thatLocator, "temporalCoverage", rhsTemporalCoverage), lhsTemporalCoverage, rhsTemporalCoverage, this.isSetTemporalCoverage(), that.isSetTemporalCoverage())) {
                return false;
            }
        }
        {
            List<PlaceType> lhsGeospatialCoverage;
            lhsGeospatialCoverage = (this.isSetGeospatialCoverage()?this.getGeospatialCoverage():null);
            List<PlaceType> rhsGeospatialCoverage;
            rhsGeospatialCoverage = (that.isSetGeospatialCoverage()?that.getGeospatialCoverage():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "geospatialCoverage", lhsGeospatialCoverage), LocatorUtils.property(thatLocator, "geospatialCoverage", rhsGeospatialCoverage), lhsGeospatialCoverage, rhsGeospatialCoverage, this.isSetGeospatialCoverage(), that.isSetGeospatialCoverage())) {
                return false;
            }
        }
        {
            List<RelatedResourcesType> lhsRelatedResource;
            lhsRelatedResource = (this.isSetRelatedResource()?this.getRelatedResource():null);
            List<RelatedResourcesType> rhsRelatedResource;
            rhsRelatedResource = (that.isSetRelatedResource()?that.getRelatedResource():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "relatedResource", lhsRelatedResource), LocatorUtils.property(thatLocator, "relatedResource", rhsRelatedResource), lhsRelatedResource, rhsRelatedResource, this.isSetRelatedResource(), that.isSetRelatedResource())) {
                return false;
            }
        }
        {
            ResourceManagementType lhsResourceManagement;
            lhsResourceManagement = this.getResourceManagement();
            ResourceManagementType rhsResourceManagement;
            rhsResourceManagement = that.getResourceManagement();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "resourceManagement", lhsResourceManagement), LocatorUtils.property(thatLocator, "resourceManagement", rhsResourceManagement), lhsResourceManagement, rhsResourceManagement, this.isSetResourceManagement(), that.isSetResourceManagement())) {
                return false;
            }
        }
        {
            List<String> lhsCompliesWith;
            lhsCompliesWith = (this.isSetCompliesWith()?this.getCompliesWith():null);
            List<String> rhsCompliesWith;
            rhsCompliesWith = (that.isSetCompliesWith()?that.getCompliesWith():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "compliesWith", lhsCompliesWith), LocatorUtils.property(thatLocator, "compliesWith", rhsCompliesWith), lhsCompliesWith, rhsCompliesWith, this.isSetCompliesWith(), that.isSetCompliesWith())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            MetacardInfoType theMetacardInfo;
            theMetacardInfo = this.getMetacardInfo();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "metacardInfo", theMetacardInfo), currentHashCode, theMetacardInfo, this.isSetMetacardInfo());
        }
        {
            List<CompoundResourceIdentifierType> theIdentifier;
            theIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "identifier", theIdentifier), currentHashCode, theIdentifier, this.isSetIdentifier());
        }
        {
            List<TitleType> theTitle;
            theTitle = (this.isSetTitle()?this.getTitle():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "title", theTitle), currentHashCode, theTitle, this.isSetTitle());
        }
        {
            List<SubtitleType> theSubtitle;
            theSubtitle = (this.isSetSubtitle()?this.getSubtitle():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "subtitle", theSubtitle), currentHashCode, theSubtitle, this.isSetSubtitle());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription, this.isSetDescription());
        }
        {
            List<CompoundLanguageIdentifierType> theLanguage;
            theLanguage = (this.isSetLanguage()?this.getLanguage():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "language", theLanguage), currentHashCode, theLanguage, this.isSetLanguage());
        }
        {
            DatesType theDates;
            theDates = this.getDates();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "dates", theDates), currentHashCode, theDates, this.isSetDates());
        }
        {
            RightsType theRights;
            theRights = this.getRights();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "rights", theRights), currentHashCode, theRights, this.isSetRights());
        }
        {
            List<CompoundSourceIdentifierType> theSource;
            theSource = (this.isSetSource()?this.getSource():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "source", theSource), currentHashCode, theSource, this.isSetSource());
        }
        {
            List<CompoundTypeIdentifierType> theType;
            theType = (this.isSetType()?this.getType():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "type", theType), currentHashCode, theType, this.isSetType());
        }
        {
            List<JAXBElement<ContactInfoType>> theCreatorOrPublisherOrContributor;
            theCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "creatorOrPublisherOrContributor", theCreatorOrPublisherOrContributor), currentHashCode, theCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor());
        }
        {
            FormatType theFormat;
            theFormat = this.getFormat();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "format", theFormat), currentHashCode, theFormat, this.isSetFormat());
        }
        {
            List<SubjectType> theSubjectCoverage;
            theSubjectCoverage = (this.isSetSubjectCoverage()?this.getSubjectCoverage():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "subjectCoverage", theSubjectCoverage), currentHashCode, theSubjectCoverage, this.isSetSubjectCoverage());
        }
        {
            List<VirtualCoverageType> theVirtualCoverage;
            theVirtualCoverage = (this.isSetVirtualCoverage()?this.getVirtualCoverage():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "virtualCoverage", theVirtualCoverage), currentHashCode, theVirtualCoverage, this.isSetVirtualCoverage());
        }
        {
            List<TimePeriodType> theTemporalCoverage;
            theTemporalCoverage = (this.isSetTemporalCoverage()?this.getTemporalCoverage():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "temporalCoverage", theTemporalCoverage), currentHashCode, theTemporalCoverage, this.isSetTemporalCoverage());
        }
        {
            List<PlaceType> theGeospatialCoverage;
            theGeospatialCoverage = (this.isSetGeospatialCoverage()?this.getGeospatialCoverage():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "geospatialCoverage", theGeospatialCoverage), currentHashCode, theGeospatialCoverage, this.isSetGeospatialCoverage());
        }
        {
            List<RelatedResourcesType> theRelatedResource;
            theRelatedResource = (this.isSetRelatedResource()?this.getRelatedResource():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "relatedResource", theRelatedResource), currentHashCode, theRelatedResource, this.isSetRelatedResource());
        }
        {
            ResourceManagementType theResourceManagement;
            theResourceManagement = this.getResourceManagement();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "resourceManagement", theResourceManagement), currentHashCode, theResourceManagement, this.isSetResourceManagement());
        }
        {
            List<String> theCompliesWith;
            theCompliesWith = (this.isSetCompliesWith()?this.getCompliesWith():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compliesWith", theCompliesWith), currentHashCode, theCompliesWith, this.isSetCompliesWith());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof ResourceType) {
            final ResourceType copy = ((ResourceType) draftCopy);
            {
                Boolean metacardInfoShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetMetacardInfo());
                if (metacardInfoShouldBeCopiedAndSet == Boolean.TRUE) {
                    MetacardInfoType sourceMetacardInfo;
                    sourceMetacardInfo = this.getMetacardInfo();
                    MetacardInfoType copyMetacardInfo = ((MetacardInfoType) strategy.copy(LocatorUtils.property(locator, "metacardInfo", sourceMetacardInfo), sourceMetacardInfo, this.isSetMetacardInfo()));
                    copy.setMetacardInfo(copyMetacardInfo);
                } else {
                    if (metacardInfoShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.metacardInfo = null;
                    }
                }
            }
            {
                Boolean identifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetIdentifier());
                if (identifierShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CompoundResourceIdentifierType> sourceIdentifier;
                    sourceIdentifier = (this.isSetIdentifier()?this.getIdentifier():null);
                    @SuppressWarnings("unchecked")
                    List<CompoundResourceIdentifierType> copyIdentifier = ((List<CompoundResourceIdentifierType> ) strategy.copy(LocatorUtils.property(locator, "identifier", sourceIdentifier), sourceIdentifier, this.isSetIdentifier()));
                    copy.unsetIdentifier();
                    if (copyIdentifier!= null) {
                        List<CompoundResourceIdentifierType> uniqueIdentifierl = copy.getIdentifier();
                        uniqueIdentifierl.addAll(copyIdentifier);
                    }
                } else {
                    if (identifierShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetIdentifier();
                    }
                }
            }
            {
                Boolean titleShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTitle());
                if (titleShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<TitleType> sourceTitle;
                    sourceTitle = (this.isSetTitle()?this.getTitle():null);
                    @SuppressWarnings("unchecked")
                    List<TitleType> copyTitle = ((List<TitleType> ) strategy.copy(LocatorUtils.property(locator, "title", sourceTitle), sourceTitle, this.isSetTitle()));
                    copy.unsetTitle();
                    if (copyTitle!= null) {
                        List<TitleType> uniqueTitlel = copy.getTitle();
                        uniqueTitlel.addAll(copyTitle);
                    }
                } else {
                    if (titleShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetTitle();
                    }
                }
            }
            {
                Boolean subtitleShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSubtitle());
                if (subtitleShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<SubtitleType> sourceSubtitle;
                    sourceSubtitle = (this.isSetSubtitle()?this.getSubtitle():null);
                    @SuppressWarnings("unchecked")
                    List<SubtitleType> copySubtitle = ((List<SubtitleType> ) strategy.copy(LocatorUtils.property(locator, "subtitle", sourceSubtitle), sourceSubtitle, this.isSetSubtitle()));
                    copy.unsetSubtitle();
                    if (copySubtitle!= null) {
                        List<SubtitleType> uniqueSubtitlel = copy.getSubtitle();
                        uniqueSubtitlel.addAll(copySubtitle);
                    }
                } else {
                    if (subtitleShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSubtitle();
                    }
                }
            }
            {
                Boolean descriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDescription());
                if (descriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    DescriptionType sourceDescription;
                    sourceDescription = this.getDescription();
                    DescriptionType copyDescription = ((DescriptionType) strategy.copy(LocatorUtils.property(locator, "description", sourceDescription), sourceDescription, this.isSetDescription()));
                    copy.setDescription(copyDescription);
                } else {
                    if (descriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.description = null;
                    }
                }
            }
            {
                Boolean languageShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetLanguage());
                if (languageShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CompoundLanguageIdentifierType> sourceLanguage;
                    sourceLanguage = (this.isSetLanguage()?this.getLanguage():null);
                    @SuppressWarnings("unchecked")
                    List<CompoundLanguageIdentifierType> copyLanguage = ((List<CompoundLanguageIdentifierType> ) strategy.copy(LocatorUtils.property(locator, "language", sourceLanguage), sourceLanguage, this.isSetLanguage()));
                    copy.unsetLanguage();
                    if (copyLanguage!= null) {
                        List<CompoundLanguageIdentifierType> uniqueLanguagel = copy.getLanguage();
                        uniqueLanguagel.addAll(copyLanguage);
                    }
                } else {
                    if (languageShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetLanguage();
                    }
                }
            }
            {
                Boolean datesShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDates());
                if (datesShouldBeCopiedAndSet == Boolean.TRUE) {
                    DatesType sourceDates;
                    sourceDates = this.getDates();
                    DatesType copyDates = ((DatesType) strategy.copy(LocatorUtils.property(locator, "dates", sourceDates), sourceDates, this.isSetDates()));
                    copy.setDates(copyDates);
                } else {
                    if (datesShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.dates = null;
                    }
                }
            }
            {
                Boolean rightsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRights());
                if (rightsShouldBeCopiedAndSet == Boolean.TRUE) {
                    RightsType sourceRights;
                    sourceRights = this.getRights();
                    RightsType copyRights = ((RightsType) strategy.copy(LocatorUtils.property(locator, "rights", sourceRights), sourceRights, this.isSetRights()));
                    copy.setRights(copyRights);
                } else {
                    if (rightsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.rights = null;
                    }
                }
            }
            {
                Boolean sourceShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSource());
                if (sourceShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CompoundSourceIdentifierType> sourceSource;
                    sourceSource = (this.isSetSource()?this.getSource():null);
                    @SuppressWarnings("unchecked")
                    List<CompoundSourceIdentifierType> copySource = ((List<CompoundSourceIdentifierType> ) strategy.copy(LocatorUtils.property(locator, "source", sourceSource), sourceSource, this.isSetSource()));
                    copy.unsetSource();
                    if (copySource!= null) {
                        List<CompoundSourceIdentifierType> uniqueSourcel = copy.getSource();
                        uniqueSourcel.addAll(copySource);
                    }
                } else {
                    if (sourceShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSource();
                    }
                }
            }
            {
                Boolean typeShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetType());
                if (typeShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CompoundTypeIdentifierType> sourceType;
                    sourceType = (this.isSetType()?this.getType():null);
                    @SuppressWarnings("unchecked")
                    List<CompoundTypeIdentifierType> copyType = ((List<CompoundTypeIdentifierType> ) strategy.copy(LocatorUtils.property(locator, "type", sourceType), sourceType, this.isSetType()));
                    copy.unsetType();
                    if (copyType!= null) {
                        List<CompoundTypeIdentifierType> uniqueTypel = copy.getType();
                        uniqueTypel.addAll(copyType);
                    }
                } else {
                    if (typeShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetType();
                    }
                }
            }
            {
                Boolean creatorOrPublisherOrContributorShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCreatorOrPublisherOrContributor());
                if (creatorOrPublisherOrContributorShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<JAXBElement<ContactInfoType>> sourceCreatorOrPublisherOrContributor;
                    sourceCreatorOrPublisherOrContributor = (this.isSetCreatorOrPublisherOrContributor()?this.getCreatorOrPublisherOrContributor():null);
                    @SuppressWarnings("unchecked")
                    List<JAXBElement<ContactInfoType>> copyCreatorOrPublisherOrContributor = ((List<JAXBElement<ContactInfoType>> ) strategy.copy(LocatorUtils.property(locator, "creatorOrPublisherOrContributor", sourceCreatorOrPublisherOrContributor), sourceCreatorOrPublisherOrContributor, this.isSetCreatorOrPublisherOrContributor()));
                    copy.unsetCreatorOrPublisherOrContributor();
                    if (copyCreatorOrPublisherOrContributor!= null) {
                        List<JAXBElement<ContactInfoType>> uniqueCreatorOrPublisherOrContributorl = copy.getCreatorOrPublisherOrContributor();
                        uniqueCreatorOrPublisherOrContributorl.addAll(copyCreatorOrPublisherOrContributor);
                    }
                } else {
                    if (creatorOrPublisherOrContributorShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetCreatorOrPublisherOrContributor();
                    }
                }
            }
            {
                Boolean formatShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFormat());
                if (formatShouldBeCopiedAndSet == Boolean.TRUE) {
                    FormatType sourceFormat;
                    sourceFormat = this.getFormat();
                    FormatType copyFormat = ((FormatType) strategy.copy(LocatorUtils.property(locator, "format", sourceFormat), sourceFormat, this.isSetFormat()));
                    copy.setFormat(copyFormat);
                } else {
                    if (formatShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.format = null;
                    }
                }
            }
            {
                Boolean subjectCoverageShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSubjectCoverage());
                if (subjectCoverageShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<SubjectType> sourceSubjectCoverage;
                    sourceSubjectCoverage = (this.isSetSubjectCoverage()?this.getSubjectCoverage():null);
                    @SuppressWarnings("unchecked")
                    List<SubjectType> copySubjectCoverage = ((List<SubjectType> ) strategy.copy(LocatorUtils.property(locator, "subjectCoverage", sourceSubjectCoverage), sourceSubjectCoverage, this.isSetSubjectCoverage()));
                    copy.unsetSubjectCoverage();
                    if (copySubjectCoverage!= null) {
                        List<SubjectType> uniqueSubjectCoveragel = copy.getSubjectCoverage();
                        uniqueSubjectCoveragel.addAll(copySubjectCoverage);
                    }
                } else {
                    if (subjectCoverageShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSubjectCoverage();
                    }
                }
            }
            {
                Boolean virtualCoverageShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetVirtualCoverage());
                if (virtualCoverageShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<VirtualCoverageType> sourceVirtualCoverage;
                    sourceVirtualCoverage = (this.isSetVirtualCoverage()?this.getVirtualCoverage():null);
                    @SuppressWarnings("unchecked")
                    List<VirtualCoverageType> copyVirtualCoverage = ((List<VirtualCoverageType> ) strategy.copy(LocatorUtils.property(locator, "virtualCoverage", sourceVirtualCoverage), sourceVirtualCoverage, this.isSetVirtualCoverage()));
                    copy.unsetVirtualCoverage();
                    if (copyVirtualCoverage!= null) {
                        List<VirtualCoverageType> uniqueVirtualCoveragel = copy.getVirtualCoverage();
                        uniqueVirtualCoveragel.addAll(copyVirtualCoverage);
                    }
                } else {
                    if (virtualCoverageShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetVirtualCoverage();
                    }
                }
            }
            {
                Boolean temporalCoverageShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTemporalCoverage());
                if (temporalCoverageShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<TimePeriodType> sourceTemporalCoverage;
                    sourceTemporalCoverage = (this.isSetTemporalCoverage()?this.getTemporalCoverage():null);
                    @SuppressWarnings("unchecked")
                    List<TimePeriodType> copyTemporalCoverage = ((List<TimePeriodType> ) strategy.copy(LocatorUtils.property(locator, "temporalCoverage", sourceTemporalCoverage), sourceTemporalCoverage, this.isSetTemporalCoverage()));
                    copy.unsetTemporalCoverage();
                    if (copyTemporalCoverage!= null) {
                        List<TimePeriodType> uniqueTemporalCoveragel = copy.getTemporalCoverage();
                        uniqueTemporalCoveragel.addAll(copyTemporalCoverage);
                    }
                } else {
                    if (temporalCoverageShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetTemporalCoverage();
                    }
                }
            }
            {
                Boolean geospatialCoverageShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetGeospatialCoverage());
                if (geospatialCoverageShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<PlaceType> sourceGeospatialCoverage;
                    sourceGeospatialCoverage = (this.isSetGeospatialCoverage()?this.getGeospatialCoverage():null);
                    @SuppressWarnings("unchecked")
                    List<PlaceType> copyGeospatialCoverage = ((List<PlaceType> ) strategy.copy(LocatorUtils.property(locator, "geospatialCoverage", sourceGeospatialCoverage), sourceGeospatialCoverage, this.isSetGeospatialCoverage()));
                    copy.unsetGeospatialCoverage();
                    if (copyGeospatialCoverage!= null) {
                        List<PlaceType> uniqueGeospatialCoveragel = copy.getGeospatialCoverage();
                        uniqueGeospatialCoveragel.addAll(copyGeospatialCoverage);
                    }
                } else {
                    if (geospatialCoverageShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetGeospatialCoverage();
                    }
                }
            }
            {
                Boolean relatedResourceShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRelatedResource());
                if (relatedResourceShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<RelatedResourcesType> sourceRelatedResource;
                    sourceRelatedResource = (this.isSetRelatedResource()?this.getRelatedResource():null);
                    @SuppressWarnings("unchecked")
                    List<RelatedResourcesType> copyRelatedResource = ((List<RelatedResourcesType> ) strategy.copy(LocatorUtils.property(locator, "relatedResource", sourceRelatedResource), sourceRelatedResource, this.isSetRelatedResource()));
                    copy.unsetRelatedResource();
                    if (copyRelatedResource!= null) {
                        List<RelatedResourcesType> uniqueRelatedResourcel = copy.getRelatedResource();
                        uniqueRelatedResourcel.addAll(copyRelatedResource);
                    }
                } else {
                    if (relatedResourceShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetRelatedResource();
                    }
                }
            }
            {
                Boolean resourceManagementShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetResourceManagement());
                if (resourceManagementShouldBeCopiedAndSet == Boolean.TRUE) {
                    ResourceManagementType sourceResourceManagement;
                    sourceResourceManagement = this.getResourceManagement();
                    ResourceManagementType copyResourceManagement = ((ResourceManagementType) strategy.copy(LocatorUtils.property(locator, "resourceManagement", sourceResourceManagement), sourceResourceManagement, this.isSetResourceManagement()));
                    copy.setResourceManagement(copyResourceManagement);
                } else {
                    if (resourceManagementShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.resourceManagement = null;
                    }
                }
            }
            {
                Boolean compliesWithShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompliesWith());
                if (compliesWithShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceCompliesWith;
                    sourceCompliesWith = (this.isSetCompliesWith()?this.getCompliesWith():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyCompliesWith = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "compliesWith", sourceCompliesWith), sourceCompliesWith, this.isSetCompliesWith()));
                    copy.unsetCompliesWith();
                    if (copyCompliesWith!= null) {
                        List<String> uniqueCompliesWithl = copy.getCompliesWith();
                        uniqueCompliesWithl.addAll(copyCompliesWith);
                    }
                } else {
                    if (compliesWithShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetCompliesWith();
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new ResourceType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof ResourceType) {
            final ResourceType target = this;
            final ResourceType leftObject = ((ResourceType) left);
            final ResourceType rightObject = ((ResourceType) right);
            {
                Boolean metacardInfoShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetMetacardInfo(), rightObject.isSetMetacardInfo());
                if (metacardInfoShouldBeMergedAndSet == Boolean.TRUE) {
                    MetacardInfoType lhsMetacardInfo;
                    lhsMetacardInfo = leftObject.getMetacardInfo();
                    MetacardInfoType rhsMetacardInfo;
                    rhsMetacardInfo = rightObject.getMetacardInfo();
                    MetacardInfoType mergedMetacardInfo = ((MetacardInfoType) strategy.merge(LocatorUtils.property(leftLocator, "metacardInfo", lhsMetacardInfo), LocatorUtils.property(rightLocator, "metacardInfo", rhsMetacardInfo), lhsMetacardInfo, rhsMetacardInfo, leftObject.isSetMetacardInfo(), rightObject.isSetMetacardInfo()));
                    target.setMetacardInfo(mergedMetacardInfo);
                } else {
                    if (metacardInfoShouldBeMergedAndSet == Boolean.FALSE) {
                        target.metacardInfo = null;
                    }
                }
            }
            {
                Boolean identifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetIdentifier(), rightObject.isSetIdentifier());
                if (identifierShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CompoundResourceIdentifierType> lhsIdentifier;
                    lhsIdentifier = (leftObject.isSetIdentifier()?leftObject.getIdentifier():null);
                    List<CompoundResourceIdentifierType> rhsIdentifier;
                    rhsIdentifier = (rightObject.isSetIdentifier()?rightObject.getIdentifier():null);
                    List<CompoundResourceIdentifierType> mergedIdentifier = ((List<CompoundResourceIdentifierType> ) strategy.merge(LocatorUtils.property(leftLocator, "identifier", lhsIdentifier), LocatorUtils.property(rightLocator, "identifier", rhsIdentifier), lhsIdentifier, rhsIdentifier, leftObject.isSetIdentifier(), rightObject.isSetIdentifier()));
                    target.unsetIdentifier();
                    if (mergedIdentifier!= null) {
                        List<CompoundResourceIdentifierType> uniqueIdentifierl = target.getIdentifier();
                        uniqueIdentifierl.addAll(mergedIdentifier);
                    }
                } else {
                    if (identifierShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetIdentifier();
                    }
                }
            }
            {
                Boolean titleShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTitle(), rightObject.isSetTitle());
                if (titleShouldBeMergedAndSet == Boolean.TRUE) {
                    List<TitleType> lhsTitle;
                    lhsTitle = (leftObject.isSetTitle()?leftObject.getTitle():null);
                    List<TitleType> rhsTitle;
                    rhsTitle = (rightObject.isSetTitle()?rightObject.getTitle():null);
                    List<TitleType> mergedTitle = ((List<TitleType> ) strategy.merge(LocatorUtils.property(leftLocator, "title", lhsTitle), LocatorUtils.property(rightLocator, "title", rhsTitle), lhsTitle, rhsTitle, leftObject.isSetTitle(), rightObject.isSetTitle()));
                    target.unsetTitle();
                    if (mergedTitle!= null) {
                        List<TitleType> uniqueTitlel = target.getTitle();
                        uniqueTitlel.addAll(mergedTitle);
                    }
                } else {
                    if (titleShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetTitle();
                    }
                }
            }
            {
                Boolean subtitleShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSubtitle(), rightObject.isSetSubtitle());
                if (subtitleShouldBeMergedAndSet == Boolean.TRUE) {
                    List<SubtitleType> lhsSubtitle;
                    lhsSubtitle = (leftObject.isSetSubtitle()?leftObject.getSubtitle():null);
                    List<SubtitleType> rhsSubtitle;
                    rhsSubtitle = (rightObject.isSetSubtitle()?rightObject.getSubtitle():null);
                    List<SubtitleType> mergedSubtitle = ((List<SubtitleType> ) strategy.merge(LocatorUtils.property(leftLocator, "subtitle", lhsSubtitle), LocatorUtils.property(rightLocator, "subtitle", rhsSubtitle), lhsSubtitle, rhsSubtitle, leftObject.isSetSubtitle(), rightObject.isSetSubtitle()));
                    target.unsetSubtitle();
                    if (mergedSubtitle!= null) {
                        List<SubtitleType> uniqueSubtitlel = target.getSubtitle();
                        uniqueSubtitlel.addAll(mergedSubtitle);
                    }
                } else {
                    if (subtitleShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSubtitle();
                    }
                }
            }
            {
                Boolean descriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDescription(), rightObject.isSetDescription());
                if (descriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    DescriptionType lhsDescription;
                    lhsDescription = leftObject.getDescription();
                    DescriptionType rhsDescription;
                    rhsDescription = rightObject.getDescription();
                    DescriptionType mergedDescription = ((DescriptionType) strategy.merge(LocatorUtils.property(leftLocator, "description", lhsDescription), LocatorUtils.property(rightLocator, "description", rhsDescription), lhsDescription, rhsDescription, leftObject.isSetDescription(), rightObject.isSetDescription()));
                    target.setDescription(mergedDescription);
                } else {
                    if (descriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.description = null;
                    }
                }
            }
            {
                Boolean languageShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetLanguage(), rightObject.isSetLanguage());
                if (languageShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CompoundLanguageIdentifierType> lhsLanguage;
                    lhsLanguage = (leftObject.isSetLanguage()?leftObject.getLanguage():null);
                    List<CompoundLanguageIdentifierType> rhsLanguage;
                    rhsLanguage = (rightObject.isSetLanguage()?rightObject.getLanguage():null);
                    List<CompoundLanguageIdentifierType> mergedLanguage = ((List<CompoundLanguageIdentifierType> ) strategy.merge(LocatorUtils.property(leftLocator, "language", lhsLanguage), LocatorUtils.property(rightLocator, "language", rhsLanguage), lhsLanguage, rhsLanguage, leftObject.isSetLanguage(), rightObject.isSetLanguage()));
                    target.unsetLanguage();
                    if (mergedLanguage!= null) {
                        List<CompoundLanguageIdentifierType> uniqueLanguagel = target.getLanguage();
                        uniqueLanguagel.addAll(mergedLanguage);
                    }
                } else {
                    if (languageShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetLanguage();
                    }
                }
            }
            {
                Boolean datesShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDates(), rightObject.isSetDates());
                if (datesShouldBeMergedAndSet == Boolean.TRUE) {
                    DatesType lhsDates;
                    lhsDates = leftObject.getDates();
                    DatesType rhsDates;
                    rhsDates = rightObject.getDates();
                    DatesType mergedDates = ((DatesType) strategy.merge(LocatorUtils.property(leftLocator, "dates", lhsDates), LocatorUtils.property(rightLocator, "dates", rhsDates), lhsDates, rhsDates, leftObject.isSetDates(), rightObject.isSetDates()));
                    target.setDates(mergedDates);
                } else {
                    if (datesShouldBeMergedAndSet == Boolean.FALSE) {
                        target.dates = null;
                    }
                }
            }
            {
                Boolean rightsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRights(), rightObject.isSetRights());
                if (rightsShouldBeMergedAndSet == Boolean.TRUE) {
                    RightsType lhsRights;
                    lhsRights = leftObject.getRights();
                    RightsType rhsRights;
                    rhsRights = rightObject.getRights();
                    RightsType mergedRights = ((RightsType) strategy.merge(LocatorUtils.property(leftLocator, "rights", lhsRights), LocatorUtils.property(rightLocator, "rights", rhsRights), lhsRights, rhsRights, leftObject.isSetRights(), rightObject.isSetRights()));
                    target.setRights(mergedRights);
                } else {
                    if (rightsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.rights = null;
                    }
                }
            }
            {
                Boolean sourceShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSource(), rightObject.isSetSource());
                if (sourceShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CompoundSourceIdentifierType> lhsSource;
                    lhsSource = (leftObject.isSetSource()?leftObject.getSource():null);
                    List<CompoundSourceIdentifierType> rhsSource;
                    rhsSource = (rightObject.isSetSource()?rightObject.getSource():null);
                    List<CompoundSourceIdentifierType> mergedSource = ((List<CompoundSourceIdentifierType> ) strategy.merge(LocatorUtils.property(leftLocator, "source", lhsSource), LocatorUtils.property(rightLocator, "source", rhsSource), lhsSource, rhsSource, leftObject.isSetSource(), rightObject.isSetSource()));
                    target.unsetSource();
                    if (mergedSource!= null) {
                        List<CompoundSourceIdentifierType> uniqueSourcel = target.getSource();
                        uniqueSourcel.addAll(mergedSource);
                    }
                } else {
                    if (sourceShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSource();
                    }
                }
            }
            {
                Boolean typeShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetType(), rightObject.isSetType());
                if (typeShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CompoundTypeIdentifierType> lhsType;
                    lhsType = (leftObject.isSetType()?leftObject.getType():null);
                    List<CompoundTypeIdentifierType> rhsType;
                    rhsType = (rightObject.isSetType()?rightObject.getType():null);
                    List<CompoundTypeIdentifierType> mergedType = ((List<CompoundTypeIdentifierType> ) strategy.merge(LocatorUtils.property(leftLocator, "type", lhsType), LocatorUtils.property(rightLocator, "type", rhsType), lhsType, rhsType, leftObject.isSetType(), rightObject.isSetType()));
                    target.unsetType();
                    if (mergedType!= null) {
                        List<CompoundTypeIdentifierType> uniqueTypel = target.getType();
                        uniqueTypel.addAll(mergedType);
                    }
                } else {
                    if (typeShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetType();
                    }
                }
            }
            {
                Boolean creatorOrPublisherOrContributorShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCreatorOrPublisherOrContributor(), rightObject.isSetCreatorOrPublisherOrContributor());
                if (creatorOrPublisherOrContributorShouldBeMergedAndSet == Boolean.TRUE) {
                    List<JAXBElement<ContactInfoType>> lhsCreatorOrPublisherOrContributor;
                    lhsCreatorOrPublisherOrContributor = (leftObject.isSetCreatorOrPublisherOrContributor()?leftObject.getCreatorOrPublisherOrContributor():null);
                    List<JAXBElement<ContactInfoType>> rhsCreatorOrPublisherOrContributor;
                    rhsCreatorOrPublisherOrContributor = (rightObject.isSetCreatorOrPublisherOrContributor()?rightObject.getCreatorOrPublisherOrContributor():null);
                    List<JAXBElement<ContactInfoType>> mergedCreatorOrPublisherOrContributor = ((List<JAXBElement<ContactInfoType>> ) strategy.merge(LocatorUtils.property(leftLocator, "creatorOrPublisherOrContributor", lhsCreatorOrPublisherOrContributor), LocatorUtils.property(rightLocator, "creatorOrPublisherOrContributor", rhsCreatorOrPublisherOrContributor), lhsCreatorOrPublisherOrContributor, rhsCreatorOrPublisherOrContributor, leftObject.isSetCreatorOrPublisherOrContributor(), rightObject.isSetCreatorOrPublisherOrContributor()));
                    target.unsetCreatorOrPublisherOrContributor();
                    if (mergedCreatorOrPublisherOrContributor!= null) {
                        List<JAXBElement<ContactInfoType>> uniqueCreatorOrPublisherOrContributorl = target.getCreatorOrPublisherOrContributor();
                        uniqueCreatorOrPublisherOrContributorl.addAll(mergedCreatorOrPublisherOrContributor);
                    }
                } else {
                    if (creatorOrPublisherOrContributorShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetCreatorOrPublisherOrContributor();
                    }
                }
            }
            {
                Boolean formatShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFormat(), rightObject.isSetFormat());
                if (formatShouldBeMergedAndSet == Boolean.TRUE) {
                    FormatType lhsFormat;
                    lhsFormat = leftObject.getFormat();
                    FormatType rhsFormat;
                    rhsFormat = rightObject.getFormat();
                    FormatType mergedFormat = ((FormatType) strategy.merge(LocatorUtils.property(leftLocator, "format", lhsFormat), LocatorUtils.property(rightLocator, "format", rhsFormat), lhsFormat, rhsFormat, leftObject.isSetFormat(), rightObject.isSetFormat()));
                    target.setFormat(mergedFormat);
                } else {
                    if (formatShouldBeMergedAndSet == Boolean.FALSE) {
                        target.format = null;
                    }
                }
            }
            {
                Boolean subjectCoverageShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSubjectCoverage(), rightObject.isSetSubjectCoverage());
                if (subjectCoverageShouldBeMergedAndSet == Boolean.TRUE) {
                    List<SubjectType> lhsSubjectCoverage;
                    lhsSubjectCoverage = (leftObject.isSetSubjectCoverage()?leftObject.getSubjectCoverage():null);
                    List<SubjectType> rhsSubjectCoverage;
                    rhsSubjectCoverage = (rightObject.isSetSubjectCoverage()?rightObject.getSubjectCoverage():null);
                    List<SubjectType> mergedSubjectCoverage = ((List<SubjectType> ) strategy.merge(LocatorUtils.property(leftLocator, "subjectCoverage", lhsSubjectCoverage), LocatorUtils.property(rightLocator, "subjectCoverage", rhsSubjectCoverage), lhsSubjectCoverage, rhsSubjectCoverage, leftObject.isSetSubjectCoverage(), rightObject.isSetSubjectCoverage()));
                    target.unsetSubjectCoverage();
                    if (mergedSubjectCoverage!= null) {
                        List<SubjectType> uniqueSubjectCoveragel = target.getSubjectCoverage();
                        uniqueSubjectCoveragel.addAll(mergedSubjectCoverage);
                    }
                } else {
                    if (subjectCoverageShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSubjectCoverage();
                    }
                }
            }
            {
                Boolean virtualCoverageShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetVirtualCoverage(), rightObject.isSetVirtualCoverage());
                if (virtualCoverageShouldBeMergedAndSet == Boolean.TRUE) {
                    List<VirtualCoverageType> lhsVirtualCoverage;
                    lhsVirtualCoverage = (leftObject.isSetVirtualCoverage()?leftObject.getVirtualCoverage():null);
                    List<VirtualCoverageType> rhsVirtualCoverage;
                    rhsVirtualCoverage = (rightObject.isSetVirtualCoverage()?rightObject.getVirtualCoverage():null);
                    List<VirtualCoverageType> mergedVirtualCoverage = ((List<VirtualCoverageType> ) strategy.merge(LocatorUtils.property(leftLocator, "virtualCoverage", lhsVirtualCoverage), LocatorUtils.property(rightLocator, "virtualCoverage", rhsVirtualCoverage), lhsVirtualCoverage, rhsVirtualCoverage, leftObject.isSetVirtualCoverage(), rightObject.isSetVirtualCoverage()));
                    target.unsetVirtualCoverage();
                    if (mergedVirtualCoverage!= null) {
                        List<VirtualCoverageType> uniqueVirtualCoveragel = target.getVirtualCoverage();
                        uniqueVirtualCoveragel.addAll(mergedVirtualCoverage);
                    }
                } else {
                    if (virtualCoverageShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetVirtualCoverage();
                    }
                }
            }
            {
                Boolean temporalCoverageShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTemporalCoverage(), rightObject.isSetTemporalCoverage());
                if (temporalCoverageShouldBeMergedAndSet == Boolean.TRUE) {
                    List<TimePeriodType> lhsTemporalCoverage;
                    lhsTemporalCoverage = (leftObject.isSetTemporalCoverage()?leftObject.getTemporalCoverage():null);
                    List<TimePeriodType> rhsTemporalCoverage;
                    rhsTemporalCoverage = (rightObject.isSetTemporalCoverage()?rightObject.getTemporalCoverage():null);
                    List<TimePeriodType> mergedTemporalCoverage = ((List<TimePeriodType> ) strategy.merge(LocatorUtils.property(leftLocator, "temporalCoverage", lhsTemporalCoverage), LocatorUtils.property(rightLocator, "temporalCoverage", rhsTemporalCoverage), lhsTemporalCoverage, rhsTemporalCoverage, leftObject.isSetTemporalCoverage(), rightObject.isSetTemporalCoverage()));
                    target.unsetTemporalCoverage();
                    if (mergedTemporalCoverage!= null) {
                        List<TimePeriodType> uniqueTemporalCoveragel = target.getTemporalCoverage();
                        uniqueTemporalCoveragel.addAll(mergedTemporalCoverage);
                    }
                } else {
                    if (temporalCoverageShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetTemporalCoverage();
                    }
                }
            }
            {
                Boolean geospatialCoverageShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetGeospatialCoverage(), rightObject.isSetGeospatialCoverage());
                if (geospatialCoverageShouldBeMergedAndSet == Boolean.TRUE) {
                    List<PlaceType> lhsGeospatialCoverage;
                    lhsGeospatialCoverage = (leftObject.isSetGeospatialCoverage()?leftObject.getGeospatialCoverage():null);
                    List<PlaceType> rhsGeospatialCoverage;
                    rhsGeospatialCoverage = (rightObject.isSetGeospatialCoverage()?rightObject.getGeospatialCoverage():null);
                    List<PlaceType> mergedGeospatialCoverage = ((List<PlaceType> ) strategy.merge(LocatorUtils.property(leftLocator, "geospatialCoverage", lhsGeospatialCoverage), LocatorUtils.property(rightLocator, "geospatialCoverage", rhsGeospatialCoverage), lhsGeospatialCoverage, rhsGeospatialCoverage, leftObject.isSetGeospatialCoverage(), rightObject.isSetGeospatialCoverage()));
                    target.unsetGeospatialCoverage();
                    if (mergedGeospatialCoverage!= null) {
                        List<PlaceType> uniqueGeospatialCoveragel = target.getGeospatialCoverage();
                        uniqueGeospatialCoveragel.addAll(mergedGeospatialCoverage);
                    }
                } else {
                    if (geospatialCoverageShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetGeospatialCoverage();
                    }
                }
            }
            {
                Boolean relatedResourceShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRelatedResource(), rightObject.isSetRelatedResource());
                if (relatedResourceShouldBeMergedAndSet == Boolean.TRUE) {
                    List<RelatedResourcesType> lhsRelatedResource;
                    lhsRelatedResource = (leftObject.isSetRelatedResource()?leftObject.getRelatedResource():null);
                    List<RelatedResourcesType> rhsRelatedResource;
                    rhsRelatedResource = (rightObject.isSetRelatedResource()?rightObject.getRelatedResource():null);
                    List<RelatedResourcesType> mergedRelatedResource = ((List<RelatedResourcesType> ) strategy.merge(LocatorUtils.property(leftLocator, "relatedResource", lhsRelatedResource), LocatorUtils.property(rightLocator, "relatedResource", rhsRelatedResource), lhsRelatedResource, rhsRelatedResource, leftObject.isSetRelatedResource(), rightObject.isSetRelatedResource()));
                    target.unsetRelatedResource();
                    if (mergedRelatedResource!= null) {
                        List<RelatedResourcesType> uniqueRelatedResourcel = target.getRelatedResource();
                        uniqueRelatedResourcel.addAll(mergedRelatedResource);
                    }
                } else {
                    if (relatedResourceShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetRelatedResource();
                    }
                }
            }
            {
                Boolean resourceManagementShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetResourceManagement(), rightObject.isSetResourceManagement());
                if (resourceManagementShouldBeMergedAndSet == Boolean.TRUE) {
                    ResourceManagementType lhsResourceManagement;
                    lhsResourceManagement = leftObject.getResourceManagement();
                    ResourceManagementType rhsResourceManagement;
                    rhsResourceManagement = rightObject.getResourceManagement();
                    ResourceManagementType mergedResourceManagement = ((ResourceManagementType) strategy.merge(LocatorUtils.property(leftLocator, "resourceManagement", lhsResourceManagement), LocatorUtils.property(rightLocator, "resourceManagement", rhsResourceManagement), lhsResourceManagement, rhsResourceManagement, leftObject.isSetResourceManagement(), rightObject.isSetResourceManagement()));
                    target.setResourceManagement(mergedResourceManagement);
                } else {
                    if (resourceManagementShouldBeMergedAndSet == Boolean.FALSE) {
                        target.resourceManagement = null;
                    }
                }
            }
            {
                Boolean compliesWithShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompliesWith(), rightObject.isSetCompliesWith());
                if (compliesWithShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsCompliesWith;
                    lhsCompliesWith = (leftObject.isSetCompliesWith()?leftObject.getCompliesWith():null);
                    List<String> rhsCompliesWith;
                    rhsCompliesWith = (rightObject.isSetCompliesWith()?rightObject.getCompliesWith():null);
                    List<String> mergedCompliesWith = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "compliesWith", lhsCompliesWith), LocatorUtils.property(rightLocator, "compliesWith", rhsCompliesWith), lhsCompliesWith, rhsCompliesWith, leftObject.isSetCompliesWith(), rightObject.isSetCompliesWith()));
                    target.unsetCompliesWith();
                    if (mergedCompliesWith!= null) {
                        List<String> uniqueCompliesWithl = target.getCompliesWith();
                        uniqueCompliesWithl.addAll(mergedCompliesWith);
                    }
                } else {
                    if (compliesWithShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetCompliesWith();
                    }
                }
            }
        }
    }

    public void setIdentifier(List<CompoundResourceIdentifierType> value) {
        this.identifier = null;
        if (value!= null) {
            List<CompoundResourceIdentifierType> draftl = this.getIdentifier();
            draftl.addAll(value);
        }
    }

    public void setTitle(List<TitleType> value) {
        this.title = null;
        if (value!= null) {
            List<TitleType> draftl = this.getTitle();
            draftl.addAll(value);
        }
    }

    public void setSubtitle(List<SubtitleType> value) {
        this.subtitle = null;
        if (value!= null) {
            List<SubtitleType> draftl = this.getSubtitle();
            draftl.addAll(value);
        }
    }

    public void setLanguage(List<CompoundLanguageIdentifierType> value) {
        this.language = null;
        if (value!= null) {
            List<CompoundLanguageIdentifierType> draftl = this.getLanguage();
            draftl.addAll(value);
        }
    }

    public void setSource(List<CompoundSourceIdentifierType> value) {
        this.source = null;
        if (value!= null) {
            List<CompoundSourceIdentifierType> draftl = this.getSource();
            draftl.addAll(value);
        }
    }

    public void setType(List<CompoundTypeIdentifierType> value) {
        this.type = null;
        if (value!= null) {
            List<CompoundTypeIdentifierType> draftl = this.getType();
            draftl.addAll(value);
        }
    }

    public void setCreatorOrPublisherOrContributor(List<JAXBElement<ContactInfoType>> value) {
        this.creatorOrPublisherOrContributor = null;
        if (value!= null) {
            List<JAXBElement<ContactInfoType>> draftl = this.getCreatorOrPublisherOrContributor();
            draftl.addAll(value);
        }
    }

    public void setSubjectCoverage(List<SubjectType> value) {
        this.subjectCoverage = null;
        if (value!= null) {
            List<SubjectType> draftl = this.getSubjectCoverage();
            draftl.addAll(value);
        }
    }

    public void setVirtualCoverage(List<VirtualCoverageType> value) {
        this.virtualCoverage = null;
        if (value!= null) {
            List<VirtualCoverageType> draftl = this.getVirtualCoverage();
            draftl.addAll(value);
        }
    }

    public void setTemporalCoverage(List<TimePeriodType> value) {
        this.temporalCoverage = null;
        if (value!= null) {
            List<TimePeriodType> draftl = this.getTemporalCoverage();
            draftl.addAll(value);
        }
    }

    public void setGeospatialCoverage(List<PlaceType> value) {
        this.geospatialCoverage = null;
        if (value!= null) {
            List<PlaceType> draftl = this.getGeospatialCoverage();
            draftl.addAll(value);
        }
    }

    public void setRelatedResource(List<RelatedResourcesType> value) {
        this.relatedResource = null;
        if (value!= null) {
            List<RelatedResourcesType> draftl = this.getRelatedResource();
            draftl.addAll(value);
        }
    }

    public void setCompliesWith(List<String> value) {
        this.compliesWith = null;
        if (value!= null) {
            List<String> draftl = this.getCompliesWith();
            draftl.addAll(value);
        }
    }

}
