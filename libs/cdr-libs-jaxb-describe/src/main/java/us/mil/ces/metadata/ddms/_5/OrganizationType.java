//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.datatype.XMLGregorianCalendar;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import us.gov.ic.cvenum.ism._25x.CVEnumISM25X;
import us.gov.ic.cvenum.ism.classification.all.CVEnumISMClassificationAll;
import us.gov.ic.cvenum.ism.dissem.CVEnumISMDissemValues;
import us.gov.ic.cvenum.ism.nonic.CVEnumISMNonICValues;
import us.gov.ic.cvenum.ism.nonuscontrols.CVEnumISMNonUSControlsValues;
import us.gov.ic.cvenum.ism.scicontrols.CVEnumISMSCIControlsValues;


/**
 * <p>Java class for OrganizationType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="OrganizationType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence minOccurs="0"&gt;
 *         &lt;element name="name" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" maxOccurs="unbounded"/&gt;
 *         &lt;element name="phone" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="email" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="subOrganization" maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;simpleContent&gt;
 *               &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;simpleTokenType"&gt;
 *                 &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
 *               &lt;/extension&gt;
 *             &lt;/simpleContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute ref="{urn:us:mil:ces:metadata:ddms:5}acronym"/&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "OrganizationType", propOrder = {
    "name",
    "phone",
    "email",
    "subOrganization"
})
public class OrganizationType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "token")
    @Size(min = 1)
    protected List<String> name;
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "token")
    protected List<String> phone;
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "token")
    protected List<String> email;
    @Valid
    protected List<OrganizationType.SubOrganization> subOrganization;
    @XmlAttribute(name = "acronym", namespace = "urn:us:mil:ces:metadata:ddms:5")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @Size(min = 1)
    protected String acronym;

    /**
     * Gets the value of the name property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the name property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getName().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getName() {
        if (name == null) {
            name = new ArrayList<String>();
        }
        return this.name;
    }

    public boolean isSetName() {
        return ((this.name!= null)&&(!this.name.isEmpty()));
    }

    public void unsetName() {
        this.name = null;
    }

    /**
     * Gets the value of the phone property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the phone property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhone().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getPhone() {
        if (phone == null) {
            phone = new ArrayList<String>();
        }
        return this.phone;
    }

    public boolean isSetPhone() {
        return ((this.phone!= null)&&(!this.phone.isEmpty()));
    }

    public void unsetPhone() {
        this.phone = null;
    }

    /**
     * Gets the value of the email property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the email property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmail().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getEmail() {
        if (email == null) {
            email = new ArrayList<String>();
        }
        return this.email;
    }

    public boolean isSetEmail() {
        return ((this.email!= null)&&(!this.email.isEmpty()));
    }

    public void unsetEmail() {
        this.email = null;
    }

    /**
     * Gets the value of the subOrganization property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subOrganization property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubOrganization().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OrganizationType.SubOrganization }
     * 
     * 
     */
    public List<OrganizationType.SubOrganization> getSubOrganization() {
        if (subOrganization == null) {
            subOrganization = new ArrayList<OrganizationType.SubOrganization>();
        }
        return this.subOrganization;
    }

    public boolean isSetSubOrganization() {
        return ((this.subOrganization!= null)&&(!this.subOrganization.isEmpty()));
    }

    public void unsetSubOrganization() {
        this.subOrganization = null;
    }

    /**
     * Gets the value of the acronym property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getAcronym() {
        return acronym;
    }

    /**
     * Sets the value of the acronym property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setAcronym(String value) {
        this.acronym = value;
    }

    public boolean isSetAcronym() {
        return (this.acronym!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            List<String> theName;
            theName = (this.isSetName()?this.getName():null);
            strategy.appendField(locator, this, "name", buffer, theName, this.isSetName());
        }
        {
            List<String> thePhone;
            thePhone = (this.isSetPhone()?this.getPhone():null);
            strategy.appendField(locator, this, "phone", buffer, thePhone, this.isSetPhone());
        }
        {
            List<String> theEmail;
            theEmail = (this.isSetEmail()?this.getEmail():null);
            strategy.appendField(locator, this, "email", buffer, theEmail, this.isSetEmail());
        }
        {
            List<OrganizationType.SubOrganization> theSubOrganization;
            theSubOrganization = (this.isSetSubOrganization()?this.getSubOrganization():null);
            strategy.appendField(locator, this, "subOrganization", buffer, theSubOrganization, this.isSetSubOrganization());
        }
        {
            String theAcronym;
            theAcronym = this.getAcronym();
            strategy.appendField(locator, this, "acronym", buffer, theAcronym, this.isSetAcronym());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final OrganizationType that = ((OrganizationType) object);
        {
            List<String> lhsName;
            lhsName = (this.isSetName()?this.getName():null);
            List<String> rhsName;
            rhsName = (that.isSetName()?that.getName():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "name", lhsName), LocatorUtils.property(thatLocator, "name", rhsName), lhsName, rhsName, this.isSetName(), that.isSetName())) {
                return false;
            }
        }
        {
            List<String> lhsPhone;
            lhsPhone = (this.isSetPhone()?this.getPhone():null);
            List<String> rhsPhone;
            rhsPhone = (that.isSetPhone()?that.getPhone():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "phone", lhsPhone), LocatorUtils.property(thatLocator, "phone", rhsPhone), lhsPhone, rhsPhone, this.isSetPhone(), that.isSetPhone())) {
                return false;
            }
        }
        {
            List<String> lhsEmail;
            lhsEmail = (this.isSetEmail()?this.getEmail():null);
            List<String> rhsEmail;
            rhsEmail = (that.isSetEmail()?that.getEmail():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "email", lhsEmail), LocatorUtils.property(thatLocator, "email", rhsEmail), lhsEmail, rhsEmail, this.isSetEmail(), that.isSetEmail())) {
                return false;
            }
        }
        {
            List<OrganizationType.SubOrganization> lhsSubOrganization;
            lhsSubOrganization = (this.isSetSubOrganization()?this.getSubOrganization():null);
            List<OrganizationType.SubOrganization> rhsSubOrganization;
            rhsSubOrganization = (that.isSetSubOrganization()?that.getSubOrganization():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "subOrganization", lhsSubOrganization), LocatorUtils.property(thatLocator, "subOrganization", rhsSubOrganization), lhsSubOrganization, rhsSubOrganization, this.isSetSubOrganization(), that.isSetSubOrganization())) {
                return false;
            }
        }
        {
            String lhsAcronym;
            lhsAcronym = this.getAcronym();
            String rhsAcronym;
            rhsAcronym = that.getAcronym();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "acronym", lhsAcronym), LocatorUtils.property(thatLocator, "acronym", rhsAcronym), lhsAcronym, rhsAcronym, this.isSetAcronym(), that.isSetAcronym())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            List<String> theName;
            theName = (this.isSetName()?this.getName():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "name", theName), currentHashCode, theName, this.isSetName());
        }
        {
            List<String> thePhone;
            thePhone = (this.isSetPhone()?this.getPhone():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "phone", thePhone), currentHashCode, thePhone, this.isSetPhone());
        }
        {
            List<String> theEmail;
            theEmail = (this.isSetEmail()?this.getEmail():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "email", theEmail), currentHashCode, theEmail, this.isSetEmail());
        }
        {
            List<OrganizationType.SubOrganization> theSubOrganization;
            theSubOrganization = (this.isSetSubOrganization()?this.getSubOrganization():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "subOrganization", theSubOrganization), currentHashCode, theSubOrganization, this.isSetSubOrganization());
        }
        {
            String theAcronym;
            theAcronym = this.getAcronym();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "acronym", theAcronym), currentHashCode, theAcronym, this.isSetAcronym());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof OrganizationType) {
            final OrganizationType copy = ((OrganizationType) draftCopy);
            {
                Boolean nameShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetName());
                if (nameShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceName;
                    sourceName = (this.isSetName()?this.getName():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyName = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "name", sourceName), sourceName, this.isSetName()));
                    copy.unsetName();
                    if (copyName!= null) {
                        List<String> uniqueNamel = copy.getName();
                        uniqueNamel.addAll(copyName);
                    }
                } else {
                    if (nameShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetName();
                    }
                }
            }
            {
                Boolean phoneShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPhone());
                if (phoneShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourcePhone;
                    sourcePhone = (this.isSetPhone()?this.getPhone():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyPhone = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "phone", sourcePhone), sourcePhone, this.isSetPhone()));
                    copy.unsetPhone();
                    if (copyPhone!= null) {
                        List<String> uniquePhonel = copy.getPhone();
                        uniquePhonel.addAll(copyPhone);
                    }
                } else {
                    if (phoneShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetPhone();
                    }
                }
            }
            {
                Boolean emailShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetEmail());
                if (emailShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceEmail;
                    sourceEmail = (this.isSetEmail()?this.getEmail():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyEmail = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "email", sourceEmail), sourceEmail, this.isSetEmail()));
                    copy.unsetEmail();
                    if (copyEmail!= null) {
                        List<String> uniqueEmaill = copy.getEmail();
                        uniqueEmaill.addAll(copyEmail);
                    }
                } else {
                    if (emailShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetEmail();
                    }
                }
            }
            {
                Boolean subOrganizationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSubOrganization());
                if (subOrganizationShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<OrganizationType.SubOrganization> sourceSubOrganization;
                    sourceSubOrganization = (this.isSetSubOrganization()?this.getSubOrganization():null);
                    @SuppressWarnings("unchecked")
                    List<OrganizationType.SubOrganization> copySubOrganization = ((List<OrganizationType.SubOrganization> ) strategy.copy(LocatorUtils.property(locator, "subOrganization", sourceSubOrganization), sourceSubOrganization, this.isSetSubOrganization()));
                    copy.unsetSubOrganization();
                    if (copySubOrganization!= null) {
                        List<OrganizationType.SubOrganization> uniqueSubOrganizationl = copy.getSubOrganization();
                        uniqueSubOrganizationl.addAll(copySubOrganization);
                    }
                } else {
                    if (subOrganizationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSubOrganization();
                    }
                }
            }
            {
                Boolean acronymShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAcronym());
                if (acronymShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceAcronym;
                    sourceAcronym = this.getAcronym();
                    String copyAcronym = ((String) strategy.copy(LocatorUtils.property(locator, "acronym", sourceAcronym), sourceAcronym, this.isSetAcronym()));
                    copy.setAcronym(copyAcronym);
                } else {
                    if (acronymShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.acronym = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new OrganizationType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof OrganizationType) {
            final OrganizationType target = this;
            final OrganizationType leftObject = ((OrganizationType) left);
            final OrganizationType rightObject = ((OrganizationType) right);
            {
                Boolean nameShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetName(), rightObject.isSetName());
                if (nameShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsName;
                    lhsName = (leftObject.isSetName()?leftObject.getName():null);
                    List<String> rhsName;
                    rhsName = (rightObject.isSetName()?rightObject.getName():null);
                    List<String> mergedName = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "name", lhsName), LocatorUtils.property(rightLocator, "name", rhsName), lhsName, rhsName, leftObject.isSetName(), rightObject.isSetName()));
                    target.unsetName();
                    if (mergedName!= null) {
                        List<String> uniqueNamel = target.getName();
                        uniqueNamel.addAll(mergedName);
                    }
                } else {
                    if (nameShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetName();
                    }
                }
            }
            {
                Boolean phoneShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPhone(), rightObject.isSetPhone());
                if (phoneShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsPhone;
                    lhsPhone = (leftObject.isSetPhone()?leftObject.getPhone():null);
                    List<String> rhsPhone;
                    rhsPhone = (rightObject.isSetPhone()?rightObject.getPhone():null);
                    List<String> mergedPhone = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "phone", lhsPhone), LocatorUtils.property(rightLocator, "phone", rhsPhone), lhsPhone, rhsPhone, leftObject.isSetPhone(), rightObject.isSetPhone()));
                    target.unsetPhone();
                    if (mergedPhone!= null) {
                        List<String> uniquePhonel = target.getPhone();
                        uniquePhonel.addAll(mergedPhone);
                    }
                } else {
                    if (phoneShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetPhone();
                    }
                }
            }
            {
                Boolean emailShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetEmail(), rightObject.isSetEmail());
                if (emailShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsEmail;
                    lhsEmail = (leftObject.isSetEmail()?leftObject.getEmail():null);
                    List<String> rhsEmail;
                    rhsEmail = (rightObject.isSetEmail()?rightObject.getEmail():null);
                    List<String> mergedEmail = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "email", lhsEmail), LocatorUtils.property(rightLocator, "email", rhsEmail), lhsEmail, rhsEmail, leftObject.isSetEmail(), rightObject.isSetEmail()));
                    target.unsetEmail();
                    if (mergedEmail!= null) {
                        List<String> uniqueEmaill = target.getEmail();
                        uniqueEmaill.addAll(mergedEmail);
                    }
                } else {
                    if (emailShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetEmail();
                    }
                }
            }
            {
                Boolean subOrganizationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSubOrganization(), rightObject.isSetSubOrganization());
                if (subOrganizationShouldBeMergedAndSet == Boolean.TRUE) {
                    List<OrganizationType.SubOrganization> lhsSubOrganization;
                    lhsSubOrganization = (leftObject.isSetSubOrganization()?leftObject.getSubOrganization():null);
                    List<OrganizationType.SubOrganization> rhsSubOrganization;
                    rhsSubOrganization = (rightObject.isSetSubOrganization()?rightObject.getSubOrganization():null);
                    List<OrganizationType.SubOrganization> mergedSubOrganization = ((List<OrganizationType.SubOrganization> ) strategy.merge(LocatorUtils.property(leftLocator, "subOrganization", lhsSubOrganization), LocatorUtils.property(rightLocator, "subOrganization", rhsSubOrganization), lhsSubOrganization, rhsSubOrganization, leftObject.isSetSubOrganization(), rightObject.isSetSubOrganization()));
                    target.unsetSubOrganization();
                    if (mergedSubOrganization!= null) {
                        List<OrganizationType.SubOrganization> uniqueSubOrganizationl = target.getSubOrganization();
                        uniqueSubOrganizationl.addAll(mergedSubOrganization);
                    }
                } else {
                    if (subOrganizationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSubOrganization();
                    }
                }
            }
            {
                Boolean acronymShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAcronym(), rightObject.isSetAcronym());
                if (acronymShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsAcronym;
                    lhsAcronym = leftObject.getAcronym();
                    String rhsAcronym;
                    rhsAcronym = rightObject.getAcronym();
                    String mergedAcronym = ((String) strategy.merge(LocatorUtils.property(leftLocator, "acronym", lhsAcronym), LocatorUtils.property(rightLocator, "acronym", rhsAcronym), lhsAcronym, rhsAcronym, leftObject.isSetAcronym(), rightObject.isSetAcronym()));
                    target.setAcronym(mergedAcronym);
                } else {
                    if (acronymShouldBeMergedAndSet == Boolean.FALSE) {
                        target.acronym = null;
                    }
                }
            }
        }
    }

    public void setName(List<String> value) {
        this.name = null;
        if (value!= null) {
            List<String> draftl = this.getName();
            draftl.addAll(value);
        }
    }

    public void setPhone(List<String> value) {
        this.phone = null;
        if (value!= null) {
            List<String> draftl = this.getPhone();
            draftl.addAll(value);
        }
    }

    public void setEmail(List<String> value) {
        this.email = null;
        if (value!= null) {
            List<String> draftl = this.getEmail();
            draftl.addAll(value);
        }
    }

    public void setSubOrganization(List<OrganizationType.SubOrganization> value) {
        this.subOrganization = null;
        if (value!= null) {
            List<OrganizationType.SubOrganization> draftl = this.getSubOrganization();
            draftl.addAll(value);
        }
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;simpleContent&gt;
     *     &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;simpleTokenType"&gt;
     *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
     *     &lt;/extension&gt;
     *   &lt;/simpleContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class SubOrganization implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlValue
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        protected String value;
        @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism", required = true)
        protected CVEnumISMClassificationAll classification;
        @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism", required = true)
        protected List<String> ownerProducer;
        @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
        protected Boolean joint;
        @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMSCIControlsValues> scIcontrols;
        @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
        protected List<String> sarIdentifier;
        @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
        protected List<String> atomicEnergyMarkings;
        @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMDissemValues> disseminationControls;
        @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> displayOnlyTo;
        @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceOpen;
        @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceProtected;
        @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> releasableTo;
        @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonICValues> nonICmarkings;
        @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
        protected String classifiedBy;
        @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
        protected String compilationReason;
        @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
        protected String derivativelyClassifiedBy;
        @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
        protected String classificationReason;
        @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonUSControlsValues> nonUSControls;
        @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
        protected String derivedFrom;
        @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
        protected XMLGregorianCalendar declassDate;
        @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
        protected String declassEvent;
        @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
        protected CVEnumISM25X declassException;

        /**
         * type created to ensure an element / attribute is comprised of more than whitespace, tab, newline, etc.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        public boolean isSetValue() {
            return (this.value!= null);
        }

        /**
         * Gets the value of the classification property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public CVEnumISMClassificationAll getClassification() {
            return classification;
        }

        /**
         * Sets the value of the classification property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public void setClassification(CVEnumISMClassificationAll value) {
            this.classification = value;
        }

        public boolean isSetClassification() {
            return (this.classification!= null);
        }

        /**
         * Gets the value of the ownerProducer property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getOwnerProducer().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getOwnerProducer() {
            if (ownerProducer == null) {
                ownerProducer = new ArrayList<String>();
            }
            return this.ownerProducer;
        }

        public boolean isSetOwnerProducer() {
            return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
        }

        public void unsetOwnerProducer() {
            this.ownerProducer = null;
        }

        /**
         * Gets the value of the joint property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean getJoint() {
            return joint;
        }

        /**
         * Sets the value of the joint property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setJoint(boolean value) {
            this.joint = value;
        }

        public boolean isSetJoint() {
            return (this.joint!= null);
        }

        public void unsetJoint() {
            this.joint = null;
        }

        /**
         * Gets the value of the scIcontrols property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSCIcontrols().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMSCIControlsValues }
         * 
         * 
         */
        public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
            if (scIcontrols == null) {
                scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
            }
            return this.scIcontrols;
        }

        public boolean isSetSCIcontrols() {
            return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
        }

        public void unsetSCIcontrols() {
            this.scIcontrols = null;
        }

        /**
         * Gets the value of the sarIdentifier property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSARIdentifier().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getSARIdentifier() {
            if (sarIdentifier == null) {
                sarIdentifier = new ArrayList<String>();
            }
            return this.sarIdentifier;
        }

        public boolean isSetSARIdentifier() {
            return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
        }

        public void unsetSARIdentifier() {
            this.sarIdentifier = null;
        }

        /**
         * Gets the value of the atomicEnergyMarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAtomicEnergyMarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getAtomicEnergyMarkings() {
            if (atomicEnergyMarkings == null) {
                atomicEnergyMarkings = new ArrayList<String>();
            }
            return this.atomicEnergyMarkings;
        }

        public boolean isSetAtomicEnergyMarkings() {
            return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
        }

        public void unsetAtomicEnergyMarkings() {
            this.atomicEnergyMarkings = null;
        }

        /**
         * Gets the value of the disseminationControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisseminationControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMDissemValues }
         * 
         * 
         */
        public List<CVEnumISMDissemValues> getDisseminationControls() {
            if (disseminationControls == null) {
                disseminationControls = new ArrayList<CVEnumISMDissemValues>();
            }
            return this.disseminationControls;
        }

        public boolean isSetDisseminationControls() {
            return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
        }

        public void unsetDisseminationControls() {
            this.disseminationControls = null;
        }

        /**
         * Gets the value of the displayOnlyTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisplayOnlyTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getDisplayOnlyTo() {
            if (displayOnlyTo == null) {
                displayOnlyTo = new ArrayList<String>();
            }
            return this.displayOnlyTo;
        }

        public boolean isSetDisplayOnlyTo() {
            return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
        }

        public void unsetDisplayOnlyTo() {
            this.displayOnlyTo = null;
        }

        /**
         * Gets the value of the fgIsourceOpen property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceOpen().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceOpen() {
            if (fgIsourceOpen == null) {
                fgIsourceOpen = new ArrayList<String>();
            }
            return this.fgIsourceOpen;
        }

        public boolean isSetFGIsourceOpen() {
            return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
        }

        public void unsetFGIsourceOpen() {
            this.fgIsourceOpen = null;
        }

        /**
         * Gets the value of the fgIsourceProtected property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceProtected().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceProtected() {
            if (fgIsourceProtected == null) {
                fgIsourceProtected = new ArrayList<String>();
            }
            return this.fgIsourceProtected;
        }

        public boolean isSetFGIsourceProtected() {
            return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
        }

        public void unsetFGIsourceProtected() {
            this.fgIsourceProtected = null;
        }

        /**
         * Gets the value of the releasableTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getReleasableTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getReleasableTo() {
            if (releasableTo == null) {
                releasableTo = new ArrayList<String>();
            }
            return this.releasableTo;
        }

        public boolean isSetReleasableTo() {
            return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
        }

        public void unsetReleasableTo() {
            this.releasableTo = null;
        }

        /**
         * Gets the value of the nonICmarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonICmarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonICValues }
         * 
         * 
         */
        public List<CVEnumISMNonICValues> getNonICmarkings() {
            if (nonICmarkings == null) {
                nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
            }
            return this.nonICmarkings;
        }

        public boolean isSetNonICmarkings() {
            return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
        }

        public void unsetNonICmarkings() {
            this.nonICmarkings = null;
        }

        /**
         * Gets the value of the classifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassifiedBy() {
            return classifiedBy;
        }

        /**
         * Sets the value of the classifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassifiedBy(String value) {
            this.classifiedBy = value;
        }

        public boolean isSetClassifiedBy() {
            return (this.classifiedBy!= null);
        }

        /**
         * Gets the value of the compilationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getCompilationReason() {
            return compilationReason;
        }

        /**
         * Sets the value of the compilationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setCompilationReason(String value) {
            this.compilationReason = value;
        }

        public boolean isSetCompilationReason() {
            return (this.compilationReason!= null);
        }

        /**
         * Gets the value of the derivativelyClassifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivativelyClassifiedBy() {
            return derivativelyClassifiedBy;
        }

        /**
         * Sets the value of the derivativelyClassifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivativelyClassifiedBy(String value) {
            this.derivativelyClassifiedBy = value;
        }

        public boolean isSetDerivativelyClassifiedBy() {
            return (this.derivativelyClassifiedBy!= null);
        }

        /**
         * Gets the value of the classificationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassificationReason() {
            return classificationReason;
        }

        /**
         * Sets the value of the classificationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassificationReason(String value) {
            this.classificationReason = value;
        }

        public boolean isSetClassificationReason() {
            return (this.classificationReason!= null);
        }

        /**
         * Gets the value of the nonUSControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonUSControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonUSControlsValues }
         * 
         * 
         */
        public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
            if (nonUSControls == null) {
                nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
            }
            return this.nonUSControls;
        }

        public boolean isSetNonUSControls() {
            return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
        }

        public void unsetNonUSControls() {
            this.nonUSControls = null;
        }

        /**
         * Gets the value of the derivedFrom property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivedFrom() {
            return derivedFrom;
        }

        /**
         * Sets the value of the derivedFrom property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivedFrom(String value) {
            this.derivedFrom = value;
        }

        public boolean isSetDerivedFrom() {
            return (this.derivedFrom!= null);
        }

        /**
         * Gets the value of the declassDate property.
         * 
         * @return
         *     possible object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public XMLGregorianCalendar getDeclassDate() {
            return declassDate;
        }

        /**
         * Sets the value of the declassDate property.
         * 
         * @param value
         *     allowed object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public void setDeclassDate(XMLGregorianCalendar value) {
            this.declassDate = value;
        }

        public boolean isSetDeclassDate() {
            return (this.declassDate!= null);
        }

        /**
         * Gets the value of the declassEvent property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDeclassEvent() {
            return declassEvent;
        }

        /**
         * Sets the value of the declassEvent property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDeclassEvent(String value) {
            this.declassEvent = value;
        }

        public boolean isSetDeclassEvent() {
            return (this.declassEvent!= null);
        }

        /**
         * Gets the value of the declassException property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISM25X }
         *     
         */
        public CVEnumISM25X getDeclassException() {
            return declassException;
        }

        /**
         * Sets the value of the declassException property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISM25X }
         *     
         */
        public void setDeclassException(CVEnumISM25X value) {
            this.declassException = value;
        }

        public boolean isSetDeclassException() {
            return (this.declassException!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                String theValue;
                theValue = this.getValue();
                strategy.appendField(locator, this, "value", buffer, theValue, this.isSetValue());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final OrganizationType.SubOrganization that = ((OrganizationType.SubOrganization) object);
            {
                String lhsValue;
                lhsValue = this.getValue();
                String rhsValue;
                rhsValue = that.getValue();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "value", lhsValue), LocatorUtils.property(thatLocator, "value", rhsValue), lhsValue, rhsValue, this.isSetValue(), that.isSetValue())) {
                    return false;
                }
            }
            {
                CVEnumISMClassificationAll lhsClassification;
                lhsClassification = this.getClassification();
                CVEnumISMClassificationAll rhsClassification;
                rhsClassification = that.getClassification();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                    return false;
                }
            }
            {
                List<String> lhsOwnerProducer;
                lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                List<String> rhsOwnerProducer;
                rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                    return false;
                }
            }
            {
                boolean lhsJoint;
                lhsJoint = (this.isSetJoint()?this.getJoint():false);
                boolean rhsJoint;
                rhsJoint = (that.isSetJoint()?that.getJoint():false);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                    return false;
                }
            }
            {
                List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                    return false;
                }
            }
            {
                List<String> lhsSARIdentifier;
                lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                List<String> rhsSARIdentifier;
                rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                    return false;
                }
            }
            {
                List<String> lhsAtomicEnergyMarkings;
                lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                List<String> rhsAtomicEnergyMarkings;
                rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                    return false;
                }
            }
            {
                List<CVEnumISMDissemValues> lhsDisseminationControls;
                lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                List<CVEnumISMDissemValues> rhsDisseminationControls;
                rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                    return false;
                }
            }
            {
                List<String> lhsDisplayOnlyTo;
                lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                List<String> rhsDisplayOnlyTo;
                rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceOpen;
                lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                List<String> rhsFGIsourceOpen;
                rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceProtected;
                lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                List<String> rhsFGIsourceProtected;
                rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                    return false;
                }
            }
            {
                List<String> lhsReleasableTo;
                lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                List<String> rhsReleasableTo;
                rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonICValues> lhsNonICmarkings;
                lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                List<CVEnumISMNonICValues> rhsNonICmarkings;
                rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                    return false;
                }
            }
            {
                String lhsClassifiedBy;
                lhsClassifiedBy = this.getClassifiedBy();
                String rhsClassifiedBy;
                rhsClassifiedBy = that.getClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsCompilationReason;
                lhsCompilationReason = this.getCompilationReason();
                String rhsCompilationReason;
                rhsCompilationReason = that.getCompilationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                    return false;
                }
            }
            {
                String lhsDerivativelyClassifiedBy;
                lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                String rhsDerivativelyClassifiedBy;
                rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsClassificationReason;
                lhsClassificationReason = this.getClassificationReason();
                String rhsClassificationReason;
                rhsClassificationReason = that.getClassificationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                    return false;
                }
            }
            {
                String lhsDerivedFrom;
                lhsDerivedFrom = this.getDerivedFrom();
                String rhsDerivedFrom;
                rhsDerivedFrom = that.getDerivedFrom();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                    return false;
                }
            }
            {
                XMLGregorianCalendar lhsDeclassDate;
                lhsDeclassDate = this.getDeclassDate();
                XMLGregorianCalendar rhsDeclassDate;
                rhsDeclassDate = that.getDeclassDate();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                    return false;
                }
            }
            {
                String lhsDeclassEvent;
                lhsDeclassEvent = this.getDeclassEvent();
                String rhsDeclassEvent;
                rhsDeclassEvent = that.getDeclassEvent();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                    return false;
                }
            }
            {
                CVEnumISM25X lhsDeclassException;
                lhsDeclassException = this.getDeclassException();
                CVEnumISM25X rhsDeclassException;
                rhsDeclassException = that.getDeclassException();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                String theValue;
                theValue = this.getValue();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "value", theValue), currentHashCode, theValue, this.isSetValue());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof OrganizationType.SubOrganization) {
                final OrganizationType.SubOrganization copy = ((OrganizationType.SubOrganization) draftCopy);
                {
                    Boolean valueShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetValue());
                    if (valueShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceValue;
                        sourceValue = this.getValue();
                        String copyValue = ((String) strategy.copy(LocatorUtils.property(locator, "value", sourceValue), sourceValue, this.isSetValue()));
                        copy.setValue(copyValue);
                    } else {
                        if (valueShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.value = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                    if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll sourceClassification;
                        sourceClassification = this.getClassification();
                        CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                        copy.setClassification(copyClassification);
                    } else {
                        if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceOwnerProducer;
                        sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                        copy.unsetOwnerProducer();
                        if (copyOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(copyOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                    if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                        boolean sourceJoint;
                        sourceJoint = (this.isSetJoint()?this.getJoint():false);
                        boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                        copy.setJoint(copyJoint);
                    } else {
                        if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                        sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                        copy.unsetSCIcontrols();
                        if (copySCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(copySCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceSARIdentifier;
                        sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                        @SuppressWarnings("unchecked")
                        List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                        copy.unsetSARIdentifier();
                        if (copySARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(copySARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceAtomicEnergyMarkings;
                        sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                        copy.unsetAtomicEnergyMarkings();
                        if (copyAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> sourceDisseminationControls;
                        sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                        copy.unsetDisseminationControls();
                        if (copyDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceDisplayOnlyTo;
                        sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                        copy.unsetDisplayOnlyTo();
                        if (copyDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceOpen;
                        sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                        copy.unsetFGIsourceOpen();
                        if (copyFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceProtected;
                        sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                        copy.unsetFGIsourceProtected();
                        if (copyFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                    if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceReleasableTo;
                        sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                        copy.unsetReleasableTo();
                        if (copyReleasableTo!= null) {
                            List<String> uniqueReleasableTol = copy.getReleasableTo();
                            uniqueReleasableTol.addAll(copyReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> sourceNonICmarkings;
                        sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                        copy.unsetNonICmarkings();
                        if (copyNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                    if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassifiedBy;
                        sourceClassifiedBy = this.getClassifiedBy();
                        String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                        copy.setClassifiedBy(copyClassifiedBy);
                    } else {
                        if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceCompilationReason;
                        sourceCompilationReason = this.getCompilationReason();
                        String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                        copy.setCompilationReason(copyCompilationReason);
                    } else {
                        if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivativelyClassifiedBy;
                        sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                        String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                        copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassificationReason;
                        sourceClassificationReason = this.getClassificationReason();
                        String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                        copy.setClassificationReason(copyClassificationReason);
                    } else {
                        if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                        sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                        copy.unsetNonUSControls();
                        if (copyNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                            uniqueNonUSControlsl.addAll(copyNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                    if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivedFrom;
                        sourceDerivedFrom = this.getDerivedFrom();
                        String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                        copy.setDerivedFrom(copyDerivedFrom);
                    } else {
                        if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                    if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar sourceDeclassDate;
                        sourceDeclassDate = this.getDeclassDate();
                        XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                        copy.setDeclassDate(copyDeclassDate);
                    } else {
                        if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                    if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDeclassEvent;
                        sourceDeclassEvent = this.getDeclassEvent();
                        String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                        copy.setDeclassEvent(copyDeclassEvent);
                    } else {
                        if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISM25X sourceDeclassException;
                        sourceDeclassException = this.getDeclassException();
                        CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                        copy.setDeclassException(copyDeclassException);
                    } else {
                        if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassException = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new OrganizationType.SubOrganization();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof OrganizationType.SubOrganization) {
                final OrganizationType.SubOrganization target = this;
                final OrganizationType.SubOrganization leftObject = ((OrganizationType.SubOrganization) left);
                final OrganizationType.SubOrganization rightObject = ((OrganizationType.SubOrganization) right);
                {
                    Boolean valueShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetValue(), rightObject.isSetValue());
                    if (valueShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsValue;
                        lhsValue = leftObject.getValue();
                        String rhsValue;
                        rhsValue = rightObject.getValue();
                        String mergedValue = ((String) strategy.merge(LocatorUtils.property(leftLocator, "value", lhsValue), LocatorUtils.property(rightLocator, "value", rhsValue), lhsValue, rhsValue, leftObject.isSetValue(), rightObject.isSetValue()));
                        target.setValue(mergedValue);
                    } else {
                        if (valueShouldBeMergedAndSet == Boolean.FALSE) {
                            target.value = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                    if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll lhsClassification;
                        lhsClassification = leftObject.getClassification();
                        CVEnumISMClassificationAll rhsClassification;
                        rhsClassification = rightObject.getClassification();
                        CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                        target.setClassification(mergedClassification);
                    } else {
                        if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                    if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsOwnerProducer;
                        lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                        List<String> rhsOwnerProducer;
                        rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                        List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                        target.unsetOwnerProducer();
                        if (mergedOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                    if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                        boolean lhsJoint;
                        lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                        boolean rhsJoint;
                        rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                        boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                        target.setJoint(mergedJoint);
                    } else {
                        if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                        lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                        rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                        target.unsetSCIcontrols();
                        if (mergedSCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsSARIdentifier;
                        lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                        List<String> rhsSARIdentifier;
                        rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                        List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                        target.unsetSARIdentifier();
                        if (mergedSARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsAtomicEnergyMarkings;
                        lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                        List<String> rhsAtomicEnergyMarkings;
                        rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                        List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                        target.unsetAtomicEnergyMarkings();
                        if (mergedAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> lhsDisseminationControls;
                        lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> rhsDisseminationControls;
                        rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                        target.unsetDisseminationControls();
                        if (mergedDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsDisplayOnlyTo;
                        lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                        List<String> rhsDisplayOnlyTo;
                        rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                        List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                        target.unsetDisplayOnlyTo();
                        if (mergedDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceOpen;
                        lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                        List<String> rhsFGIsourceOpen;
                        rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                        List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                        target.unsetFGIsourceOpen();
                        if (mergedFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceProtected;
                        lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                        List<String> rhsFGIsourceProtected;
                        rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                        List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                        target.unsetFGIsourceProtected();
                        if (mergedFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                    if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsReleasableTo;
                        lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                        List<String> rhsReleasableTo;
                        rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                        List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                        target.unsetReleasableTo();
                        if (mergedReleasableTo!= null) {
                            List<String> uniqueReleasableTol = target.getReleasableTo();
                            uniqueReleasableTol.addAll(mergedReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> lhsNonICmarkings;
                        lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> rhsNonICmarkings;
                        rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                        target.unsetNonICmarkings();
                        if (mergedNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                    if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassifiedBy;
                        lhsClassifiedBy = leftObject.getClassifiedBy();
                        String rhsClassifiedBy;
                        rhsClassifiedBy = rightObject.getClassifiedBy();
                        String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                        target.setClassifiedBy(mergedClassifiedBy);
                    } else {
                        if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                    if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsCompilationReason;
                        lhsCompilationReason = leftObject.getCompilationReason();
                        String rhsCompilationReason;
                        rhsCompilationReason = rightObject.getCompilationReason();
                        String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                        target.setCompilationReason(mergedCompilationReason);
                    } else {
                        if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivativelyClassifiedBy;
                        lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                        String rhsDerivativelyClassifiedBy;
                        rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                        String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                        target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                    if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassificationReason;
                        lhsClassificationReason = leftObject.getClassificationReason();
                        String rhsClassificationReason;
                        rhsClassificationReason = rightObject.getClassificationReason();
                        String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                        target.setClassificationReason(mergedClassificationReason);
                    } else {
                        if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                        lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                        rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                        target.unsetNonUSControls();
                        if (mergedNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                            uniqueNonUSControlsl.addAll(mergedNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                    if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivedFrom;
                        lhsDerivedFrom = leftObject.getDerivedFrom();
                        String rhsDerivedFrom;
                        rhsDerivedFrom = rightObject.getDerivedFrom();
                        String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                        target.setDerivedFrom(mergedDerivedFrom);
                    } else {
                        if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                    if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar lhsDeclassDate;
                        lhsDeclassDate = leftObject.getDeclassDate();
                        XMLGregorianCalendar rhsDeclassDate;
                        rhsDeclassDate = rightObject.getDeclassDate();
                        XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                        target.setDeclassDate(mergedDeclassDate);
                    } else {
                        if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                    if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDeclassEvent;
                        lhsDeclassEvent = leftObject.getDeclassEvent();
                        String rhsDeclassEvent;
                        rhsDeclassEvent = rightObject.getDeclassEvent();
                        String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                        target.setDeclassEvent(mergedDeclassEvent);
                    } else {
                        if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                    if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISM25X lhsDeclassException;
                        lhsDeclassException = leftObject.getDeclassException();
                        CVEnumISM25X rhsDeclassException;
                        rhsDeclassException = rightObject.getDeclassException();
                        CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                        target.setDeclassException(mergedDeclassException);
                    } else {
                        if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassException = null;
                        }
                    }
                }
            }
        }

        public void setOwnerProducer(List<String> value) {
            this.ownerProducer = null;
            if (value!= null) {
                List<String> draftl = this.getOwnerProducer();
                draftl.addAll(value);
            }
        }

        public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
            this.scIcontrols = null;
            if (value!= null) {
                List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
                draftl.addAll(value);
            }
        }

        public void setSARIdentifier(List<String> value) {
            this.sarIdentifier = null;
            if (value!= null) {
                List<String> draftl = this.getSARIdentifier();
                draftl.addAll(value);
            }
        }

        public void setAtomicEnergyMarkings(List<String> value) {
            this.atomicEnergyMarkings = null;
            if (value!= null) {
                List<String> draftl = this.getAtomicEnergyMarkings();
                draftl.addAll(value);
            }
        }

        public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
            this.disseminationControls = null;
            if (value!= null) {
                List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
                draftl.addAll(value);
            }
        }

        public void setDisplayOnlyTo(List<String> value) {
            this.displayOnlyTo = null;
            if (value!= null) {
                List<String> draftl = this.getDisplayOnlyTo();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceOpen(List<String> value) {
            this.fgIsourceOpen = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceOpen();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceProtected(List<String> value) {
            this.fgIsourceProtected = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceProtected();
                draftl.addAll(value);
            }
        }

        public void setReleasableTo(List<String> value) {
            this.releasableTo = null;
            if (value!= null) {
                List<String> draftl = this.getReleasableTo();
                draftl.addAll(value);
            }
        }

        public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
            this.nonICmarkings = null;
            if (value!= null) {
                List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
                draftl.addAll(value);
            }
        }

        public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
            this.nonUSControls = null;
            if (value!= null) {
                List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
                draftl.addAll(value);
            }
        }

    }

}
