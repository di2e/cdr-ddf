//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package us.mil.ces.metadata.ddms._5;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.datatype.XMLGregorianCalendar;
import org.hisrc.w3c.xlink.v_1_0.ActuateType;
import org.hisrc.w3c.xlink.v_1_0.ShowType;
import org.hisrc.w3c.xlink.v_1_0.TypeType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import us.gov.ic.cvenum.ism._25x.CVEnumISM25X;
import us.gov.ic.cvenum.ism.classification.all.CVEnumISMClassificationAll;
import us.gov.ic.cvenum.ism.dissem.CVEnumISMDissemValues;
import us.gov.ic.cvenum.ism.nonic.CVEnumISMNonICValues;
import us.gov.ic.cvenum.ism.nonuscontrols.CVEnumISMNonUSControlsValues;
import us.gov.ic.cvenum.ism.scicontrols.CVEnumISMSCIControlsValues;


/**
 * <p>Java class for TaskingInfoType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="TaskingInfoType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="requesterInfo" maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;choice&gt;
 *                   &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}person"/&gt;
 *                   &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}organization"/&gt;
 *                 &lt;/choice&gt;
 *                 &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="addressee" maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;choice&gt;
 *                   &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}person"/&gt;
 *                   &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}organization"/&gt;
 *                 &lt;/choice&gt;
 *                 &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}description" minOccurs="0"/&gt;
 *         &lt;element name="taskID"&gt;
 *           &lt;complexType&gt;
 *             &lt;simpleContent&gt;
 *               &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;simpleTokenType"&gt;
 *                 &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SimpleLinkAttributesGroup"/&gt;
 *                 &lt;attribute name="taskingSystem" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" /&gt;
 *               &lt;/extension&gt;
 *             &lt;/simpleContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *       &lt;/sequence&gt;
 *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "TaskingInfoType", propOrder = {
    "requesterInfo",
    "addressee",
    "description",
    "taskID"
})
public class TaskingInfoType implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @Valid
    protected List<TaskingInfoType.RequesterInfo> requesterInfo;
    @Valid
    protected List<TaskingInfoType.Addressee> addressee;
    @Valid
    protected DescriptionType description;
    @XmlElement(required = true)
    @NotNull(message = "TaskingInfoType.taskID {javax.validation.constraints.NotNull.message}")
    @Valid
    protected TaskingInfoType.TaskID taskID;
    @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism", required = true)
    @NotNull(message = "TaskingInfoType.classification {javax.validation.constraints.NotNull.message}")
    protected CVEnumISMClassificationAll classification;
    @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism", required = true)
    @NotNull(message = "TaskingInfoType.ownerProducer {javax.validation.constraints.NotNull.message}")
    protected List<String> ownerProducer;
    @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
    protected Boolean joint;
    @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMSCIControlsValues> scIcontrols;
    @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
    protected List<String> sarIdentifier;
    @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
    protected List<String> atomicEnergyMarkings;
    @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMDissemValues> disseminationControls;
    @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> displayOnlyTo;
    @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceOpen;
    @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
    protected List<String> fgIsourceProtected;
    @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
    protected List<String> releasableTo;
    @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonICValues> nonICmarkings;
    @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String classifiedBy;
    @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String compilationReason;
    @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivativelyClassifiedBy;
    @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
    @Size(max = 4096)
    protected String classificationReason;
    @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
    protected List<CVEnumISMNonUSControlsValues> nonUSControls;
    @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String derivedFrom;
    @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
    protected XMLGregorianCalendar declassDate;
    @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
    @Size(max = 1024)
    protected String declassEvent;
    @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
    protected CVEnumISM25X declassException;

    /**
     * Gets the value of the requesterInfo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the requesterInfo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRequesterInfo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TaskingInfoType.RequesterInfo }
     * 
     * 
     */
    public List<TaskingInfoType.RequesterInfo> getRequesterInfo() {
        if (requesterInfo == null) {
            requesterInfo = new ArrayList<TaskingInfoType.RequesterInfo>();
        }
        return this.requesterInfo;
    }

    public boolean isSetRequesterInfo() {
        return ((this.requesterInfo!= null)&&(!this.requesterInfo.isEmpty()));
    }

    public void unsetRequesterInfo() {
        this.requesterInfo = null;
    }

    /**
     * Gets the value of the addressee property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the addressee property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAddressee().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TaskingInfoType.Addressee }
     * 
     * 
     */
    public List<TaskingInfoType.Addressee> getAddressee() {
        if (addressee == null) {
            addressee = new ArrayList<TaskingInfoType.Addressee>();
        }
        return this.addressee;
    }

    public boolean isSetAddressee() {
        return ((this.addressee!= null)&&(!this.addressee.isEmpty()));
    }

    public void unsetAddressee() {
        this.addressee = null;
    }

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link DescriptionType }
     *     
     */
    public DescriptionType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link DescriptionType }
     *     
     */
    public void setDescription(DescriptionType value) {
        this.description = value;
    }

    public boolean isSetDescription() {
        return (this.description!= null);
    }

    /**
     * Gets the value of the taskID property.
     * 
     * @return
     *     possible object is
     *     {@link TaskingInfoType.TaskID }
     *     
     */
    public TaskingInfoType.TaskID getTaskID() {
        return taskID;
    }

    /**
     * Sets the value of the taskID property.
     * 
     * @param value
     *     allowed object is
     *     {@link TaskingInfoType.TaskID }
     *     
     */
    public void setTaskID(TaskingInfoType.TaskID value) {
        this.taskID = value;
    }

    public boolean isSetTaskID() {
        return (this.taskID!= null);
    }

    /**
     * Gets the value of the classification property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public CVEnumISMClassificationAll getClassification() {
        return classification;
    }

    /**
     * Sets the value of the classification property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISMClassificationAll }
     *     
     */
    public void setClassification(CVEnumISMClassificationAll value) {
        this.classification = value;
    }

    public boolean isSetClassification() {
        return (this.classification!= null);
    }

    /**
     * Gets the value of the ownerProducer property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOwnerProducer().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getOwnerProducer() {
        if (ownerProducer == null) {
            ownerProducer = new ArrayList<String>();
        }
        return this.ownerProducer;
    }

    public boolean isSetOwnerProducer() {
        return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
    }

    public void unsetOwnerProducer() {
        this.ownerProducer = null;
    }

    /**
     * Gets the value of the joint property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean getJoint() {
        return joint;
    }

    /**
     * Sets the value of the joint property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setJoint(boolean value) {
        this.joint = value;
    }

    public boolean isSetJoint() {
        return (this.joint!= null);
    }

    public void unsetJoint() {
        this.joint = null;
    }

    /**
     * Gets the value of the scIcontrols property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSCIcontrols().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMSCIControlsValues }
     * 
     * 
     */
    public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
        if (scIcontrols == null) {
            scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
        }
        return this.scIcontrols;
    }

    public boolean isSetSCIcontrols() {
        return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
    }

    public void unsetSCIcontrols() {
        this.scIcontrols = null;
    }

    /**
     * Gets the value of the sarIdentifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSARIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSARIdentifier() {
        if (sarIdentifier == null) {
            sarIdentifier = new ArrayList<String>();
        }
        return this.sarIdentifier;
    }

    public boolean isSetSARIdentifier() {
        return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
    }

    public void unsetSARIdentifier() {
        this.sarIdentifier = null;
    }

    /**
     * Gets the value of the atomicEnergyMarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAtomicEnergyMarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getAtomicEnergyMarkings() {
        if (atomicEnergyMarkings == null) {
            atomicEnergyMarkings = new ArrayList<String>();
        }
        return this.atomicEnergyMarkings;
    }

    public boolean isSetAtomicEnergyMarkings() {
        return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
    }

    public void unsetAtomicEnergyMarkings() {
        this.atomicEnergyMarkings = null;
    }

    /**
     * Gets the value of the disseminationControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisseminationControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMDissemValues }
     * 
     * 
     */
    public List<CVEnumISMDissemValues> getDisseminationControls() {
        if (disseminationControls == null) {
            disseminationControls = new ArrayList<CVEnumISMDissemValues>();
        }
        return this.disseminationControls;
    }

    public boolean isSetDisseminationControls() {
        return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
    }

    public void unsetDisseminationControls() {
        this.disseminationControls = null;
    }

    /**
     * Gets the value of the displayOnlyTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisplayOnlyTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getDisplayOnlyTo() {
        if (displayOnlyTo == null) {
            displayOnlyTo = new ArrayList<String>();
        }
        return this.displayOnlyTo;
    }

    public boolean isSetDisplayOnlyTo() {
        return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
    }

    public void unsetDisplayOnlyTo() {
        this.displayOnlyTo = null;
    }

    /**
     * Gets the value of the fgIsourceOpen property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceOpen().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceOpen() {
        if (fgIsourceOpen == null) {
            fgIsourceOpen = new ArrayList<String>();
        }
        return this.fgIsourceOpen;
    }

    public boolean isSetFGIsourceOpen() {
        return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
    }

    public void unsetFGIsourceOpen() {
        this.fgIsourceOpen = null;
    }

    /**
     * Gets the value of the fgIsourceProtected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFGIsourceProtected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getFGIsourceProtected() {
        if (fgIsourceProtected == null) {
            fgIsourceProtected = new ArrayList<String>();
        }
        return this.fgIsourceProtected;
    }

    public boolean isSetFGIsourceProtected() {
        return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
    }

    public void unsetFGIsourceProtected() {
        this.fgIsourceProtected = null;
    }

    /**
     * Gets the value of the releasableTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReleasableTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getReleasableTo() {
        if (releasableTo == null) {
            releasableTo = new ArrayList<String>();
        }
        return this.releasableTo;
    }

    public boolean isSetReleasableTo() {
        return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
    }

    public void unsetReleasableTo() {
        this.releasableTo = null;
    }

    /**
     * Gets the value of the nonICmarkings property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonICmarkings().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonICValues }
     * 
     * 
     */
    public List<CVEnumISMNonICValues> getNonICmarkings() {
        if (nonICmarkings == null) {
            nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
        }
        return this.nonICmarkings;
    }

    public boolean isSetNonICmarkings() {
        return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
    }

    public void unsetNonICmarkings() {
        this.nonICmarkings = null;
    }

    /**
     * Gets the value of the classifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassifiedBy() {
        return classifiedBy;
    }

    /**
     * Sets the value of the classifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassifiedBy(String value) {
        this.classifiedBy = value;
    }

    public boolean isSetClassifiedBy() {
        return (this.classifiedBy!= null);
    }

    /**
     * Gets the value of the compilationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getCompilationReason() {
        return compilationReason;
    }

    /**
     * Sets the value of the compilationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCompilationReason(String value) {
        this.compilationReason = value;
    }

    public boolean isSetCompilationReason() {
        return (this.compilationReason!= null);
    }

    /**
     * Gets the value of the derivativelyClassifiedBy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivativelyClassifiedBy() {
        return derivativelyClassifiedBy;
    }

    /**
     * Sets the value of the derivativelyClassifiedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivativelyClassifiedBy(String value) {
        this.derivativelyClassifiedBy = value;
    }

    public boolean isSetDerivativelyClassifiedBy() {
        return (this.derivativelyClassifiedBy!= null);
    }

    /**
     * Gets the value of the classificationReason property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClassificationReason() {
        return classificationReason;
    }

    /**
     * Sets the value of the classificationReason property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClassificationReason(String value) {
        this.classificationReason = value;
    }

    public boolean isSetClassificationReason() {
        return (this.classificationReason!= null);
    }

    /**
     * Gets the value of the nonUSControls property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNonUSControls().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CVEnumISMNonUSControlsValues }
     * 
     * 
     */
    public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
        if (nonUSControls == null) {
            nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
        }
        return this.nonUSControls;
    }

    public boolean isSetNonUSControls() {
        return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
    }

    public void unsetNonUSControls() {
        this.nonUSControls = null;
    }

    /**
     * Gets the value of the derivedFrom property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDerivedFrom() {
        return derivedFrom;
    }

    /**
     * Sets the value of the derivedFrom property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDerivedFrom(String value) {
        this.derivedFrom = value;
    }

    public boolean isSetDerivedFrom() {
        return (this.derivedFrom!= null);
    }

    /**
     * Gets the value of the declassDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getDeclassDate() {
        return declassDate;
    }

    /**
     * Sets the value of the declassDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setDeclassDate(XMLGregorianCalendar value) {
        this.declassDate = value;
    }

    public boolean isSetDeclassDate() {
        return (this.declassDate!= null);
    }

    /**
     * Gets the value of the declassEvent property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDeclassEvent() {
        return declassEvent;
    }

    /**
     * Sets the value of the declassEvent property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDeclassEvent(String value) {
        this.declassEvent = value;
    }

    public boolean isSetDeclassEvent() {
        return (this.declassEvent!= null);
    }

    /**
     * Gets the value of the declassException property.
     * 
     * @return
     *     possible object is
     *     {@link CVEnumISM25X }
     *     
     */
    public CVEnumISM25X getDeclassException() {
        return declassException;
    }

    /**
     * Sets the value of the declassException property.
     * 
     * @param value
     *     allowed object is
     *     {@link CVEnumISM25X }
     *     
     */
    public void setDeclassException(CVEnumISM25X value) {
        this.declassException = value;
    }

    public boolean isSetDeclassException() {
        return (this.declassException!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            List<TaskingInfoType.RequesterInfo> theRequesterInfo;
            theRequesterInfo = (this.isSetRequesterInfo()?this.getRequesterInfo():null);
            strategy.appendField(locator, this, "requesterInfo", buffer, theRequesterInfo, this.isSetRequesterInfo());
        }
        {
            List<TaskingInfoType.Addressee> theAddressee;
            theAddressee = (this.isSetAddressee()?this.getAddressee():null);
            strategy.appendField(locator, this, "addressee", buffer, theAddressee, this.isSetAddressee());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            strategy.appendField(locator, this, "description", buffer, theDescription, this.isSetDescription());
        }
        {
            TaskingInfoType.TaskID theTaskID;
            theTaskID = this.getTaskID();
            strategy.appendField(locator, this, "taskID", buffer, theTaskID, this.isSetTaskID());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final TaskingInfoType that = ((TaskingInfoType) object);
        {
            List<TaskingInfoType.RequesterInfo> lhsRequesterInfo;
            lhsRequesterInfo = (this.isSetRequesterInfo()?this.getRequesterInfo():null);
            List<TaskingInfoType.RequesterInfo> rhsRequesterInfo;
            rhsRequesterInfo = (that.isSetRequesterInfo()?that.getRequesterInfo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "requesterInfo", lhsRequesterInfo), LocatorUtils.property(thatLocator, "requesterInfo", rhsRequesterInfo), lhsRequesterInfo, rhsRequesterInfo, this.isSetRequesterInfo(), that.isSetRequesterInfo())) {
                return false;
            }
        }
        {
            List<TaskingInfoType.Addressee> lhsAddressee;
            lhsAddressee = (this.isSetAddressee()?this.getAddressee():null);
            List<TaskingInfoType.Addressee> rhsAddressee;
            rhsAddressee = (that.isSetAddressee()?that.getAddressee():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "addressee", lhsAddressee), LocatorUtils.property(thatLocator, "addressee", rhsAddressee), lhsAddressee, rhsAddressee, this.isSetAddressee(), that.isSetAddressee())) {
                return false;
            }
        }
        {
            DescriptionType lhsDescription;
            lhsDescription = this.getDescription();
            DescriptionType rhsDescription;
            rhsDescription = that.getDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "description", lhsDescription), LocatorUtils.property(thatLocator, "description", rhsDescription), lhsDescription, rhsDescription, this.isSetDescription(), that.isSetDescription())) {
                return false;
            }
        }
        {
            TaskingInfoType.TaskID lhsTaskID;
            lhsTaskID = this.getTaskID();
            TaskingInfoType.TaskID rhsTaskID;
            rhsTaskID = that.getTaskID();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "taskID", lhsTaskID), LocatorUtils.property(thatLocator, "taskID", rhsTaskID), lhsTaskID, rhsTaskID, this.isSetTaskID(), that.isSetTaskID())) {
                return false;
            }
        }
        {
            CVEnumISMClassificationAll lhsClassification;
            lhsClassification = this.getClassification();
            CVEnumISMClassificationAll rhsClassification;
            rhsClassification = that.getClassification();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                return false;
            }
        }
        {
            List<String> lhsOwnerProducer;
            lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            List<String> rhsOwnerProducer;
            rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                return false;
            }
        }
        {
            boolean lhsJoint;
            lhsJoint = (this.isSetJoint()?this.getJoint():false);
            boolean rhsJoint;
            rhsJoint = (that.isSetJoint()?that.getJoint():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                return false;
            }
        }
        {
            List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
            lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
            rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                return false;
            }
        }
        {
            List<String> lhsSARIdentifier;
            lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            List<String> rhsSARIdentifier;
            rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                return false;
            }
        }
        {
            List<String> lhsAtomicEnergyMarkings;
            lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            List<String> rhsAtomicEnergyMarkings;
            rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                return false;
            }
        }
        {
            List<CVEnumISMDissemValues> lhsDisseminationControls;
            lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            List<CVEnumISMDissemValues> rhsDisseminationControls;
            rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                return false;
            }
        }
        {
            List<String> lhsDisplayOnlyTo;
            lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            List<String> rhsDisplayOnlyTo;
            rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceOpen;
            lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            List<String> rhsFGIsourceOpen;
            rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                return false;
            }
        }
        {
            List<String> lhsFGIsourceProtected;
            lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            List<String> rhsFGIsourceProtected;
            rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                return false;
            }
        }
        {
            List<String> lhsReleasableTo;
            lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            List<String> rhsReleasableTo;
            rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonICValues> lhsNonICmarkings;
            lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            List<CVEnumISMNonICValues> rhsNonICmarkings;
            rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                return false;
            }
        }
        {
            String lhsClassifiedBy;
            lhsClassifiedBy = this.getClassifiedBy();
            String rhsClassifiedBy;
            rhsClassifiedBy = that.getClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsCompilationReason;
            lhsCompilationReason = this.getCompilationReason();
            String rhsCompilationReason;
            rhsCompilationReason = that.getCompilationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                return false;
            }
        }
        {
            String lhsDerivativelyClassifiedBy;
            lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            String rhsDerivativelyClassifiedBy;
            rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                return false;
            }
        }
        {
            String lhsClassificationReason;
            lhsClassificationReason = this.getClassificationReason();
            String rhsClassificationReason;
            rhsClassificationReason = that.getClassificationReason();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                return false;
            }
        }
        {
            List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
            lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
            rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                return false;
            }
        }
        {
            String lhsDerivedFrom;
            lhsDerivedFrom = this.getDerivedFrom();
            String rhsDerivedFrom;
            rhsDerivedFrom = that.getDerivedFrom();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                return false;
            }
        }
        {
            XMLGregorianCalendar lhsDeclassDate;
            lhsDeclassDate = this.getDeclassDate();
            XMLGregorianCalendar rhsDeclassDate;
            rhsDeclassDate = that.getDeclassDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                return false;
            }
        }
        {
            String lhsDeclassEvent;
            lhsDeclassEvent = this.getDeclassEvent();
            String rhsDeclassEvent;
            rhsDeclassEvent = that.getDeclassEvent();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                return false;
            }
        }
        {
            CVEnumISM25X lhsDeclassException;
            lhsDeclassException = this.getDeclassException();
            CVEnumISM25X rhsDeclassException;
            rhsDeclassException = that.getDeclassException();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = 1;
        {
            List<TaskingInfoType.RequesterInfo> theRequesterInfo;
            theRequesterInfo = (this.isSetRequesterInfo()?this.getRequesterInfo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "requesterInfo", theRequesterInfo), currentHashCode, theRequesterInfo, this.isSetRequesterInfo());
        }
        {
            List<TaskingInfoType.Addressee> theAddressee;
            theAddressee = (this.isSetAddressee()?this.getAddressee():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "addressee", theAddressee), currentHashCode, theAddressee, this.isSetAddressee());
        }
        {
            DescriptionType theDescription;
            theDescription = this.getDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "description", theDescription), currentHashCode, theDescription, this.isSetDescription());
        }
        {
            TaskingInfoType.TaskID theTaskID;
            theTaskID = this.getTaskID();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "taskID", theTaskID), currentHashCode, theTaskID, this.isSetTaskID());
        }
        {
            CVEnumISMClassificationAll theClassification;
            theClassification = this.getClassification();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
        }
        {
            List<String> theOwnerProducer;
            theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
        }
        {
            boolean theJoint;
            theJoint = (this.isSetJoint()?this.getJoint():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
        }
        {
            List<CVEnumISMSCIControlsValues> theSCIcontrols;
            theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
        }
        {
            List<String> theSARIdentifier;
            theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
        }
        {
            List<String> theAtomicEnergyMarkings;
            theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
        }
        {
            List<CVEnumISMDissemValues> theDisseminationControls;
            theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
        }
        {
            List<String> theDisplayOnlyTo;
            theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
        }
        {
            List<String> theFGIsourceOpen;
            theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
        }
        {
            List<String> theFGIsourceProtected;
            theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
        }
        {
            List<String> theReleasableTo;
            theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
        }
        {
            List<CVEnumISMNonICValues> theNonICmarkings;
            theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
        }
        {
            String theClassifiedBy;
            theClassifiedBy = this.getClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
        }
        {
            String theCompilationReason;
            theCompilationReason = this.getCompilationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
        }
        {
            String theDerivativelyClassifiedBy;
            theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
        }
        {
            String theClassificationReason;
            theClassificationReason = this.getClassificationReason();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
        }
        {
            List<CVEnumISMNonUSControlsValues> theNonUSControls;
            theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
        }
        {
            String theDerivedFrom;
            theDerivedFrom = this.getDerivedFrom();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
        }
        {
            XMLGregorianCalendar theDeclassDate;
            theDeclassDate = this.getDeclassDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
        }
        {
            String theDeclassEvent;
            theDeclassEvent = this.getDeclassEvent();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
        }
        {
            CVEnumISM25X theDeclassException;
            theDeclassException = this.getDeclassException();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof TaskingInfoType) {
            final TaskingInfoType copy = ((TaskingInfoType) draftCopy);
            {
                Boolean requesterInfoShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRequesterInfo());
                if (requesterInfoShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<TaskingInfoType.RequesterInfo> sourceRequesterInfo;
                    sourceRequesterInfo = (this.isSetRequesterInfo()?this.getRequesterInfo():null);
                    @SuppressWarnings("unchecked")
                    List<TaskingInfoType.RequesterInfo> copyRequesterInfo = ((List<TaskingInfoType.RequesterInfo> ) strategy.copy(LocatorUtils.property(locator, "requesterInfo", sourceRequesterInfo), sourceRequesterInfo, this.isSetRequesterInfo()));
                    copy.unsetRequesterInfo();
                    if (copyRequesterInfo!= null) {
                        List<TaskingInfoType.RequesterInfo> uniqueRequesterInfol = copy.getRequesterInfo();
                        uniqueRequesterInfol.addAll(copyRequesterInfo);
                    }
                } else {
                    if (requesterInfoShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetRequesterInfo();
                    }
                }
            }
            {
                Boolean addresseeShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAddressee());
                if (addresseeShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<TaskingInfoType.Addressee> sourceAddressee;
                    sourceAddressee = (this.isSetAddressee()?this.getAddressee():null);
                    @SuppressWarnings("unchecked")
                    List<TaskingInfoType.Addressee> copyAddressee = ((List<TaskingInfoType.Addressee> ) strategy.copy(LocatorUtils.property(locator, "addressee", sourceAddressee), sourceAddressee, this.isSetAddressee()));
                    copy.unsetAddressee();
                    if (copyAddressee!= null) {
                        List<TaskingInfoType.Addressee> uniqueAddresseel = copy.getAddressee();
                        uniqueAddresseel.addAll(copyAddressee);
                    }
                } else {
                    if (addresseeShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetAddressee();
                    }
                }
            }
            {
                Boolean descriptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDescription());
                if (descriptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    DescriptionType sourceDescription;
                    sourceDescription = this.getDescription();
                    DescriptionType copyDescription = ((DescriptionType) strategy.copy(LocatorUtils.property(locator, "description", sourceDescription), sourceDescription, this.isSetDescription()));
                    copy.setDescription(copyDescription);
                } else {
                    if (descriptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.description = null;
                    }
                }
            }
            {
                Boolean taskIDShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTaskID());
                if (taskIDShouldBeCopiedAndSet == Boolean.TRUE) {
                    TaskingInfoType.TaskID sourceTaskID;
                    sourceTaskID = this.getTaskID();
                    TaskingInfoType.TaskID copyTaskID = ((TaskingInfoType.TaskID) strategy.copy(LocatorUtils.property(locator, "taskID", sourceTaskID), sourceTaskID, this.isSetTaskID()));
                    copy.setTaskID(copyTaskID);
                } else {
                    if (taskIDShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.taskID = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll sourceClassification;
                    sourceClassification = this.getClassification();
                    CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                    copy.setClassification(copyClassification);
                } else {
                    if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceOwnerProducer;
                    sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                    copy.unsetOwnerProducer();
                    if (copyOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(copyOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                    boolean sourceJoint;
                    sourceJoint = (this.isSetJoint()?this.getJoint():false);
                    boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                    copy.setJoint(copyJoint);
                } else {
                    if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                    sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                    copy.unsetSCIcontrols();
                    if (copySCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(copySCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceSARIdentifier;
                    sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                    @SuppressWarnings("unchecked")
                    List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                    copy.unsetSARIdentifier();
                    if (copySARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(copySARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceAtomicEnergyMarkings;
                    sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                    copy.unsetAtomicEnergyMarkings();
                    if (copyAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> sourceDisseminationControls;
                    sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                    copy.unsetDisseminationControls();
                    if (copyDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceDisplayOnlyTo;
                    sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                    copy.unsetDisplayOnlyTo();
                    if (copyDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceOpen;
                    sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                    copy.unsetFGIsourceOpen();
                    if (copyFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceFGIsourceProtected;
                    sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                    copy.unsetFGIsourceProtected();
                    if (copyFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<String> sourceReleasableTo;
                    sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                    @SuppressWarnings("unchecked")
                    List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                    copy.unsetReleasableTo();
                    if (copyReleasableTo!= null) {
                        List<String> uniqueReleasableTol = copy.getReleasableTo();
                        uniqueReleasableTol.addAll(copyReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> sourceNonICmarkings;
                    sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                    copy.unsetNonICmarkings();
                    if (copyNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassifiedBy;
                    sourceClassifiedBy = this.getClassifiedBy();
                    String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                    copy.setClassifiedBy(copyClassifiedBy);
                } else {
                    if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceCompilationReason;
                    sourceCompilationReason = this.getCompilationReason();
                    String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                    copy.setCompilationReason(copyCompilationReason);
                } else {
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivativelyClassifiedBy;
                    sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                    String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                    copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceClassificationReason;
                    sourceClassificationReason = this.getClassificationReason();
                    String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                    copy.setClassificationReason(copyClassificationReason);
                } else {
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                    sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                    @SuppressWarnings("unchecked")
                    List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                    copy.unsetNonUSControls();
                    if (copyNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                        uniqueNonUSControlsl.addAll(copyNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDerivedFrom;
                    sourceDerivedFrom = this.getDerivedFrom();
                    String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                    copy.setDerivedFrom(copyDerivedFrom);
                } else {
                    if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar sourceDeclassDate;
                    sourceDeclassDate = this.getDeclassDate();
                    XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                    copy.setDeclassDate(copyDeclassDate);
                } else {
                    if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                    String sourceDeclassEvent;
                    sourceDeclassEvent = this.getDeclassEvent();
                    String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                    copy.setDeclassEvent(copyDeclassEvent);
                } else {
                    if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                    CVEnumISM25X sourceDeclassException;
                    sourceDeclassException = this.getDeclassException();
                    CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                    copy.setDeclassException(copyDeclassException);
                } else {
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.declassException = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new TaskingInfoType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        if (right instanceof TaskingInfoType) {
            final TaskingInfoType target = this;
            final TaskingInfoType leftObject = ((TaskingInfoType) left);
            final TaskingInfoType rightObject = ((TaskingInfoType) right);
            {
                Boolean requesterInfoShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRequesterInfo(), rightObject.isSetRequesterInfo());
                if (requesterInfoShouldBeMergedAndSet == Boolean.TRUE) {
                    List<TaskingInfoType.RequesterInfo> lhsRequesterInfo;
                    lhsRequesterInfo = (leftObject.isSetRequesterInfo()?leftObject.getRequesterInfo():null);
                    List<TaskingInfoType.RequesterInfo> rhsRequesterInfo;
                    rhsRequesterInfo = (rightObject.isSetRequesterInfo()?rightObject.getRequesterInfo():null);
                    List<TaskingInfoType.RequesterInfo> mergedRequesterInfo = ((List<TaskingInfoType.RequesterInfo> ) strategy.merge(LocatorUtils.property(leftLocator, "requesterInfo", lhsRequesterInfo), LocatorUtils.property(rightLocator, "requesterInfo", rhsRequesterInfo), lhsRequesterInfo, rhsRequesterInfo, leftObject.isSetRequesterInfo(), rightObject.isSetRequesterInfo()));
                    target.unsetRequesterInfo();
                    if (mergedRequesterInfo!= null) {
                        List<TaskingInfoType.RequesterInfo> uniqueRequesterInfol = target.getRequesterInfo();
                        uniqueRequesterInfol.addAll(mergedRequesterInfo);
                    }
                } else {
                    if (requesterInfoShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetRequesterInfo();
                    }
                }
            }
            {
                Boolean addresseeShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAddressee(), rightObject.isSetAddressee());
                if (addresseeShouldBeMergedAndSet == Boolean.TRUE) {
                    List<TaskingInfoType.Addressee> lhsAddressee;
                    lhsAddressee = (leftObject.isSetAddressee()?leftObject.getAddressee():null);
                    List<TaskingInfoType.Addressee> rhsAddressee;
                    rhsAddressee = (rightObject.isSetAddressee()?rightObject.getAddressee():null);
                    List<TaskingInfoType.Addressee> mergedAddressee = ((List<TaskingInfoType.Addressee> ) strategy.merge(LocatorUtils.property(leftLocator, "addressee", lhsAddressee), LocatorUtils.property(rightLocator, "addressee", rhsAddressee), lhsAddressee, rhsAddressee, leftObject.isSetAddressee(), rightObject.isSetAddressee()));
                    target.unsetAddressee();
                    if (mergedAddressee!= null) {
                        List<TaskingInfoType.Addressee> uniqueAddresseel = target.getAddressee();
                        uniqueAddresseel.addAll(mergedAddressee);
                    }
                } else {
                    if (addresseeShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetAddressee();
                    }
                }
            }
            {
                Boolean descriptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDescription(), rightObject.isSetDescription());
                if (descriptionShouldBeMergedAndSet == Boolean.TRUE) {
                    DescriptionType lhsDescription;
                    lhsDescription = leftObject.getDescription();
                    DescriptionType rhsDescription;
                    rhsDescription = rightObject.getDescription();
                    DescriptionType mergedDescription = ((DescriptionType) strategy.merge(LocatorUtils.property(leftLocator, "description", lhsDescription), LocatorUtils.property(rightLocator, "description", rhsDescription), lhsDescription, rhsDescription, leftObject.isSetDescription(), rightObject.isSetDescription()));
                    target.setDescription(mergedDescription);
                } else {
                    if (descriptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.description = null;
                    }
                }
            }
            {
                Boolean taskIDShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTaskID(), rightObject.isSetTaskID());
                if (taskIDShouldBeMergedAndSet == Boolean.TRUE) {
                    TaskingInfoType.TaskID lhsTaskID;
                    lhsTaskID = leftObject.getTaskID();
                    TaskingInfoType.TaskID rhsTaskID;
                    rhsTaskID = rightObject.getTaskID();
                    TaskingInfoType.TaskID mergedTaskID = ((TaskingInfoType.TaskID) strategy.merge(LocatorUtils.property(leftLocator, "taskID", lhsTaskID), LocatorUtils.property(rightLocator, "taskID", rhsTaskID), lhsTaskID, rhsTaskID, leftObject.isSetTaskID(), rightObject.isSetTaskID()));
                    target.setTaskID(mergedTaskID);
                } else {
                    if (taskIDShouldBeMergedAndSet == Boolean.FALSE) {
                        target.taskID = null;
                    }
                }
            }
            {
                Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISMClassificationAll lhsClassification;
                    lhsClassification = leftObject.getClassification();
                    CVEnumISMClassificationAll rhsClassification;
                    rhsClassification = rightObject.getClassification();
                    CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                    target.setClassification(mergedClassification);
                } else {
                    if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classification = null;
                    }
                }
            }
            {
                Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsOwnerProducer;
                    lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                    List<String> rhsOwnerProducer;
                    rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                    List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                    target.unsetOwnerProducer();
                    if (mergedOwnerProducer!= null) {
                        List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                        uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                    }
                } else {
                    if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetOwnerProducer();
                    }
                }
            }
            {
                Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                    boolean lhsJoint;
                    lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                    boolean rhsJoint;
                    rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                    boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                    target.setJoint(mergedJoint);
                } else {
                    if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetJoint();
                    }
                }
            }
            {
                Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                    lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                    rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                    List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                    target.unsetSCIcontrols();
                    if (mergedSCIcontrols!= null) {
                        List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                        uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                    }
                } else {
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSCIcontrols();
                    }
                }
            }
            {
                Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsSARIdentifier;
                    lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                    List<String> rhsSARIdentifier;
                    rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                    List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                    target.unsetSARIdentifier();
                    if (mergedSARIdentifier!= null) {
                        List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                        uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                    }
                } else {
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetSARIdentifier();
                    }
                }
            }
            {
                Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsAtomicEnergyMarkings;
                    lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                    List<String> rhsAtomicEnergyMarkings;
                    rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                    List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                    target.unsetAtomicEnergyMarkings();
                    if (mergedAtomicEnergyMarkings!= null) {
                        List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                        uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                    }
                } else {
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetAtomicEnergyMarkings();
                    }
                }
            }
            {
                Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMDissemValues> lhsDisseminationControls;
                    lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> rhsDisseminationControls;
                    rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                    List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                    target.unsetDisseminationControls();
                    if (mergedDisseminationControls!= null) {
                        List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                        uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                    }
                } else {
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisseminationControls();
                    }
                }
            }
            {
                Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsDisplayOnlyTo;
                    lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                    List<String> rhsDisplayOnlyTo;
                    rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                    List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                    target.unsetDisplayOnlyTo();
                    if (mergedDisplayOnlyTo!= null) {
                        List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                        uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                    }
                } else {
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetDisplayOnlyTo();
                    }
                }
            }
            {
                Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceOpen;
                    lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                    List<String> rhsFGIsourceOpen;
                    rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                    List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                    target.unsetFGIsourceOpen();
                    if (mergedFGIsourceOpen!= null) {
                        List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                        uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                    }
                } else {
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceOpen();
                    }
                }
            }
            {
                Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsFGIsourceProtected;
                    lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                    List<String> rhsFGIsourceProtected;
                    rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                    List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                    target.unsetFGIsourceProtected();
                    if (mergedFGIsourceProtected!= null) {
                        List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                        uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                    }
                } else {
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetFGIsourceProtected();
                    }
                }
            }
            {
                Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                    List<String> lhsReleasableTo;
                    lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                    List<String> rhsReleasableTo;
                    rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                    List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                    target.unsetReleasableTo();
                    if (mergedReleasableTo!= null) {
                        List<String> uniqueReleasableTol = target.getReleasableTo();
                        uniqueReleasableTol.addAll(mergedReleasableTo);
                    }
                } else {
                    if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetReleasableTo();
                    }
                }
            }
            {
                Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonICValues> lhsNonICmarkings;
                    lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> rhsNonICmarkings;
                    rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                    List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                    target.unsetNonICmarkings();
                    if (mergedNonICmarkings!= null) {
                        List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                        uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                    }
                } else {
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonICmarkings();
                    }
                }
            }
            {
                Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassifiedBy;
                    lhsClassifiedBy = leftObject.getClassifiedBy();
                    String rhsClassifiedBy;
                    rhsClassifiedBy = rightObject.getClassifiedBy();
                    String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                    target.setClassifiedBy(mergedClassifiedBy);
                } else {
                    if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classifiedBy = null;
                    }
                }
            }
            {
                Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsCompilationReason;
                    lhsCompilationReason = leftObject.getCompilationReason();
                    String rhsCompilationReason;
                    rhsCompilationReason = rightObject.getCompilationReason();
                    String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                    target.setCompilationReason(mergedCompilationReason);
                } else {
                    if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.compilationReason = null;
                    }
                }
            }
            {
                Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivativelyClassifiedBy;
                    lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                    String rhsDerivativelyClassifiedBy;
                    rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                    String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                    target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                } else {
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivativelyClassifiedBy = null;
                    }
                }
            }
            {
                Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsClassificationReason;
                    lhsClassificationReason = leftObject.getClassificationReason();
                    String rhsClassificationReason;
                    rhsClassificationReason = rightObject.getClassificationReason();
                    String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                    target.setClassificationReason(mergedClassificationReason);
                } else {
                    if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                        target.classificationReason = null;
                    }
                }
            }
            {
                Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                    List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                    lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                    rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                    List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                    target.unsetNonUSControls();
                    if (mergedNonUSControls!= null) {
                        List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                        uniqueNonUSControlsl.addAll(mergedNonUSControls);
                    }
                } else {
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                        target.unsetNonUSControls();
                    }
                }
            }
            {
                Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDerivedFrom;
                    lhsDerivedFrom = leftObject.getDerivedFrom();
                    String rhsDerivedFrom;
                    rhsDerivedFrom = rightObject.getDerivedFrom();
                    String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                    target.setDerivedFrom(mergedDerivedFrom);
                } else {
                    if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                        target.derivedFrom = null;
                    }
                }
            }
            {
                Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                    XMLGregorianCalendar lhsDeclassDate;
                    lhsDeclassDate = leftObject.getDeclassDate();
                    XMLGregorianCalendar rhsDeclassDate;
                    rhsDeclassDate = rightObject.getDeclassDate();
                    XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                    target.setDeclassDate(mergedDeclassDate);
                } else {
                    if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassDate = null;
                    }
                }
            }
            {
                Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                    String lhsDeclassEvent;
                    lhsDeclassEvent = leftObject.getDeclassEvent();
                    String rhsDeclassEvent;
                    rhsDeclassEvent = rightObject.getDeclassEvent();
                    String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                    target.setDeclassEvent(mergedDeclassEvent);
                } else {
                    if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassEvent = null;
                    }
                }
            }
            {
                Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                    CVEnumISM25X lhsDeclassException;
                    lhsDeclassException = leftObject.getDeclassException();
                    CVEnumISM25X rhsDeclassException;
                    rhsDeclassException = rightObject.getDeclassException();
                    CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                    target.setDeclassException(mergedDeclassException);
                } else {
                    if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                        target.declassException = null;
                    }
                }
            }
        }
    }

    public void setRequesterInfo(List<TaskingInfoType.RequesterInfo> value) {
        this.requesterInfo = null;
        if (value!= null) {
            List<TaskingInfoType.RequesterInfo> draftl = this.getRequesterInfo();
            draftl.addAll(value);
        }
    }

    public void setAddressee(List<TaskingInfoType.Addressee> value) {
        this.addressee = null;
        if (value!= null) {
            List<TaskingInfoType.Addressee> draftl = this.getAddressee();
            draftl.addAll(value);
        }
    }

    public void setOwnerProducer(List<String> value) {
        this.ownerProducer = null;
        if (value!= null) {
            List<String> draftl = this.getOwnerProducer();
            draftl.addAll(value);
        }
    }

    public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
        this.scIcontrols = null;
        if (value!= null) {
            List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
            draftl.addAll(value);
        }
    }

    public void setSARIdentifier(List<String> value) {
        this.sarIdentifier = null;
        if (value!= null) {
            List<String> draftl = this.getSARIdentifier();
            draftl.addAll(value);
        }
    }

    public void setAtomicEnergyMarkings(List<String> value) {
        this.atomicEnergyMarkings = null;
        if (value!= null) {
            List<String> draftl = this.getAtomicEnergyMarkings();
            draftl.addAll(value);
        }
    }

    public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
        this.disseminationControls = null;
        if (value!= null) {
            List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
            draftl.addAll(value);
        }
    }

    public void setDisplayOnlyTo(List<String> value) {
        this.displayOnlyTo = null;
        if (value!= null) {
            List<String> draftl = this.getDisplayOnlyTo();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceOpen(List<String> value) {
        this.fgIsourceOpen = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceOpen();
            draftl.addAll(value);
        }
    }

    public void setFGIsourceProtected(List<String> value) {
        this.fgIsourceProtected = null;
        if (value!= null) {
            List<String> draftl = this.getFGIsourceProtected();
            draftl.addAll(value);
        }
    }

    public void setReleasableTo(List<String> value) {
        this.releasableTo = null;
        if (value!= null) {
            List<String> draftl = this.getReleasableTo();
            draftl.addAll(value);
        }
    }

    public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
        this.nonICmarkings = null;
        if (value!= null) {
            List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
            draftl.addAll(value);
        }
    }

    public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
        this.nonUSControls = null;
        if (value!= null) {
            List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
            draftl.addAll(value);
        }
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;choice&gt;
     *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}person"/&gt;
     *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}organization"/&gt;
     *       &lt;/choice&gt;
     *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "person",
        "organization"
    })
    public static class Addressee implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @Valid
        protected PersonType person;
        @Valid
        protected OrganizationType organization;
        @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism", required = true)
        @NotNull(message = "Addressee.classification {javax.validation.constraints.NotNull.message}")
        protected CVEnumISMClassificationAll classification;
        @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism", required = true)
        @NotNull(message = "Addressee.ownerProducer {javax.validation.constraints.NotNull.message}")
        protected List<String> ownerProducer;
        @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
        protected Boolean joint;
        @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMSCIControlsValues> scIcontrols;
        @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
        protected List<String> sarIdentifier;
        @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
        protected List<String> atomicEnergyMarkings;
        @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMDissemValues> disseminationControls;
        @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> displayOnlyTo;
        @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceOpen;
        @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceProtected;
        @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> releasableTo;
        @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonICValues> nonICmarkings;
        @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String classifiedBy;
        @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String compilationReason;
        @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String derivativelyClassifiedBy;
        @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
        @Size(max = 4096)
        protected String classificationReason;
        @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonUSControlsValues> nonUSControls;
        @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String derivedFrom;
        @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
        protected XMLGregorianCalendar declassDate;
        @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String declassEvent;
        @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
        protected CVEnumISM25X declassException;

        /**
         * Gets the value of the person property.
         * 
         * @return
         *     possible object is
         *     {@link PersonType }
         *     
         */
        public PersonType getPerson() {
            return person;
        }

        /**
         * Sets the value of the person property.
         * 
         * @param value
         *     allowed object is
         *     {@link PersonType }
         *     
         */
        public void setPerson(PersonType value) {
            this.person = value;
        }

        public boolean isSetPerson() {
            return (this.person!= null);
        }

        /**
         * Gets the value of the organization property.
         * 
         * @return
         *     possible object is
         *     {@link OrganizationType }
         *     
         */
        public OrganizationType getOrganization() {
            return organization;
        }

        /**
         * Sets the value of the organization property.
         * 
         * @param value
         *     allowed object is
         *     {@link OrganizationType }
         *     
         */
        public void setOrganization(OrganizationType value) {
            this.organization = value;
        }

        public boolean isSetOrganization() {
            return (this.organization!= null);
        }

        /**
         * Gets the value of the classification property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public CVEnumISMClassificationAll getClassification() {
            return classification;
        }

        /**
         * Sets the value of the classification property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public void setClassification(CVEnumISMClassificationAll value) {
            this.classification = value;
        }

        public boolean isSetClassification() {
            return (this.classification!= null);
        }

        /**
         * Gets the value of the ownerProducer property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getOwnerProducer().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getOwnerProducer() {
            if (ownerProducer == null) {
                ownerProducer = new ArrayList<String>();
            }
            return this.ownerProducer;
        }

        public boolean isSetOwnerProducer() {
            return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
        }

        public void unsetOwnerProducer() {
            this.ownerProducer = null;
        }

        /**
         * Gets the value of the joint property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean getJoint() {
            return joint;
        }

        /**
         * Sets the value of the joint property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setJoint(boolean value) {
            this.joint = value;
        }

        public boolean isSetJoint() {
            return (this.joint!= null);
        }

        public void unsetJoint() {
            this.joint = null;
        }

        /**
         * Gets the value of the scIcontrols property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSCIcontrols().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMSCIControlsValues }
         * 
         * 
         */
        public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
            if (scIcontrols == null) {
                scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
            }
            return this.scIcontrols;
        }

        public boolean isSetSCIcontrols() {
            return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
        }

        public void unsetSCIcontrols() {
            this.scIcontrols = null;
        }

        /**
         * Gets the value of the sarIdentifier property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSARIdentifier().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getSARIdentifier() {
            if (sarIdentifier == null) {
                sarIdentifier = new ArrayList<String>();
            }
            return this.sarIdentifier;
        }

        public boolean isSetSARIdentifier() {
            return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
        }

        public void unsetSARIdentifier() {
            this.sarIdentifier = null;
        }

        /**
         * Gets the value of the atomicEnergyMarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAtomicEnergyMarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getAtomicEnergyMarkings() {
            if (atomicEnergyMarkings == null) {
                atomicEnergyMarkings = new ArrayList<String>();
            }
            return this.atomicEnergyMarkings;
        }

        public boolean isSetAtomicEnergyMarkings() {
            return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
        }

        public void unsetAtomicEnergyMarkings() {
            this.atomicEnergyMarkings = null;
        }

        /**
         * Gets the value of the disseminationControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisseminationControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMDissemValues }
         * 
         * 
         */
        public List<CVEnumISMDissemValues> getDisseminationControls() {
            if (disseminationControls == null) {
                disseminationControls = new ArrayList<CVEnumISMDissemValues>();
            }
            return this.disseminationControls;
        }

        public boolean isSetDisseminationControls() {
            return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
        }

        public void unsetDisseminationControls() {
            this.disseminationControls = null;
        }

        /**
         * Gets the value of the displayOnlyTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisplayOnlyTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getDisplayOnlyTo() {
            if (displayOnlyTo == null) {
                displayOnlyTo = new ArrayList<String>();
            }
            return this.displayOnlyTo;
        }

        public boolean isSetDisplayOnlyTo() {
            return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
        }

        public void unsetDisplayOnlyTo() {
            this.displayOnlyTo = null;
        }

        /**
         * Gets the value of the fgIsourceOpen property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceOpen().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceOpen() {
            if (fgIsourceOpen == null) {
                fgIsourceOpen = new ArrayList<String>();
            }
            return this.fgIsourceOpen;
        }

        public boolean isSetFGIsourceOpen() {
            return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
        }

        public void unsetFGIsourceOpen() {
            this.fgIsourceOpen = null;
        }

        /**
         * Gets the value of the fgIsourceProtected property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceProtected().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceProtected() {
            if (fgIsourceProtected == null) {
                fgIsourceProtected = new ArrayList<String>();
            }
            return this.fgIsourceProtected;
        }

        public boolean isSetFGIsourceProtected() {
            return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
        }

        public void unsetFGIsourceProtected() {
            this.fgIsourceProtected = null;
        }

        /**
         * Gets the value of the releasableTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getReleasableTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getReleasableTo() {
            if (releasableTo == null) {
                releasableTo = new ArrayList<String>();
            }
            return this.releasableTo;
        }

        public boolean isSetReleasableTo() {
            return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
        }

        public void unsetReleasableTo() {
            this.releasableTo = null;
        }

        /**
         * Gets the value of the nonICmarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonICmarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonICValues }
         * 
         * 
         */
        public List<CVEnumISMNonICValues> getNonICmarkings() {
            if (nonICmarkings == null) {
                nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
            }
            return this.nonICmarkings;
        }

        public boolean isSetNonICmarkings() {
            return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
        }

        public void unsetNonICmarkings() {
            this.nonICmarkings = null;
        }

        /**
         * Gets the value of the classifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassifiedBy() {
            return classifiedBy;
        }

        /**
         * Sets the value of the classifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassifiedBy(String value) {
            this.classifiedBy = value;
        }

        public boolean isSetClassifiedBy() {
            return (this.classifiedBy!= null);
        }

        /**
         * Gets the value of the compilationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getCompilationReason() {
            return compilationReason;
        }

        /**
         * Sets the value of the compilationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setCompilationReason(String value) {
            this.compilationReason = value;
        }

        public boolean isSetCompilationReason() {
            return (this.compilationReason!= null);
        }

        /**
         * Gets the value of the derivativelyClassifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivativelyClassifiedBy() {
            return derivativelyClassifiedBy;
        }

        /**
         * Sets the value of the derivativelyClassifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivativelyClassifiedBy(String value) {
            this.derivativelyClassifiedBy = value;
        }

        public boolean isSetDerivativelyClassifiedBy() {
            return (this.derivativelyClassifiedBy!= null);
        }

        /**
         * Gets the value of the classificationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassificationReason() {
            return classificationReason;
        }

        /**
         * Sets the value of the classificationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassificationReason(String value) {
            this.classificationReason = value;
        }

        public boolean isSetClassificationReason() {
            return (this.classificationReason!= null);
        }

        /**
         * Gets the value of the nonUSControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonUSControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonUSControlsValues }
         * 
         * 
         */
        public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
            if (nonUSControls == null) {
                nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
            }
            return this.nonUSControls;
        }

        public boolean isSetNonUSControls() {
            return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
        }

        public void unsetNonUSControls() {
            this.nonUSControls = null;
        }

        /**
         * Gets the value of the derivedFrom property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivedFrom() {
            return derivedFrom;
        }

        /**
         * Sets the value of the derivedFrom property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivedFrom(String value) {
            this.derivedFrom = value;
        }

        public boolean isSetDerivedFrom() {
            return (this.derivedFrom!= null);
        }

        /**
         * Gets the value of the declassDate property.
         * 
         * @return
         *     possible object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public XMLGregorianCalendar getDeclassDate() {
            return declassDate;
        }

        /**
         * Sets the value of the declassDate property.
         * 
         * @param value
         *     allowed object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public void setDeclassDate(XMLGregorianCalendar value) {
            this.declassDate = value;
        }

        public boolean isSetDeclassDate() {
            return (this.declassDate!= null);
        }

        /**
         * Gets the value of the declassEvent property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDeclassEvent() {
            return declassEvent;
        }

        /**
         * Sets the value of the declassEvent property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDeclassEvent(String value) {
            this.declassEvent = value;
        }

        public boolean isSetDeclassEvent() {
            return (this.declassEvent!= null);
        }

        /**
         * Gets the value of the declassException property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISM25X }
         *     
         */
        public CVEnumISM25X getDeclassException() {
            return declassException;
        }

        /**
         * Sets the value of the declassException property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISM25X }
         *     
         */
        public void setDeclassException(CVEnumISM25X value) {
            this.declassException = value;
        }

        public boolean isSetDeclassException() {
            return (this.declassException!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                PersonType thePerson;
                thePerson = this.getPerson();
                strategy.appendField(locator, this, "person", buffer, thePerson, this.isSetPerson());
            }
            {
                OrganizationType theOrganization;
                theOrganization = this.getOrganization();
                strategy.appendField(locator, this, "organization", buffer, theOrganization, this.isSetOrganization());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final TaskingInfoType.Addressee that = ((TaskingInfoType.Addressee) object);
            {
                PersonType lhsPerson;
                lhsPerson = this.getPerson();
                PersonType rhsPerson;
                rhsPerson = that.getPerson();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "person", lhsPerson), LocatorUtils.property(thatLocator, "person", rhsPerson), lhsPerson, rhsPerson, this.isSetPerson(), that.isSetPerson())) {
                    return false;
                }
            }
            {
                OrganizationType lhsOrganization;
                lhsOrganization = this.getOrganization();
                OrganizationType rhsOrganization;
                rhsOrganization = that.getOrganization();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "organization", lhsOrganization), LocatorUtils.property(thatLocator, "organization", rhsOrganization), lhsOrganization, rhsOrganization, this.isSetOrganization(), that.isSetOrganization())) {
                    return false;
                }
            }
            {
                CVEnumISMClassificationAll lhsClassification;
                lhsClassification = this.getClassification();
                CVEnumISMClassificationAll rhsClassification;
                rhsClassification = that.getClassification();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                    return false;
                }
            }
            {
                List<String> lhsOwnerProducer;
                lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                List<String> rhsOwnerProducer;
                rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                    return false;
                }
            }
            {
                boolean lhsJoint;
                lhsJoint = (this.isSetJoint()?this.getJoint():false);
                boolean rhsJoint;
                rhsJoint = (that.isSetJoint()?that.getJoint():false);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                    return false;
                }
            }
            {
                List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                    return false;
                }
            }
            {
                List<String> lhsSARIdentifier;
                lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                List<String> rhsSARIdentifier;
                rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                    return false;
                }
            }
            {
                List<String> lhsAtomicEnergyMarkings;
                lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                List<String> rhsAtomicEnergyMarkings;
                rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                    return false;
                }
            }
            {
                List<CVEnumISMDissemValues> lhsDisseminationControls;
                lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                List<CVEnumISMDissemValues> rhsDisseminationControls;
                rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                    return false;
                }
            }
            {
                List<String> lhsDisplayOnlyTo;
                lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                List<String> rhsDisplayOnlyTo;
                rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceOpen;
                lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                List<String> rhsFGIsourceOpen;
                rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceProtected;
                lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                List<String> rhsFGIsourceProtected;
                rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                    return false;
                }
            }
            {
                List<String> lhsReleasableTo;
                lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                List<String> rhsReleasableTo;
                rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonICValues> lhsNonICmarkings;
                lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                List<CVEnumISMNonICValues> rhsNonICmarkings;
                rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                    return false;
                }
            }
            {
                String lhsClassifiedBy;
                lhsClassifiedBy = this.getClassifiedBy();
                String rhsClassifiedBy;
                rhsClassifiedBy = that.getClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsCompilationReason;
                lhsCompilationReason = this.getCompilationReason();
                String rhsCompilationReason;
                rhsCompilationReason = that.getCompilationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                    return false;
                }
            }
            {
                String lhsDerivativelyClassifiedBy;
                lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                String rhsDerivativelyClassifiedBy;
                rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsClassificationReason;
                lhsClassificationReason = this.getClassificationReason();
                String rhsClassificationReason;
                rhsClassificationReason = that.getClassificationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                    return false;
                }
            }
            {
                String lhsDerivedFrom;
                lhsDerivedFrom = this.getDerivedFrom();
                String rhsDerivedFrom;
                rhsDerivedFrom = that.getDerivedFrom();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                    return false;
                }
            }
            {
                XMLGregorianCalendar lhsDeclassDate;
                lhsDeclassDate = this.getDeclassDate();
                XMLGregorianCalendar rhsDeclassDate;
                rhsDeclassDate = that.getDeclassDate();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                    return false;
                }
            }
            {
                String lhsDeclassEvent;
                lhsDeclassEvent = this.getDeclassEvent();
                String rhsDeclassEvent;
                rhsDeclassEvent = that.getDeclassEvent();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                    return false;
                }
            }
            {
                CVEnumISM25X lhsDeclassException;
                lhsDeclassException = this.getDeclassException();
                CVEnumISM25X rhsDeclassException;
                rhsDeclassException = that.getDeclassException();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                PersonType thePerson;
                thePerson = this.getPerson();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "person", thePerson), currentHashCode, thePerson, this.isSetPerson());
            }
            {
                OrganizationType theOrganization;
                theOrganization = this.getOrganization();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "organization", theOrganization), currentHashCode, theOrganization, this.isSetOrganization());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof TaskingInfoType.Addressee) {
                final TaskingInfoType.Addressee copy = ((TaskingInfoType.Addressee) draftCopy);
                {
                    Boolean personShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPerson());
                    if (personShouldBeCopiedAndSet == Boolean.TRUE) {
                        PersonType sourcePerson;
                        sourcePerson = this.getPerson();
                        PersonType copyPerson = ((PersonType) strategy.copy(LocatorUtils.property(locator, "person", sourcePerson), sourcePerson, this.isSetPerson()));
                        copy.setPerson(copyPerson);
                    } else {
                        if (personShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.person = null;
                        }
                    }
                }
                {
                    Boolean organizationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOrganization());
                    if (organizationShouldBeCopiedAndSet == Boolean.TRUE) {
                        OrganizationType sourceOrganization;
                        sourceOrganization = this.getOrganization();
                        OrganizationType copyOrganization = ((OrganizationType) strategy.copy(LocatorUtils.property(locator, "organization", sourceOrganization), sourceOrganization, this.isSetOrganization()));
                        copy.setOrganization(copyOrganization);
                    } else {
                        if (organizationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.organization = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                    if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll sourceClassification;
                        sourceClassification = this.getClassification();
                        CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                        copy.setClassification(copyClassification);
                    } else {
                        if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceOwnerProducer;
                        sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                        copy.unsetOwnerProducer();
                        if (copyOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(copyOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                    if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                        boolean sourceJoint;
                        sourceJoint = (this.isSetJoint()?this.getJoint():false);
                        boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                        copy.setJoint(copyJoint);
                    } else {
                        if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                        sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                        copy.unsetSCIcontrols();
                        if (copySCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(copySCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceSARIdentifier;
                        sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                        @SuppressWarnings("unchecked")
                        List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                        copy.unsetSARIdentifier();
                        if (copySARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(copySARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceAtomicEnergyMarkings;
                        sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                        copy.unsetAtomicEnergyMarkings();
                        if (copyAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> sourceDisseminationControls;
                        sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                        copy.unsetDisseminationControls();
                        if (copyDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceDisplayOnlyTo;
                        sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                        copy.unsetDisplayOnlyTo();
                        if (copyDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceOpen;
                        sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                        copy.unsetFGIsourceOpen();
                        if (copyFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceProtected;
                        sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                        copy.unsetFGIsourceProtected();
                        if (copyFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                    if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceReleasableTo;
                        sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                        copy.unsetReleasableTo();
                        if (copyReleasableTo!= null) {
                            List<String> uniqueReleasableTol = copy.getReleasableTo();
                            uniqueReleasableTol.addAll(copyReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> sourceNonICmarkings;
                        sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                        copy.unsetNonICmarkings();
                        if (copyNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                    if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassifiedBy;
                        sourceClassifiedBy = this.getClassifiedBy();
                        String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                        copy.setClassifiedBy(copyClassifiedBy);
                    } else {
                        if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceCompilationReason;
                        sourceCompilationReason = this.getCompilationReason();
                        String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                        copy.setCompilationReason(copyCompilationReason);
                    } else {
                        if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivativelyClassifiedBy;
                        sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                        String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                        copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassificationReason;
                        sourceClassificationReason = this.getClassificationReason();
                        String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                        copy.setClassificationReason(copyClassificationReason);
                    } else {
                        if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                        sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                        copy.unsetNonUSControls();
                        if (copyNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                            uniqueNonUSControlsl.addAll(copyNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                    if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivedFrom;
                        sourceDerivedFrom = this.getDerivedFrom();
                        String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                        copy.setDerivedFrom(copyDerivedFrom);
                    } else {
                        if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                    if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar sourceDeclassDate;
                        sourceDeclassDate = this.getDeclassDate();
                        XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                        copy.setDeclassDate(copyDeclassDate);
                    } else {
                        if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                    if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDeclassEvent;
                        sourceDeclassEvent = this.getDeclassEvent();
                        String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                        copy.setDeclassEvent(copyDeclassEvent);
                    } else {
                        if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISM25X sourceDeclassException;
                        sourceDeclassException = this.getDeclassException();
                        CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                        copy.setDeclassException(copyDeclassException);
                    } else {
                        if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassException = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new TaskingInfoType.Addressee();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof TaskingInfoType.Addressee) {
                final TaskingInfoType.Addressee target = this;
                final TaskingInfoType.Addressee leftObject = ((TaskingInfoType.Addressee) left);
                final TaskingInfoType.Addressee rightObject = ((TaskingInfoType.Addressee) right);
                {
                    Boolean personShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPerson(), rightObject.isSetPerson());
                    if (personShouldBeMergedAndSet == Boolean.TRUE) {
                        PersonType lhsPerson;
                        lhsPerson = leftObject.getPerson();
                        PersonType rhsPerson;
                        rhsPerson = rightObject.getPerson();
                        PersonType mergedPerson = ((PersonType) strategy.merge(LocatorUtils.property(leftLocator, "person", lhsPerson), LocatorUtils.property(rightLocator, "person", rhsPerson), lhsPerson, rhsPerson, leftObject.isSetPerson(), rightObject.isSetPerson()));
                        target.setPerson(mergedPerson);
                    } else {
                        if (personShouldBeMergedAndSet == Boolean.FALSE) {
                            target.person = null;
                        }
                    }
                }
                {
                    Boolean organizationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOrganization(), rightObject.isSetOrganization());
                    if (organizationShouldBeMergedAndSet == Boolean.TRUE) {
                        OrganizationType lhsOrganization;
                        lhsOrganization = leftObject.getOrganization();
                        OrganizationType rhsOrganization;
                        rhsOrganization = rightObject.getOrganization();
                        OrganizationType mergedOrganization = ((OrganizationType) strategy.merge(LocatorUtils.property(leftLocator, "organization", lhsOrganization), LocatorUtils.property(rightLocator, "organization", rhsOrganization), lhsOrganization, rhsOrganization, leftObject.isSetOrganization(), rightObject.isSetOrganization()));
                        target.setOrganization(mergedOrganization);
                    } else {
                        if (organizationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.organization = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                    if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll lhsClassification;
                        lhsClassification = leftObject.getClassification();
                        CVEnumISMClassificationAll rhsClassification;
                        rhsClassification = rightObject.getClassification();
                        CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                        target.setClassification(mergedClassification);
                    } else {
                        if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                    if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsOwnerProducer;
                        lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                        List<String> rhsOwnerProducer;
                        rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                        List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                        target.unsetOwnerProducer();
                        if (mergedOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                    if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                        boolean lhsJoint;
                        lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                        boolean rhsJoint;
                        rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                        boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                        target.setJoint(mergedJoint);
                    } else {
                        if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                        lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                        rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                        target.unsetSCIcontrols();
                        if (mergedSCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsSARIdentifier;
                        lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                        List<String> rhsSARIdentifier;
                        rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                        List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                        target.unsetSARIdentifier();
                        if (mergedSARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsAtomicEnergyMarkings;
                        lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                        List<String> rhsAtomicEnergyMarkings;
                        rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                        List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                        target.unsetAtomicEnergyMarkings();
                        if (mergedAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> lhsDisseminationControls;
                        lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> rhsDisseminationControls;
                        rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                        target.unsetDisseminationControls();
                        if (mergedDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsDisplayOnlyTo;
                        lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                        List<String> rhsDisplayOnlyTo;
                        rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                        List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                        target.unsetDisplayOnlyTo();
                        if (mergedDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceOpen;
                        lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                        List<String> rhsFGIsourceOpen;
                        rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                        List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                        target.unsetFGIsourceOpen();
                        if (mergedFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceProtected;
                        lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                        List<String> rhsFGIsourceProtected;
                        rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                        List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                        target.unsetFGIsourceProtected();
                        if (mergedFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                    if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsReleasableTo;
                        lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                        List<String> rhsReleasableTo;
                        rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                        List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                        target.unsetReleasableTo();
                        if (mergedReleasableTo!= null) {
                            List<String> uniqueReleasableTol = target.getReleasableTo();
                            uniqueReleasableTol.addAll(mergedReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> lhsNonICmarkings;
                        lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> rhsNonICmarkings;
                        rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                        target.unsetNonICmarkings();
                        if (mergedNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                    if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassifiedBy;
                        lhsClassifiedBy = leftObject.getClassifiedBy();
                        String rhsClassifiedBy;
                        rhsClassifiedBy = rightObject.getClassifiedBy();
                        String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                        target.setClassifiedBy(mergedClassifiedBy);
                    } else {
                        if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                    if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsCompilationReason;
                        lhsCompilationReason = leftObject.getCompilationReason();
                        String rhsCompilationReason;
                        rhsCompilationReason = rightObject.getCompilationReason();
                        String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                        target.setCompilationReason(mergedCompilationReason);
                    } else {
                        if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivativelyClassifiedBy;
                        lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                        String rhsDerivativelyClassifiedBy;
                        rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                        String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                        target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                    if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassificationReason;
                        lhsClassificationReason = leftObject.getClassificationReason();
                        String rhsClassificationReason;
                        rhsClassificationReason = rightObject.getClassificationReason();
                        String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                        target.setClassificationReason(mergedClassificationReason);
                    } else {
                        if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                        lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                        rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                        target.unsetNonUSControls();
                        if (mergedNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                            uniqueNonUSControlsl.addAll(mergedNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                    if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivedFrom;
                        lhsDerivedFrom = leftObject.getDerivedFrom();
                        String rhsDerivedFrom;
                        rhsDerivedFrom = rightObject.getDerivedFrom();
                        String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                        target.setDerivedFrom(mergedDerivedFrom);
                    } else {
                        if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                    if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar lhsDeclassDate;
                        lhsDeclassDate = leftObject.getDeclassDate();
                        XMLGregorianCalendar rhsDeclassDate;
                        rhsDeclassDate = rightObject.getDeclassDate();
                        XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                        target.setDeclassDate(mergedDeclassDate);
                    } else {
                        if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                    if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDeclassEvent;
                        lhsDeclassEvent = leftObject.getDeclassEvent();
                        String rhsDeclassEvent;
                        rhsDeclassEvent = rightObject.getDeclassEvent();
                        String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                        target.setDeclassEvent(mergedDeclassEvent);
                    } else {
                        if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                    if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISM25X lhsDeclassException;
                        lhsDeclassException = leftObject.getDeclassException();
                        CVEnumISM25X rhsDeclassException;
                        rhsDeclassException = rightObject.getDeclassException();
                        CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                        target.setDeclassException(mergedDeclassException);
                    } else {
                        if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassException = null;
                        }
                    }
                }
            }
        }

        public void setOwnerProducer(List<String> value) {
            this.ownerProducer = null;
            if (value!= null) {
                List<String> draftl = this.getOwnerProducer();
                draftl.addAll(value);
            }
        }

        public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
            this.scIcontrols = null;
            if (value!= null) {
                List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
                draftl.addAll(value);
            }
        }

        public void setSARIdentifier(List<String> value) {
            this.sarIdentifier = null;
            if (value!= null) {
                List<String> draftl = this.getSARIdentifier();
                draftl.addAll(value);
            }
        }

        public void setAtomicEnergyMarkings(List<String> value) {
            this.atomicEnergyMarkings = null;
            if (value!= null) {
                List<String> draftl = this.getAtomicEnergyMarkings();
                draftl.addAll(value);
            }
        }

        public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
            this.disseminationControls = null;
            if (value!= null) {
                List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
                draftl.addAll(value);
            }
        }

        public void setDisplayOnlyTo(List<String> value) {
            this.displayOnlyTo = null;
            if (value!= null) {
                List<String> draftl = this.getDisplayOnlyTo();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceOpen(List<String> value) {
            this.fgIsourceOpen = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceOpen();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceProtected(List<String> value) {
            this.fgIsourceProtected = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceProtected();
                draftl.addAll(value);
            }
        }

        public void setReleasableTo(List<String> value) {
            this.releasableTo = null;
            if (value!= null) {
                List<String> draftl = this.getReleasableTo();
                draftl.addAll(value);
            }
        }

        public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
            this.nonICmarkings = null;
            if (value!= null) {
                List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
                draftl.addAll(value);
            }
        }

        public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
            this.nonUSControls = null;
            if (value!= null) {
                List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
                draftl.addAll(value);
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;choice&gt;
     *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}person"/&gt;
     *         &lt;element ref="{urn:us:mil:ces:metadata:ddms:5}organization"/&gt;
     *       &lt;/choice&gt;
     *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SecurityAttributesGroup"/&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "person",
        "organization"
    })
    public static class RequesterInfo implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @Valid
        protected PersonType person;
        @Valid
        protected OrganizationType organization;
        @XmlAttribute(name = "classification", namespace = "urn:us:gov:ic:ism", required = true)
        @NotNull(message = "RequesterInfo.classification {javax.validation.constraints.NotNull.message}")
        protected CVEnumISMClassificationAll classification;
        @XmlAttribute(name = "ownerProducer", namespace = "urn:us:gov:ic:ism", required = true)
        @NotNull(message = "RequesterInfo.ownerProducer {javax.validation.constraints.NotNull.message}")
        protected List<String> ownerProducer;
        @XmlAttribute(name = "joint", namespace = "urn:us:gov:ic:ism")
        protected Boolean joint;
        @XmlAttribute(name = "SCIcontrols", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMSCIControlsValues> scIcontrols;
        @XmlAttribute(name = "SARIdentifier", namespace = "urn:us:gov:ic:ism")
        protected List<String> sarIdentifier;
        @XmlAttribute(name = "atomicEnergyMarkings", namespace = "urn:us:gov:ic:ism")
        protected List<String> atomicEnergyMarkings;
        @XmlAttribute(name = "disseminationControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMDissemValues> disseminationControls;
        @XmlAttribute(name = "displayOnlyTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> displayOnlyTo;
        @XmlAttribute(name = "FGIsourceOpen", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceOpen;
        @XmlAttribute(name = "FGIsourceProtected", namespace = "urn:us:gov:ic:ism")
        protected List<String> fgIsourceProtected;
        @XmlAttribute(name = "releasableTo", namespace = "urn:us:gov:ic:ism")
        protected List<String> releasableTo;
        @XmlAttribute(name = "nonICmarkings", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonICValues> nonICmarkings;
        @XmlAttribute(name = "classifiedBy", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String classifiedBy;
        @XmlAttribute(name = "compilationReason", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String compilationReason;
        @XmlAttribute(name = "derivativelyClassifiedBy", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String derivativelyClassifiedBy;
        @XmlAttribute(name = "classificationReason", namespace = "urn:us:gov:ic:ism")
        @Size(max = 4096)
        protected String classificationReason;
        @XmlAttribute(name = "nonUSControls", namespace = "urn:us:gov:ic:ism")
        protected List<CVEnumISMNonUSControlsValues> nonUSControls;
        @XmlAttribute(name = "derivedFrom", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String derivedFrom;
        @XmlAttribute(name = "declassDate", namespace = "urn:us:gov:ic:ism")
        protected XMLGregorianCalendar declassDate;
        @XmlAttribute(name = "declassEvent", namespace = "urn:us:gov:ic:ism")
        @Size(max = 1024)
        protected String declassEvent;
        @XmlAttribute(name = "declassException", namespace = "urn:us:gov:ic:ism")
        protected CVEnumISM25X declassException;

        /**
         * Gets the value of the person property.
         * 
         * @return
         *     possible object is
         *     {@link PersonType }
         *     
         */
        public PersonType getPerson() {
            return person;
        }

        /**
         * Sets the value of the person property.
         * 
         * @param value
         *     allowed object is
         *     {@link PersonType }
         *     
         */
        public void setPerson(PersonType value) {
            this.person = value;
        }

        public boolean isSetPerson() {
            return (this.person!= null);
        }

        /**
         * Gets the value of the organization property.
         * 
         * @return
         *     possible object is
         *     {@link OrganizationType }
         *     
         */
        public OrganizationType getOrganization() {
            return organization;
        }

        /**
         * Sets the value of the organization property.
         * 
         * @param value
         *     allowed object is
         *     {@link OrganizationType }
         *     
         */
        public void setOrganization(OrganizationType value) {
            this.organization = value;
        }

        public boolean isSetOrganization() {
            return (this.organization!= null);
        }

        /**
         * Gets the value of the classification property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public CVEnumISMClassificationAll getClassification() {
            return classification;
        }

        /**
         * Sets the value of the classification property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISMClassificationAll }
         *     
         */
        public void setClassification(CVEnumISMClassificationAll value) {
            this.classification = value;
        }

        public boolean isSetClassification() {
            return (this.classification!= null);
        }

        /**
         * Gets the value of the ownerProducer property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the ownerProducer property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getOwnerProducer().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getOwnerProducer() {
            if (ownerProducer == null) {
                ownerProducer = new ArrayList<String>();
            }
            return this.ownerProducer;
        }

        public boolean isSetOwnerProducer() {
            return ((this.ownerProducer!= null)&&(!this.ownerProducer.isEmpty()));
        }

        public void unsetOwnerProducer() {
            this.ownerProducer = null;
        }

        /**
         * Gets the value of the joint property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean getJoint() {
            return joint;
        }

        /**
         * Sets the value of the joint property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setJoint(boolean value) {
            this.joint = value;
        }

        public boolean isSetJoint() {
            return (this.joint!= null);
        }

        public void unsetJoint() {
            this.joint = null;
        }

        /**
         * Gets the value of the scIcontrols property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the scIcontrols property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSCIcontrols().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMSCIControlsValues }
         * 
         * 
         */
        public List<CVEnumISMSCIControlsValues> getSCIcontrols() {
            if (scIcontrols == null) {
                scIcontrols = new ArrayList<CVEnumISMSCIControlsValues>();
            }
            return this.scIcontrols;
        }

        public boolean isSetSCIcontrols() {
            return ((this.scIcontrols!= null)&&(!this.scIcontrols.isEmpty()));
        }

        public void unsetSCIcontrols() {
            this.scIcontrols = null;
        }

        /**
         * Gets the value of the sarIdentifier property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the sarIdentifier property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSARIdentifier().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getSARIdentifier() {
            if (sarIdentifier == null) {
                sarIdentifier = new ArrayList<String>();
            }
            return this.sarIdentifier;
        }

        public boolean isSetSARIdentifier() {
            return ((this.sarIdentifier!= null)&&(!this.sarIdentifier.isEmpty()));
        }

        public void unsetSARIdentifier() {
            this.sarIdentifier = null;
        }

        /**
         * Gets the value of the atomicEnergyMarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the atomicEnergyMarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAtomicEnergyMarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getAtomicEnergyMarkings() {
            if (atomicEnergyMarkings == null) {
                atomicEnergyMarkings = new ArrayList<String>();
            }
            return this.atomicEnergyMarkings;
        }

        public boolean isSetAtomicEnergyMarkings() {
            return ((this.atomicEnergyMarkings!= null)&&(!this.atomicEnergyMarkings.isEmpty()));
        }

        public void unsetAtomicEnergyMarkings() {
            this.atomicEnergyMarkings = null;
        }

        /**
         * Gets the value of the disseminationControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the disseminationControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisseminationControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMDissemValues }
         * 
         * 
         */
        public List<CVEnumISMDissemValues> getDisseminationControls() {
            if (disseminationControls == null) {
                disseminationControls = new ArrayList<CVEnumISMDissemValues>();
            }
            return this.disseminationControls;
        }

        public boolean isSetDisseminationControls() {
            return ((this.disseminationControls!= null)&&(!this.disseminationControls.isEmpty()));
        }

        public void unsetDisseminationControls() {
            this.disseminationControls = null;
        }

        /**
         * Gets the value of the displayOnlyTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the displayOnlyTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getDisplayOnlyTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getDisplayOnlyTo() {
            if (displayOnlyTo == null) {
                displayOnlyTo = new ArrayList<String>();
            }
            return this.displayOnlyTo;
        }

        public boolean isSetDisplayOnlyTo() {
            return ((this.displayOnlyTo!= null)&&(!this.displayOnlyTo.isEmpty()));
        }

        public void unsetDisplayOnlyTo() {
            this.displayOnlyTo = null;
        }

        /**
         * Gets the value of the fgIsourceOpen property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceOpen property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceOpen().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceOpen() {
            if (fgIsourceOpen == null) {
                fgIsourceOpen = new ArrayList<String>();
            }
            return this.fgIsourceOpen;
        }

        public boolean isSetFGIsourceOpen() {
            return ((this.fgIsourceOpen!= null)&&(!this.fgIsourceOpen.isEmpty()));
        }

        public void unsetFGIsourceOpen() {
            this.fgIsourceOpen = null;
        }

        /**
         * Gets the value of the fgIsourceProtected property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fgIsourceProtected property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFGIsourceProtected().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getFGIsourceProtected() {
            if (fgIsourceProtected == null) {
                fgIsourceProtected = new ArrayList<String>();
            }
            return this.fgIsourceProtected;
        }

        public boolean isSetFGIsourceProtected() {
            return ((this.fgIsourceProtected!= null)&&(!this.fgIsourceProtected.isEmpty()));
        }

        public void unsetFGIsourceProtected() {
            this.fgIsourceProtected = null;
        }

        /**
         * Gets the value of the releasableTo property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the releasableTo property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getReleasableTo().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getReleasableTo() {
            if (releasableTo == null) {
                releasableTo = new ArrayList<String>();
            }
            return this.releasableTo;
        }

        public boolean isSetReleasableTo() {
            return ((this.releasableTo!= null)&&(!this.releasableTo.isEmpty()));
        }

        public void unsetReleasableTo() {
            this.releasableTo = null;
        }

        /**
         * Gets the value of the nonICmarkings property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonICmarkings property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonICmarkings().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonICValues }
         * 
         * 
         */
        public List<CVEnumISMNonICValues> getNonICmarkings() {
            if (nonICmarkings == null) {
                nonICmarkings = new ArrayList<CVEnumISMNonICValues>();
            }
            return this.nonICmarkings;
        }

        public boolean isSetNonICmarkings() {
            return ((this.nonICmarkings!= null)&&(!this.nonICmarkings.isEmpty()));
        }

        public void unsetNonICmarkings() {
            this.nonICmarkings = null;
        }

        /**
         * Gets the value of the classifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassifiedBy() {
            return classifiedBy;
        }

        /**
         * Sets the value of the classifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassifiedBy(String value) {
            this.classifiedBy = value;
        }

        public boolean isSetClassifiedBy() {
            return (this.classifiedBy!= null);
        }

        /**
         * Gets the value of the compilationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getCompilationReason() {
            return compilationReason;
        }

        /**
         * Sets the value of the compilationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setCompilationReason(String value) {
            this.compilationReason = value;
        }

        public boolean isSetCompilationReason() {
            return (this.compilationReason!= null);
        }

        /**
         * Gets the value of the derivativelyClassifiedBy property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivativelyClassifiedBy() {
            return derivativelyClassifiedBy;
        }

        /**
         * Sets the value of the derivativelyClassifiedBy property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivativelyClassifiedBy(String value) {
            this.derivativelyClassifiedBy = value;
        }

        public boolean isSetDerivativelyClassifiedBy() {
            return (this.derivativelyClassifiedBy!= null);
        }

        /**
         * Gets the value of the classificationReason property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getClassificationReason() {
            return classificationReason;
        }

        /**
         * Sets the value of the classificationReason property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setClassificationReason(String value) {
            this.classificationReason = value;
        }

        public boolean isSetClassificationReason() {
            return (this.classificationReason!= null);
        }

        /**
         * Gets the value of the nonUSControls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the nonUSControls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getNonUSControls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link CVEnumISMNonUSControlsValues }
         * 
         * 
         */
        public List<CVEnumISMNonUSControlsValues> getNonUSControls() {
            if (nonUSControls == null) {
                nonUSControls = new ArrayList<CVEnumISMNonUSControlsValues>();
            }
            return this.nonUSControls;
        }

        public boolean isSetNonUSControls() {
            return ((this.nonUSControls!= null)&&(!this.nonUSControls.isEmpty()));
        }

        public void unsetNonUSControls() {
            this.nonUSControls = null;
        }

        /**
         * Gets the value of the derivedFrom property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDerivedFrom() {
            return derivedFrom;
        }

        /**
         * Sets the value of the derivedFrom property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDerivedFrom(String value) {
            this.derivedFrom = value;
        }

        public boolean isSetDerivedFrom() {
            return (this.derivedFrom!= null);
        }

        /**
         * Gets the value of the declassDate property.
         * 
         * @return
         *     possible object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public XMLGregorianCalendar getDeclassDate() {
            return declassDate;
        }

        /**
         * Sets the value of the declassDate property.
         * 
         * @param value
         *     allowed object is
         *     {@link XMLGregorianCalendar }
         *     
         */
        public void setDeclassDate(XMLGregorianCalendar value) {
            this.declassDate = value;
        }

        public boolean isSetDeclassDate() {
            return (this.declassDate!= null);
        }

        /**
         * Gets the value of the declassEvent property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDeclassEvent() {
            return declassEvent;
        }

        /**
         * Sets the value of the declassEvent property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDeclassEvent(String value) {
            this.declassEvent = value;
        }

        public boolean isSetDeclassEvent() {
            return (this.declassEvent!= null);
        }

        /**
         * Gets the value of the declassException property.
         * 
         * @return
         *     possible object is
         *     {@link CVEnumISM25X }
         *     
         */
        public CVEnumISM25X getDeclassException() {
            return declassException;
        }

        /**
         * Sets the value of the declassException property.
         * 
         * @param value
         *     allowed object is
         *     {@link CVEnumISM25X }
         *     
         */
        public void setDeclassException(CVEnumISM25X value) {
            this.declassException = value;
        }

        public boolean isSetDeclassException() {
            return (this.declassException!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                PersonType thePerson;
                thePerson = this.getPerson();
                strategy.appendField(locator, this, "person", buffer, thePerson, this.isSetPerson());
            }
            {
                OrganizationType theOrganization;
                theOrganization = this.getOrganization();
                strategy.appendField(locator, this, "organization", buffer, theOrganization, this.isSetOrganization());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                strategy.appendField(locator, this, "classification", buffer, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                strategy.appendField(locator, this, "ownerProducer", buffer, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                strategy.appendField(locator, this, "joint", buffer, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                strategy.appendField(locator, this, "scIcontrols", buffer, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                strategy.appendField(locator, this, "sarIdentifier", buffer, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                strategy.appendField(locator, this, "atomicEnergyMarkings", buffer, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                strategy.appendField(locator, this, "disseminationControls", buffer, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                strategy.appendField(locator, this, "displayOnlyTo", buffer, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                strategy.appendField(locator, this, "fgIsourceOpen", buffer, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                strategy.appendField(locator, this, "fgIsourceProtected", buffer, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                strategy.appendField(locator, this, "releasableTo", buffer, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                strategy.appendField(locator, this, "nonICmarkings", buffer, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                strategy.appendField(locator, this, "classifiedBy", buffer, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                strategy.appendField(locator, this, "compilationReason", buffer, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                strategy.appendField(locator, this, "derivativelyClassifiedBy", buffer, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                strategy.appendField(locator, this, "classificationReason", buffer, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                strategy.appendField(locator, this, "nonUSControls", buffer, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                strategy.appendField(locator, this, "derivedFrom", buffer, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                strategy.appendField(locator, this, "declassDate", buffer, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                strategy.appendField(locator, this, "declassEvent", buffer, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                strategy.appendField(locator, this, "declassException", buffer, theDeclassException, this.isSetDeclassException());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final TaskingInfoType.RequesterInfo that = ((TaskingInfoType.RequesterInfo) object);
            {
                PersonType lhsPerson;
                lhsPerson = this.getPerson();
                PersonType rhsPerson;
                rhsPerson = that.getPerson();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "person", lhsPerson), LocatorUtils.property(thatLocator, "person", rhsPerson), lhsPerson, rhsPerson, this.isSetPerson(), that.isSetPerson())) {
                    return false;
                }
            }
            {
                OrganizationType lhsOrganization;
                lhsOrganization = this.getOrganization();
                OrganizationType rhsOrganization;
                rhsOrganization = that.getOrganization();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "organization", lhsOrganization), LocatorUtils.property(thatLocator, "organization", rhsOrganization), lhsOrganization, rhsOrganization, this.isSetOrganization(), that.isSetOrganization())) {
                    return false;
                }
            }
            {
                CVEnumISMClassificationAll lhsClassification;
                lhsClassification = this.getClassification();
                CVEnumISMClassificationAll rhsClassification;
                rhsClassification = that.getClassification();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classification", lhsClassification), LocatorUtils.property(thatLocator, "classification", rhsClassification), lhsClassification, rhsClassification, this.isSetClassification(), that.isSetClassification())) {
                    return false;
                }
            }
            {
                List<String> lhsOwnerProducer;
                lhsOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                List<String> rhsOwnerProducer;
                rhsOwnerProducer = (that.isSetOwnerProducer()?that.getOwnerProducer():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(thatLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, this.isSetOwnerProducer(), that.isSetOwnerProducer())) {
                    return false;
                }
            }
            {
                boolean lhsJoint;
                lhsJoint = (this.isSetJoint()?this.getJoint():false);
                boolean rhsJoint;
                rhsJoint = (that.isSetJoint()?that.getJoint():false);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "joint", lhsJoint), LocatorUtils.property(thatLocator, "joint", rhsJoint), lhsJoint, rhsJoint, this.isSetJoint(), that.isSetJoint())) {
                    return false;
                }
            }
            {
                List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                lhsSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                rhsSCIcontrols = (that.isSetSCIcontrols()?that.getSCIcontrols():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(thatLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, this.isSetSCIcontrols(), that.isSetSCIcontrols())) {
                    return false;
                }
            }
            {
                List<String> lhsSARIdentifier;
                lhsSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                List<String> rhsSARIdentifier;
                rhsSARIdentifier = (that.isSetSARIdentifier()?that.getSARIdentifier():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(thatLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, this.isSetSARIdentifier(), that.isSetSARIdentifier())) {
                    return false;
                }
            }
            {
                List<String> lhsAtomicEnergyMarkings;
                lhsAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                List<String> rhsAtomicEnergyMarkings;
                rhsAtomicEnergyMarkings = (that.isSetAtomicEnergyMarkings()?that.getAtomicEnergyMarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(thatLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings(), that.isSetAtomicEnergyMarkings())) {
                    return false;
                }
            }
            {
                List<CVEnumISMDissemValues> lhsDisseminationControls;
                lhsDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                List<CVEnumISMDissemValues> rhsDisseminationControls;
                rhsDisseminationControls = (that.isSetDisseminationControls()?that.getDisseminationControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(thatLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, this.isSetDisseminationControls(), that.isSetDisseminationControls())) {
                    return false;
                }
            }
            {
                List<String> lhsDisplayOnlyTo;
                lhsDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                List<String> rhsDisplayOnlyTo;
                rhsDisplayOnlyTo = (that.isSetDisplayOnlyTo()?that.getDisplayOnlyTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(thatLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, this.isSetDisplayOnlyTo(), that.isSetDisplayOnlyTo())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceOpen;
                lhsFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                List<String> rhsFGIsourceOpen;
                rhsFGIsourceOpen = (that.isSetFGIsourceOpen()?that.getFGIsourceOpen():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(thatLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, this.isSetFGIsourceOpen(), that.isSetFGIsourceOpen())) {
                    return false;
                }
            }
            {
                List<String> lhsFGIsourceProtected;
                lhsFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                List<String> rhsFGIsourceProtected;
                rhsFGIsourceProtected = (that.isSetFGIsourceProtected()?that.getFGIsourceProtected():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(thatLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, this.isSetFGIsourceProtected(), that.isSetFGIsourceProtected())) {
                    return false;
                }
            }
            {
                List<String> lhsReleasableTo;
                lhsReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                List<String> rhsReleasableTo;
                rhsReleasableTo = (that.isSetReleasableTo()?that.getReleasableTo():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(thatLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, this.isSetReleasableTo(), that.isSetReleasableTo())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonICValues> lhsNonICmarkings;
                lhsNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                List<CVEnumISMNonICValues> rhsNonICmarkings;
                rhsNonICmarkings = (that.isSetNonICmarkings()?that.getNonICmarkings():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(thatLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, this.isSetNonICmarkings(), that.isSetNonICmarkings())) {
                    return false;
                }
            }
            {
                String lhsClassifiedBy;
                lhsClassifiedBy = this.getClassifiedBy();
                String rhsClassifiedBy;
                rhsClassifiedBy = that.getClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(thatLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, this.isSetClassifiedBy(), that.isSetClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsCompilationReason;
                lhsCompilationReason = this.getCompilationReason();
                String rhsCompilationReason;
                rhsCompilationReason = that.getCompilationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(thatLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, this.isSetCompilationReason(), that.isSetCompilationReason())) {
                    return false;
                }
            }
            {
                String lhsDerivativelyClassifiedBy;
                lhsDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                String rhsDerivativelyClassifiedBy;
                rhsDerivativelyClassifiedBy = that.getDerivativelyClassifiedBy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(thatLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy(), that.isSetDerivativelyClassifiedBy())) {
                    return false;
                }
            }
            {
                String lhsClassificationReason;
                lhsClassificationReason = this.getClassificationReason();
                String rhsClassificationReason;
                rhsClassificationReason = that.getClassificationReason();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(thatLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, this.isSetClassificationReason(), that.isSetClassificationReason())) {
                    return false;
                }
            }
            {
                List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                lhsNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                rhsNonUSControls = (that.isSetNonUSControls()?that.getNonUSControls():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(thatLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, this.isSetNonUSControls(), that.isSetNonUSControls())) {
                    return false;
                }
            }
            {
                String lhsDerivedFrom;
                lhsDerivedFrom = this.getDerivedFrom();
                String rhsDerivedFrom;
                rhsDerivedFrom = that.getDerivedFrom();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(thatLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, this.isSetDerivedFrom(), that.isSetDerivedFrom())) {
                    return false;
                }
            }
            {
                XMLGregorianCalendar lhsDeclassDate;
                lhsDeclassDate = this.getDeclassDate();
                XMLGregorianCalendar rhsDeclassDate;
                rhsDeclassDate = that.getDeclassDate();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(thatLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, this.isSetDeclassDate(), that.isSetDeclassDate())) {
                    return false;
                }
            }
            {
                String lhsDeclassEvent;
                lhsDeclassEvent = this.getDeclassEvent();
                String rhsDeclassEvent;
                rhsDeclassEvent = that.getDeclassEvent();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(thatLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, this.isSetDeclassEvent(), that.isSetDeclassEvent())) {
                    return false;
                }
            }
            {
                CVEnumISM25X lhsDeclassException;
                lhsDeclassException = this.getDeclassException();
                CVEnumISM25X rhsDeclassException;
                rhsDeclassException = that.getDeclassException();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "declassException", lhsDeclassException), LocatorUtils.property(thatLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, this.isSetDeclassException(), that.isSetDeclassException())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                PersonType thePerson;
                thePerson = this.getPerson();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "person", thePerson), currentHashCode, thePerson, this.isSetPerson());
            }
            {
                OrganizationType theOrganization;
                theOrganization = this.getOrganization();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "organization", theOrganization), currentHashCode, theOrganization, this.isSetOrganization());
            }
            {
                CVEnumISMClassificationAll theClassification;
                theClassification = this.getClassification();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classification", theClassification), currentHashCode, theClassification, this.isSetClassification());
            }
            {
                List<String> theOwnerProducer;
                theOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownerProducer", theOwnerProducer), currentHashCode, theOwnerProducer, this.isSetOwnerProducer());
            }
            {
                boolean theJoint;
                theJoint = (this.isSetJoint()?this.getJoint():false);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "joint", theJoint), currentHashCode, theJoint, this.isSetJoint());
            }
            {
                List<CVEnumISMSCIControlsValues> theSCIcontrols;
                theSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scIcontrols", theSCIcontrols), currentHashCode, theSCIcontrols, this.isSetSCIcontrols());
            }
            {
                List<String> theSARIdentifier;
                theSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sarIdentifier", theSARIdentifier), currentHashCode, theSARIdentifier, this.isSetSARIdentifier());
            }
            {
                List<String> theAtomicEnergyMarkings;
                theAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "atomicEnergyMarkings", theAtomicEnergyMarkings), currentHashCode, theAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings());
            }
            {
                List<CVEnumISMDissemValues> theDisseminationControls;
                theDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disseminationControls", theDisseminationControls), currentHashCode, theDisseminationControls, this.isSetDisseminationControls());
            }
            {
                List<String> theDisplayOnlyTo;
                theDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "displayOnlyTo", theDisplayOnlyTo), currentHashCode, theDisplayOnlyTo, this.isSetDisplayOnlyTo());
            }
            {
                List<String> theFGIsourceOpen;
                theFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceOpen", theFGIsourceOpen), currentHashCode, theFGIsourceOpen, this.isSetFGIsourceOpen());
            }
            {
                List<String> theFGIsourceProtected;
                theFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fgIsourceProtected", theFGIsourceProtected), currentHashCode, theFGIsourceProtected, this.isSetFGIsourceProtected());
            }
            {
                List<String> theReleasableTo;
                theReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "releasableTo", theReleasableTo), currentHashCode, theReleasableTo, this.isSetReleasableTo());
            }
            {
                List<CVEnumISMNonICValues> theNonICmarkings;
                theNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonICmarkings", theNonICmarkings), currentHashCode, theNonICmarkings, this.isSetNonICmarkings());
            }
            {
                String theClassifiedBy;
                theClassifiedBy = this.getClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classifiedBy", theClassifiedBy), currentHashCode, theClassifiedBy, this.isSetClassifiedBy());
            }
            {
                String theCompilationReason;
                theCompilationReason = this.getCompilationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "compilationReason", theCompilationReason), currentHashCode, theCompilationReason, this.isSetCompilationReason());
            }
            {
                String theDerivativelyClassifiedBy;
                theDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivativelyClassifiedBy", theDerivativelyClassifiedBy), currentHashCode, theDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy());
            }
            {
                String theClassificationReason;
                theClassificationReason = this.getClassificationReason();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classificationReason", theClassificationReason), currentHashCode, theClassificationReason, this.isSetClassificationReason());
            }
            {
                List<CVEnumISMNonUSControlsValues> theNonUSControls;
                theNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonUSControls", theNonUSControls), currentHashCode, theNonUSControls, this.isSetNonUSControls());
            }
            {
                String theDerivedFrom;
                theDerivedFrom = this.getDerivedFrom();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "derivedFrom", theDerivedFrom), currentHashCode, theDerivedFrom, this.isSetDerivedFrom());
            }
            {
                XMLGregorianCalendar theDeclassDate;
                theDeclassDate = this.getDeclassDate();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassDate", theDeclassDate), currentHashCode, theDeclassDate, this.isSetDeclassDate());
            }
            {
                String theDeclassEvent;
                theDeclassEvent = this.getDeclassEvent();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassEvent", theDeclassEvent), currentHashCode, theDeclassEvent, this.isSetDeclassEvent());
            }
            {
                CVEnumISM25X theDeclassException;
                theDeclassException = this.getDeclassException();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "declassException", theDeclassException), currentHashCode, theDeclassException, this.isSetDeclassException());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof TaskingInfoType.RequesterInfo) {
                final TaskingInfoType.RequesterInfo copy = ((TaskingInfoType.RequesterInfo) draftCopy);
                {
                    Boolean personShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPerson());
                    if (personShouldBeCopiedAndSet == Boolean.TRUE) {
                        PersonType sourcePerson;
                        sourcePerson = this.getPerson();
                        PersonType copyPerson = ((PersonType) strategy.copy(LocatorUtils.property(locator, "person", sourcePerson), sourcePerson, this.isSetPerson()));
                        copy.setPerson(copyPerson);
                    } else {
                        if (personShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.person = null;
                        }
                    }
                }
                {
                    Boolean organizationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOrganization());
                    if (organizationShouldBeCopiedAndSet == Boolean.TRUE) {
                        OrganizationType sourceOrganization;
                        sourceOrganization = this.getOrganization();
                        OrganizationType copyOrganization = ((OrganizationType) strategy.copy(LocatorUtils.property(locator, "organization", sourceOrganization), sourceOrganization, this.isSetOrganization()));
                        copy.setOrganization(copyOrganization);
                    } else {
                        if (organizationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.organization = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassification());
                    if (classificationShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll sourceClassification;
                        sourceClassification = this.getClassification();
                        CVEnumISMClassificationAll copyClassification = ((CVEnumISMClassificationAll) strategy.copy(LocatorUtils.property(locator, "classification", sourceClassification), sourceClassification, this.isSetClassification()));
                        copy.setClassification(copyClassification);
                    } else {
                        if (classificationShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetOwnerProducer());
                    if (ownerProducerShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceOwnerProducer;
                        sourceOwnerProducer = (this.isSetOwnerProducer()?this.getOwnerProducer():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyOwnerProducer = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "ownerProducer", sourceOwnerProducer), sourceOwnerProducer, this.isSetOwnerProducer()));
                        copy.unsetOwnerProducer();
                        if (copyOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = copy.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(copyOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetJoint());
                    if (jointShouldBeCopiedAndSet == Boolean.TRUE) {
                        boolean sourceJoint;
                        sourceJoint = (this.isSetJoint()?this.getJoint():false);
                        boolean copyJoint = strategy.copy(LocatorUtils.property(locator, "joint", sourceJoint), sourceJoint, this.isSetJoint());
                        copy.setJoint(copyJoint);
                    } else {
                        if (jointShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSCIcontrols());
                    if (scIcontrolsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> sourceSCIcontrols;
                        sourceSCIcontrols = (this.isSetSCIcontrols()?this.getSCIcontrols():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMSCIControlsValues> copySCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.copy(LocatorUtils.property(locator, "scIcontrols", sourceSCIcontrols), sourceSCIcontrols, this.isSetSCIcontrols()));
                        copy.unsetSCIcontrols();
                        if (copySCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = copy.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(copySCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetSARIdentifier());
                    if (sarIdentifierShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceSARIdentifier;
                        sourceSARIdentifier = (this.isSetSARIdentifier()?this.getSARIdentifier():null);
                        @SuppressWarnings("unchecked")
                        List<String> copySARIdentifier = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "sarIdentifier", sourceSARIdentifier), sourceSARIdentifier, this.isSetSARIdentifier()));
                        copy.unsetSARIdentifier();
                        if (copySARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = copy.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(copySARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceAtomicEnergyMarkings;
                        sourceAtomicEnergyMarkings = (this.isSetAtomicEnergyMarkings()?this.getAtomicEnergyMarkings():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyAtomicEnergyMarkings = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "atomicEnergyMarkings", sourceAtomicEnergyMarkings), sourceAtomicEnergyMarkings, this.isSetAtomicEnergyMarkings()));
                        copy.unsetAtomicEnergyMarkings();
                        if (copyAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = copy.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(copyAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisseminationControls());
                    if (disseminationControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> sourceDisseminationControls;
                        sourceDisseminationControls = (this.isSetDisseminationControls()?this.getDisseminationControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMDissemValues> copyDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.copy(LocatorUtils.property(locator, "disseminationControls", sourceDisseminationControls), sourceDisseminationControls, this.isSetDisseminationControls()));
                        copy.unsetDisseminationControls();
                        if (copyDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = copy.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(copyDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceDisplayOnlyTo;
                        sourceDisplayOnlyTo = (this.isSetDisplayOnlyTo()?this.getDisplayOnlyTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyDisplayOnlyTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "displayOnlyTo", sourceDisplayOnlyTo), sourceDisplayOnlyTo, this.isSetDisplayOnlyTo()));
                        copy.unsetDisplayOnlyTo();
                        if (copyDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = copy.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(copyDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceOpen;
                        sourceFGIsourceOpen = (this.isSetFGIsourceOpen()?this.getFGIsourceOpen():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceOpen = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceOpen", sourceFGIsourceOpen), sourceFGIsourceOpen, this.isSetFGIsourceOpen()));
                        copy.unsetFGIsourceOpen();
                        if (copyFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = copy.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(copyFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceFGIsourceProtected;
                        sourceFGIsourceProtected = (this.isSetFGIsourceProtected()?this.getFGIsourceProtected():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyFGIsourceProtected = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "fgIsourceProtected", sourceFGIsourceProtected), sourceFGIsourceProtected, this.isSetFGIsourceProtected()));
                        copy.unsetFGIsourceProtected();
                        if (copyFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = copy.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(copyFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetReleasableTo());
                    if (releasableToShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<String> sourceReleasableTo;
                        sourceReleasableTo = (this.isSetReleasableTo()?this.getReleasableTo():null);
                        @SuppressWarnings("unchecked")
                        List<String> copyReleasableTo = ((List<String> ) strategy.copy(LocatorUtils.property(locator, "releasableTo", sourceReleasableTo), sourceReleasableTo, this.isSetReleasableTo()));
                        copy.unsetReleasableTo();
                        if (copyReleasableTo!= null) {
                            List<String> uniqueReleasableTol = copy.getReleasableTo();
                            uniqueReleasableTol.addAll(copyReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> sourceNonICmarkings;
                        sourceNonICmarkings = (this.isSetNonICmarkings()?this.getNonICmarkings():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonICValues> copyNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.copy(LocatorUtils.property(locator, "nonICmarkings", sourceNonICmarkings), sourceNonICmarkings, this.isSetNonICmarkings()));
                        copy.unsetNonICmarkings();
                        if (copyNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = copy.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(copyNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassifiedBy());
                    if (classifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassifiedBy;
                        sourceClassifiedBy = this.getClassifiedBy();
                        String copyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "classifiedBy", sourceClassifiedBy), sourceClassifiedBy, this.isSetClassifiedBy()));
                        copy.setClassifiedBy(copyClassifiedBy);
                    } else {
                        if (classifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetCompilationReason());
                    if (compilationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceCompilationReason;
                        sourceCompilationReason = this.getCompilationReason();
                        String copyCompilationReason = ((String) strategy.copy(LocatorUtils.property(locator, "compilationReason", sourceCompilationReason), sourceCompilationReason, this.isSetCompilationReason()));
                        copy.setCompilationReason(copyCompilationReason);
                    } else {
                        if (compilationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivativelyClassifiedBy;
                        sourceDerivativelyClassifiedBy = this.getDerivativelyClassifiedBy();
                        String copyDerivativelyClassifiedBy = ((String) strategy.copy(LocatorUtils.property(locator, "derivativelyClassifiedBy", sourceDerivativelyClassifiedBy), sourceDerivativelyClassifiedBy, this.isSetDerivativelyClassifiedBy()));
                        copy.setDerivativelyClassifiedBy(copyDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetClassificationReason());
                    if (classificationReasonShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceClassificationReason;
                        sourceClassificationReason = this.getClassificationReason();
                        String copyClassificationReason = ((String) strategy.copy(LocatorUtils.property(locator, "classificationReason", sourceClassificationReason), sourceClassificationReason, this.isSetClassificationReason()));
                        copy.setClassificationReason(copyClassificationReason);
                    } else {
                        if (classificationReasonShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNonUSControls());
                    if (nonUSControlsShouldBeCopiedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> sourceNonUSControls;
                        sourceNonUSControls = (this.isSetNonUSControls()?this.getNonUSControls():null);
                        @SuppressWarnings("unchecked")
                        List<CVEnumISMNonUSControlsValues> copyNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.copy(LocatorUtils.property(locator, "nonUSControls", sourceNonUSControls), sourceNonUSControls, this.isSetNonUSControls()));
                        copy.unsetNonUSControls();
                        if (copyNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = copy.getNonUSControls();
                            uniqueNonUSControlsl.addAll(copyNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDerivedFrom());
                    if (derivedFromShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDerivedFrom;
                        sourceDerivedFrom = this.getDerivedFrom();
                        String copyDerivedFrom = ((String) strategy.copy(LocatorUtils.property(locator, "derivedFrom", sourceDerivedFrom), sourceDerivedFrom, this.isSetDerivedFrom()));
                        copy.setDerivedFrom(copyDerivedFrom);
                    } else {
                        if (derivedFromShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassDate());
                    if (declassDateShouldBeCopiedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar sourceDeclassDate;
                        sourceDeclassDate = this.getDeclassDate();
                        XMLGregorianCalendar copyDeclassDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "declassDate", sourceDeclassDate), sourceDeclassDate, this.isSetDeclassDate()));
                        copy.setDeclassDate(copyDeclassDate);
                    } else {
                        if (declassDateShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassEvent());
                    if (declassEventShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceDeclassEvent;
                        sourceDeclassEvent = this.getDeclassEvent();
                        String copyDeclassEvent = ((String) strategy.copy(LocatorUtils.property(locator, "declassEvent", sourceDeclassEvent), sourceDeclassEvent, this.isSetDeclassEvent()));
                        copy.setDeclassEvent(copyDeclassEvent);
                    } else {
                        if (declassEventShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetDeclassException());
                    if (declassExceptionShouldBeCopiedAndSet == Boolean.TRUE) {
                        CVEnumISM25X sourceDeclassException;
                        sourceDeclassException = this.getDeclassException();
                        CVEnumISM25X copyDeclassException = ((CVEnumISM25X) strategy.copy(LocatorUtils.property(locator, "declassException", sourceDeclassException), sourceDeclassException, this.isSetDeclassException()));
                        copy.setDeclassException(copyDeclassException);
                    } else {
                        if (declassExceptionShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.declassException = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new TaskingInfoType.RequesterInfo();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof TaskingInfoType.RequesterInfo) {
                final TaskingInfoType.RequesterInfo target = this;
                final TaskingInfoType.RequesterInfo leftObject = ((TaskingInfoType.RequesterInfo) left);
                final TaskingInfoType.RequesterInfo rightObject = ((TaskingInfoType.RequesterInfo) right);
                {
                    Boolean personShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPerson(), rightObject.isSetPerson());
                    if (personShouldBeMergedAndSet == Boolean.TRUE) {
                        PersonType lhsPerson;
                        lhsPerson = leftObject.getPerson();
                        PersonType rhsPerson;
                        rhsPerson = rightObject.getPerson();
                        PersonType mergedPerson = ((PersonType) strategy.merge(LocatorUtils.property(leftLocator, "person", lhsPerson), LocatorUtils.property(rightLocator, "person", rhsPerson), lhsPerson, rhsPerson, leftObject.isSetPerson(), rightObject.isSetPerson()));
                        target.setPerson(mergedPerson);
                    } else {
                        if (personShouldBeMergedAndSet == Boolean.FALSE) {
                            target.person = null;
                        }
                    }
                }
                {
                    Boolean organizationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOrganization(), rightObject.isSetOrganization());
                    if (organizationShouldBeMergedAndSet == Boolean.TRUE) {
                        OrganizationType lhsOrganization;
                        lhsOrganization = leftObject.getOrganization();
                        OrganizationType rhsOrganization;
                        rhsOrganization = rightObject.getOrganization();
                        OrganizationType mergedOrganization = ((OrganizationType) strategy.merge(LocatorUtils.property(leftLocator, "organization", lhsOrganization), LocatorUtils.property(rightLocator, "organization", rhsOrganization), lhsOrganization, rhsOrganization, leftObject.isSetOrganization(), rightObject.isSetOrganization()));
                        target.setOrganization(mergedOrganization);
                    } else {
                        if (organizationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.organization = null;
                        }
                    }
                }
                {
                    Boolean classificationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassification(), rightObject.isSetClassification());
                    if (classificationShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISMClassificationAll lhsClassification;
                        lhsClassification = leftObject.getClassification();
                        CVEnumISMClassificationAll rhsClassification;
                        rhsClassification = rightObject.getClassification();
                        CVEnumISMClassificationAll mergedClassification = ((CVEnumISMClassificationAll) strategy.merge(LocatorUtils.property(leftLocator, "classification", lhsClassification), LocatorUtils.property(rightLocator, "classification", rhsClassification), lhsClassification, rhsClassification, leftObject.isSetClassification(), rightObject.isSetClassification()));
                        target.setClassification(mergedClassification);
                    } else {
                        if (classificationShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classification = null;
                        }
                    }
                }
                {
                    Boolean ownerProducerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer());
                    if (ownerProducerShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsOwnerProducer;
                        lhsOwnerProducer = (leftObject.isSetOwnerProducer()?leftObject.getOwnerProducer():null);
                        List<String> rhsOwnerProducer;
                        rhsOwnerProducer = (rightObject.isSetOwnerProducer()?rightObject.getOwnerProducer():null);
                        List<String> mergedOwnerProducer = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "ownerProducer", lhsOwnerProducer), LocatorUtils.property(rightLocator, "ownerProducer", rhsOwnerProducer), lhsOwnerProducer, rhsOwnerProducer, leftObject.isSetOwnerProducer(), rightObject.isSetOwnerProducer()));
                        target.unsetOwnerProducer();
                        if (mergedOwnerProducer!= null) {
                            List<String> uniqueOwnerProducerl = target.getOwnerProducer();
                            uniqueOwnerProducerl.addAll(mergedOwnerProducer);
                        }
                    } else {
                        if (ownerProducerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetOwnerProducer();
                        }
                    }
                }
                {
                    Boolean jointShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetJoint(), rightObject.isSetJoint());
                    if (jointShouldBeMergedAndSet == Boolean.TRUE) {
                        boolean lhsJoint;
                        lhsJoint = (leftObject.isSetJoint()?leftObject.getJoint():false);
                        boolean rhsJoint;
                        rhsJoint = (rightObject.isSetJoint()?rightObject.getJoint():false);
                        boolean mergedJoint = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "joint", lhsJoint), LocatorUtils.property(rightLocator, "joint", rhsJoint), lhsJoint, rhsJoint, leftObject.isSetJoint(), rightObject.isSetJoint()));
                        target.setJoint(mergedJoint);
                    } else {
                        if (jointShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetJoint();
                        }
                    }
                }
                {
                    Boolean scIcontrolsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols());
                    if (scIcontrolsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMSCIControlsValues> lhsSCIcontrols;
                        lhsSCIcontrols = (leftObject.isSetSCIcontrols()?leftObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> rhsSCIcontrols;
                        rhsSCIcontrols = (rightObject.isSetSCIcontrols()?rightObject.getSCIcontrols():null);
                        List<CVEnumISMSCIControlsValues> mergedSCIcontrols = ((List<CVEnumISMSCIControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "scIcontrols", lhsSCIcontrols), LocatorUtils.property(rightLocator, "scIcontrols", rhsSCIcontrols), lhsSCIcontrols, rhsSCIcontrols, leftObject.isSetSCIcontrols(), rightObject.isSetSCIcontrols()));
                        target.unsetSCIcontrols();
                        if (mergedSCIcontrols!= null) {
                            List<CVEnumISMSCIControlsValues> uniqueSCIcontrolsl = target.getSCIcontrols();
                            uniqueSCIcontrolsl.addAll(mergedSCIcontrols);
                        }
                    } else {
                        if (scIcontrolsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSCIcontrols();
                        }
                    }
                }
                {
                    Boolean sarIdentifierShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier());
                    if (sarIdentifierShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsSARIdentifier;
                        lhsSARIdentifier = (leftObject.isSetSARIdentifier()?leftObject.getSARIdentifier():null);
                        List<String> rhsSARIdentifier;
                        rhsSARIdentifier = (rightObject.isSetSARIdentifier()?rightObject.getSARIdentifier():null);
                        List<String> mergedSARIdentifier = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "sarIdentifier", lhsSARIdentifier), LocatorUtils.property(rightLocator, "sarIdentifier", rhsSARIdentifier), lhsSARIdentifier, rhsSARIdentifier, leftObject.isSetSARIdentifier(), rightObject.isSetSARIdentifier()));
                        target.unsetSARIdentifier();
                        if (mergedSARIdentifier!= null) {
                            List<String> uniqueSARIdentifierl = target.getSARIdentifier();
                            uniqueSARIdentifierl.addAll(mergedSARIdentifier);
                        }
                    } else {
                        if (sarIdentifierShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetSARIdentifier();
                        }
                    }
                }
                {
                    Boolean atomicEnergyMarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings());
                    if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsAtomicEnergyMarkings;
                        lhsAtomicEnergyMarkings = (leftObject.isSetAtomicEnergyMarkings()?leftObject.getAtomicEnergyMarkings():null);
                        List<String> rhsAtomicEnergyMarkings;
                        rhsAtomicEnergyMarkings = (rightObject.isSetAtomicEnergyMarkings()?rightObject.getAtomicEnergyMarkings():null);
                        List<String> mergedAtomicEnergyMarkings = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "atomicEnergyMarkings", lhsAtomicEnergyMarkings), LocatorUtils.property(rightLocator, "atomicEnergyMarkings", rhsAtomicEnergyMarkings), lhsAtomicEnergyMarkings, rhsAtomicEnergyMarkings, leftObject.isSetAtomicEnergyMarkings(), rightObject.isSetAtomicEnergyMarkings()));
                        target.unsetAtomicEnergyMarkings();
                        if (mergedAtomicEnergyMarkings!= null) {
                            List<String> uniqueAtomicEnergyMarkingsl = target.getAtomicEnergyMarkings();
                            uniqueAtomicEnergyMarkingsl.addAll(mergedAtomicEnergyMarkings);
                        }
                    } else {
                        if (atomicEnergyMarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetAtomicEnergyMarkings();
                        }
                    }
                }
                {
                    Boolean disseminationControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls());
                    if (disseminationControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMDissemValues> lhsDisseminationControls;
                        lhsDisseminationControls = (leftObject.isSetDisseminationControls()?leftObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> rhsDisseminationControls;
                        rhsDisseminationControls = (rightObject.isSetDisseminationControls()?rightObject.getDisseminationControls():null);
                        List<CVEnumISMDissemValues> mergedDisseminationControls = ((List<CVEnumISMDissemValues> ) strategy.merge(LocatorUtils.property(leftLocator, "disseminationControls", lhsDisseminationControls), LocatorUtils.property(rightLocator, "disseminationControls", rhsDisseminationControls), lhsDisseminationControls, rhsDisseminationControls, leftObject.isSetDisseminationControls(), rightObject.isSetDisseminationControls()));
                        target.unsetDisseminationControls();
                        if (mergedDisseminationControls!= null) {
                            List<CVEnumISMDissemValues> uniqueDisseminationControlsl = target.getDisseminationControls();
                            uniqueDisseminationControlsl.addAll(mergedDisseminationControls);
                        }
                    } else {
                        if (disseminationControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisseminationControls();
                        }
                    }
                }
                {
                    Boolean displayOnlyToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo());
                    if (displayOnlyToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsDisplayOnlyTo;
                        lhsDisplayOnlyTo = (leftObject.isSetDisplayOnlyTo()?leftObject.getDisplayOnlyTo():null);
                        List<String> rhsDisplayOnlyTo;
                        rhsDisplayOnlyTo = (rightObject.isSetDisplayOnlyTo()?rightObject.getDisplayOnlyTo():null);
                        List<String> mergedDisplayOnlyTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "displayOnlyTo", lhsDisplayOnlyTo), LocatorUtils.property(rightLocator, "displayOnlyTo", rhsDisplayOnlyTo), lhsDisplayOnlyTo, rhsDisplayOnlyTo, leftObject.isSetDisplayOnlyTo(), rightObject.isSetDisplayOnlyTo()));
                        target.unsetDisplayOnlyTo();
                        if (mergedDisplayOnlyTo!= null) {
                            List<String> uniqueDisplayOnlyTol = target.getDisplayOnlyTo();
                            uniqueDisplayOnlyTol.addAll(mergedDisplayOnlyTo);
                        }
                    } else {
                        if (displayOnlyToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetDisplayOnlyTo();
                        }
                    }
                }
                {
                    Boolean fgIsourceOpenShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen());
                    if (fgIsourceOpenShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceOpen;
                        lhsFGIsourceOpen = (leftObject.isSetFGIsourceOpen()?leftObject.getFGIsourceOpen():null);
                        List<String> rhsFGIsourceOpen;
                        rhsFGIsourceOpen = (rightObject.isSetFGIsourceOpen()?rightObject.getFGIsourceOpen():null);
                        List<String> mergedFGIsourceOpen = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceOpen", lhsFGIsourceOpen), LocatorUtils.property(rightLocator, "fgIsourceOpen", rhsFGIsourceOpen), lhsFGIsourceOpen, rhsFGIsourceOpen, leftObject.isSetFGIsourceOpen(), rightObject.isSetFGIsourceOpen()));
                        target.unsetFGIsourceOpen();
                        if (mergedFGIsourceOpen!= null) {
                            List<String> uniqueFGIsourceOpenl = target.getFGIsourceOpen();
                            uniqueFGIsourceOpenl.addAll(mergedFGIsourceOpen);
                        }
                    } else {
                        if (fgIsourceOpenShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceOpen();
                        }
                    }
                }
                {
                    Boolean fgIsourceProtectedShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected());
                    if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsFGIsourceProtected;
                        lhsFGIsourceProtected = (leftObject.isSetFGIsourceProtected()?leftObject.getFGIsourceProtected():null);
                        List<String> rhsFGIsourceProtected;
                        rhsFGIsourceProtected = (rightObject.isSetFGIsourceProtected()?rightObject.getFGIsourceProtected():null);
                        List<String> mergedFGIsourceProtected = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "fgIsourceProtected", lhsFGIsourceProtected), LocatorUtils.property(rightLocator, "fgIsourceProtected", rhsFGIsourceProtected), lhsFGIsourceProtected, rhsFGIsourceProtected, leftObject.isSetFGIsourceProtected(), rightObject.isSetFGIsourceProtected()));
                        target.unsetFGIsourceProtected();
                        if (mergedFGIsourceProtected!= null) {
                            List<String> uniqueFGIsourceProtectedl = target.getFGIsourceProtected();
                            uniqueFGIsourceProtectedl.addAll(mergedFGIsourceProtected);
                        }
                    } else {
                        if (fgIsourceProtectedShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetFGIsourceProtected();
                        }
                    }
                }
                {
                    Boolean releasableToShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo());
                    if (releasableToShouldBeMergedAndSet == Boolean.TRUE) {
                        List<String> lhsReleasableTo;
                        lhsReleasableTo = (leftObject.isSetReleasableTo()?leftObject.getReleasableTo():null);
                        List<String> rhsReleasableTo;
                        rhsReleasableTo = (rightObject.isSetReleasableTo()?rightObject.getReleasableTo():null);
                        List<String> mergedReleasableTo = ((List<String> ) strategy.merge(LocatorUtils.property(leftLocator, "releasableTo", lhsReleasableTo), LocatorUtils.property(rightLocator, "releasableTo", rhsReleasableTo), lhsReleasableTo, rhsReleasableTo, leftObject.isSetReleasableTo(), rightObject.isSetReleasableTo()));
                        target.unsetReleasableTo();
                        if (mergedReleasableTo!= null) {
                            List<String> uniqueReleasableTol = target.getReleasableTo();
                            uniqueReleasableTol.addAll(mergedReleasableTo);
                        }
                    } else {
                        if (releasableToShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetReleasableTo();
                        }
                    }
                }
                {
                    Boolean nonICmarkingsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings());
                    if (nonICmarkingsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonICValues> lhsNonICmarkings;
                        lhsNonICmarkings = (leftObject.isSetNonICmarkings()?leftObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> rhsNonICmarkings;
                        rhsNonICmarkings = (rightObject.isSetNonICmarkings()?rightObject.getNonICmarkings():null);
                        List<CVEnumISMNonICValues> mergedNonICmarkings = ((List<CVEnumISMNonICValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonICmarkings", lhsNonICmarkings), LocatorUtils.property(rightLocator, "nonICmarkings", rhsNonICmarkings), lhsNonICmarkings, rhsNonICmarkings, leftObject.isSetNonICmarkings(), rightObject.isSetNonICmarkings()));
                        target.unsetNonICmarkings();
                        if (mergedNonICmarkings!= null) {
                            List<CVEnumISMNonICValues> uniqueNonICmarkingsl = target.getNonICmarkings();
                            uniqueNonICmarkingsl.addAll(mergedNonICmarkings);
                        }
                    } else {
                        if (nonICmarkingsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonICmarkings();
                        }
                    }
                }
                {
                    Boolean classifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy());
                    if (classifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassifiedBy;
                        lhsClassifiedBy = leftObject.getClassifiedBy();
                        String rhsClassifiedBy;
                        rhsClassifiedBy = rightObject.getClassifiedBy();
                        String mergedClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classifiedBy", lhsClassifiedBy), LocatorUtils.property(rightLocator, "classifiedBy", rhsClassifiedBy), lhsClassifiedBy, rhsClassifiedBy, leftObject.isSetClassifiedBy(), rightObject.isSetClassifiedBy()));
                        target.setClassifiedBy(mergedClassifiedBy);
                    } else {
                        if (classifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classifiedBy = null;
                        }
                    }
                }
                {
                    Boolean compilationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason());
                    if (compilationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsCompilationReason;
                        lhsCompilationReason = leftObject.getCompilationReason();
                        String rhsCompilationReason;
                        rhsCompilationReason = rightObject.getCompilationReason();
                        String mergedCompilationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "compilationReason", lhsCompilationReason), LocatorUtils.property(rightLocator, "compilationReason", rhsCompilationReason), lhsCompilationReason, rhsCompilationReason, leftObject.isSetCompilationReason(), rightObject.isSetCompilationReason()));
                        target.setCompilationReason(mergedCompilationReason);
                    } else {
                        if (compilationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.compilationReason = null;
                        }
                    }
                }
                {
                    Boolean derivativelyClassifiedByShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy());
                    if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivativelyClassifiedBy;
                        lhsDerivativelyClassifiedBy = leftObject.getDerivativelyClassifiedBy();
                        String rhsDerivativelyClassifiedBy;
                        rhsDerivativelyClassifiedBy = rightObject.getDerivativelyClassifiedBy();
                        String mergedDerivativelyClassifiedBy = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivativelyClassifiedBy", lhsDerivativelyClassifiedBy), LocatorUtils.property(rightLocator, "derivativelyClassifiedBy", rhsDerivativelyClassifiedBy), lhsDerivativelyClassifiedBy, rhsDerivativelyClassifiedBy, leftObject.isSetDerivativelyClassifiedBy(), rightObject.isSetDerivativelyClassifiedBy()));
                        target.setDerivativelyClassifiedBy(mergedDerivativelyClassifiedBy);
                    } else {
                        if (derivativelyClassifiedByShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivativelyClassifiedBy = null;
                        }
                    }
                }
                {
                    Boolean classificationReasonShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason());
                    if (classificationReasonShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsClassificationReason;
                        lhsClassificationReason = leftObject.getClassificationReason();
                        String rhsClassificationReason;
                        rhsClassificationReason = rightObject.getClassificationReason();
                        String mergedClassificationReason = ((String) strategy.merge(LocatorUtils.property(leftLocator, "classificationReason", lhsClassificationReason), LocatorUtils.property(rightLocator, "classificationReason", rhsClassificationReason), lhsClassificationReason, rhsClassificationReason, leftObject.isSetClassificationReason(), rightObject.isSetClassificationReason()));
                        target.setClassificationReason(mergedClassificationReason);
                    } else {
                        if (classificationReasonShouldBeMergedAndSet == Boolean.FALSE) {
                            target.classificationReason = null;
                        }
                    }
                }
                {
                    Boolean nonUSControlsShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls());
                    if (nonUSControlsShouldBeMergedAndSet == Boolean.TRUE) {
                        List<CVEnumISMNonUSControlsValues> lhsNonUSControls;
                        lhsNonUSControls = (leftObject.isSetNonUSControls()?leftObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> rhsNonUSControls;
                        rhsNonUSControls = (rightObject.isSetNonUSControls()?rightObject.getNonUSControls():null);
                        List<CVEnumISMNonUSControlsValues> mergedNonUSControls = ((List<CVEnumISMNonUSControlsValues> ) strategy.merge(LocatorUtils.property(leftLocator, "nonUSControls", lhsNonUSControls), LocatorUtils.property(rightLocator, "nonUSControls", rhsNonUSControls), lhsNonUSControls, rhsNonUSControls, leftObject.isSetNonUSControls(), rightObject.isSetNonUSControls()));
                        target.unsetNonUSControls();
                        if (mergedNonUSControls!= null) {
                            List<CVEnumISMNonUSControlsValues> uniqueNonUSControlsl = target.getNonUSControls();
                            uniqueNonUSControlsl.addAll(mergedNonUSControls);
                        }
                    } else {
                        if (nonUSControlsShouldBeMergedAndSet == Boolean.FALSE) {
                            target.unsetNonUSControls();
                        }
                    }
                }
                {
                    Boolean derivedFromShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom());
                    if (derivedFromShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDerivedFrom;
                        lhsDerivedFrom = leftObject.getDerivedFrom();
                        String rhsDerivedFrom;
                        rhsDerivedFrom = rightObject.getDerivedFrom();
                        String mergedDerivedFrom = ((String) strategy.merge(LocatorUtils.property(leftLocator, "derivedFrom", lhsDerivedFrom), LocatorUtils.property(rightLocator, "derivedFrom", rhsDerivedFrom), lhsDerivedFrom, rhsDerivedFrom, leftObject.isSetDerivedFrom(), rightObject.isSetDerivedFrom()));
                        target.setDerivedFrom(mergedDerivedFrom);
                    } else {
                        if (derivedFromShouldBeMergedAndSet == Boolean.FALSE) {
                            target.derivedFrom = null;
                        }
                    }
                }
                {
                    Boolean declassDateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate());
                    if (declassDateShouldBeMergedAndSet == Boolean.TRUE) {
                        XMLGregorianCalendar lhsDeclassDate;
                        lhsDeclassDate = leftObject.getDeclassDate();
                        XMLGregorianCalendar rhsDeclassDate;
                        rhsDeclassDate = rightObject.getDeclassDate();
                        XMLGregorianCalendar mergedDeclassDate = ((XMLGregorianCalendar) strategy.merge(LocatorUtils.property(leftLocator, "declassDate", lhsDeclassDate), LocatorUtils.property(rightLocator, "declassDate", rhsDeclassDate), lhsDeclassDate, rhsDeclassDate, leftObject.isSetDeclassDate(), rightObject.isSetDeclassDate()));
                        target.setDeclassDate(mergedDeclassDate);
                    } else {
                        if (declassDateShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassDate = null;
                        }
                    }
                }
                {
                    Boolean declassEventShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent());
                    if (declassEventShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsDeclassEvent;
                        lhsDeclassEvent = leftObject.getDeclassEvent();
                        String rhsDeclassEvent;
                        rhsDeclassEvent = rightObject.getDeclassEvent();
                        String mergedDeclassEvent = ((String) strategy.merge(LocatorUtils.property(leftLocator, "declassEvent", lhsDeclassEvent), LocatorUtils.property(rightLocator, "declassEvent", rhsDeclassEvent), lhsDeclassEvent, rhsDeclassEvent, leftObject.isSetDeclassEvent(), rightObject.isSetDeclassEvent()));
                        target.setDeclassEvent(mergedDeclassEvent);
                    } else {
                        if (declassEventShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassEvent = null;
                        }
                    }
                }
                {
                    Boolean declassExceptionShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetDeclassException(), rightObject.isSetDeclassException());
                    if (declassExceptionShouldBeMergedAndSet == Boolean.TRUE) {
                        CVEnumISM25X lhsDeclassException;
                        lhsDeclassException = leftObject.getDeclassException();
                        CVEnumISM25X rhsDeclassException;
                        rhsDeclassException = rightObject.getDeclassException();
                        CVEnumISM25X mergedDeclassException = ((CVEnumISM25X) strategy.merge(LocatorUtils.property(leftLocator, "declassException", lhsDeclassException), LocatorUtils.property(rightLocator, "declassException", rhsDeclassException), lhsDeclassException, rhsDeclassException, leftObject.isSetDeclassException(), rightObject.isSetDeclassException()));
                        target.setDeclassException(mergedDeclassException);
                    } else {
                        if (declassExceptionShouldBeMergedAndSet == Boolean.FALSE) {
                            target.declassException = null;
                        }
                    }
                }
            }
        }

        public void setOwnerProducer(List<String> value) {
            this.ownerProducer = null;
            if (value!= null) {
                List<String> draftl = this.getOwnerProducer();
                draftl.addAll(value);
            }
        }

        public void setSCIcontrols(List<CVEnumISMSCIControlsValues> value) {
            this.scIcontrols = null;
            if (value!= null) {
                List<CVEnumISMSCIControlsValues> draftl = this.getSCIcontrols();
                draftl.addAll(value);
            }
        }

        public void setSARIdentifier(List<String> value) {
            this.sarIdentifier = null;
            if (value!= null) {
                List<String> draftl = this.getSARIdentifier();
                draftl.addAll(value);
            }
        }

        public void setAtomicEnergyMarkings(List<String> value) {
            this.atomicEnergyMarkings = null;
            if (value!= null) {
                List<String> draftl = this.getAtomicEnergyMarkings();
                draftl.addAll(value);
            }
        }

        public void setDisseminationControls(List<CVEnumISMDissemValues> value) {
            this.disseminationControls = null;
            if (value!= null) {
                List<CVEnumISMDissemValues> draftl = this.getDisseminationControls();
                draftl.addAll(value);
            }
        }

        public void setDisplayOnlyTo(List<String> value) {
            this.displayOnlyTo = null;
            if (value!= null) {
                List<String> draftl = this.getDisplayOnlyTo();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceOpen(List<String> value) {
            this.fgIsourceOpen = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceOpen();
                draftl.addAll(value);
            }
        }

        public void setFGIsourceProtected(List<String> value) {
            this.fgIsourceProtected = null;
            if (value!= null) {
                List<String> draftl = this.getFGIsourceProtected();
                draftl.addAll(value);
            }
        }

        public void setReleasableTo(List<String> value) {
            this.releasableTo = null;
            if (value!= null) {
                List<String> draftl = this.getReleasableTo();
                draftl.addAll(value);
            }
        }

        public void setNonICmarkings(List<CVEnumISMNonICValues> value) {
            this.nonICmarkings = null;
            if (value!= null) {
                List<CVEnumISMNonICValues> draftl = this.getNonICmarkings();
                draftl.addAll(value);
            }
        }

        public void setNonUSControls(List<CVEnumISMNonUSControlsValues> value) {
            this.nonUSControls = null;
            if (value!= null) {
                List<CVEnumISMNonUSControlsValues> draftl = this.getNonUSControls();
                draftl.addAll(value);
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;simpleContent&gt;
     *     &lt;extension base="&lt;urn:us:mil:ces:metadata:ddms:5&gt;simpleTokenType"&gt;
     *       &lt;attGroup ref="{urn:us:mil:ces:metadata:ddms:5}SimpleLinkAttributesGroup"/&gt;
     *       &lt;attribute name="taskingSystem" type="{urn:us:mil:ces:metadata:ddms:5}simpleTokenType" /&gt;
     *     &lt;/extension&gt;
     *   &lt;/simpleContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class TaskID implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlValue
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @Size(min = 1)
        protected String value;
        @XmlAttribute(name = "taskingSystem", namespace = "urn:us:mil:ces:metadata:ddms:5")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @Size(min = 1)
        protected String taskingSystem;
        @XmlAttribute(name = "type", namespace = "http://www.w3.org/1999/xlink")
        protected TypeType type;
        @XmlAttribute(name = "href", namespace = "http://www.w3.org/1999/xlink")
        protected String href;
        @XmlAttribute(name = "role", namespace = "http://www.w3.org/1999/xlink")
        @Size(min = 1)
        protected String role;
        @XmlAttribute(name = "arcrole", namespace = "http://www.w3.org/1999/xlink")
        @Size(min = 1)
        protected String arcrole;
        @XmlAttribute(name = "title", namespace = "http://www.w3.org/1999/xlink")
        protected String title;
        @XmlAttribute(name = "show", namespace = "http://www.w3.org/1999/xlink")
        protected ShowType show;
        @XmlAttribute(name = "actuate", namespace = "http://www.w3.org/1999/xlink")
        protected ActuateType actuate;
        @XmlAttribute(name = "network", namespace = "urn:us:gov:ic:virt")
        protected String network;

        /**
         * type created to ensure an element / attribute is comprised of more than whitespace, tab, newline, etc.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        public boolean isSetValue() {
            return (this.value!= null);
        }

        /**
         * Gets the value of the taskingSystem property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTaskingSystem() {
            return taskingSystem;
        }

        /**
         * Sets the value of the taskingSystem property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTaskingSystem(String value) {
            this.taskingSystem = value;
        }

        public boolean isSetTaskingSystem() {
            return (this.taskingSystem!= null);
        }

        /**
         * Gets the value of the type property.
         * 
         * @return
         *     possible object is
         *     {@link TypeType }
         *     
         */
        public TypeType getType() {
            return type;
        }

        /**
         * Sets the value of the type property.
         * 
         * @param value
         *     allowed object is
         *     {@link TypeType }
         *     
         */
        public void setType(TypeType value) {
            this.type = value;
        }

        public boolean isSetType() {
            return (this.type!= null);
        }

        /**
         * Gets the value of the href property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getHref() {
            return href;
        }

        /**
         * Sets the value of the href property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setHref(String value) {
            this.href = value;
        }

        public boolean isSetHref() {
            return (this.href!= null);
        }

        /**
         * Gets the value of the role property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getRole() {
            return role;
        }

        /**
         * Sets the value of the role property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setRole(String value) {
            this.role = value;
        }

        public boolean isSetRole() {
            return (this.role!= null);
        }

        /**
         * Gets the value of the arcrole property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getArcrole() {
            return arcrole;
        }

        /**
         * Sets the value of the arcrole property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setArcrole(String value) {
            this.arcrole = value;
        }

        public boolean isSetArcrole() {
            return (this.arcrole!= null);
        }

        /**
         * Gets the value of the title property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTitle() {
            return title;
        }

        /**
         * Sets the value of the title property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTitle(String value) {
            this.title = value;
        }

        public boolean isSetTitle() {
            return (this.title!= null);
        }

        /**
         * Gets the value of the show property.
         * 
         * @return
         *     possible object is
         *     {@link ShowType }
         *     
         */
        public ShowType getShow() {
            return show;
        }

        /**
         * Sets the value of the show property.
         * 
         * @param value
         *     allowed object is
         *     {@link ShowType }
         *     
         */
        public void setShow(ShowType value) {
            this.show = value;
        }

        public boolean isSetShow() {
            return (this.show!= null);
        }

        /**
         * Gets the value of the actuate property.
         * 
         * @return
         *     possible object is
         *     {@link ActuateType }
         *     
         */
        public ActuateType getActuate() {
            return actuate;
        }

        /**
         * Sets the value of the actuate property.
         * 
         * @param value
         *     allowed object is
         *     {@link ActuateType }
         *     
         */
        public void setActuate(ActuateType value) {
            this.actuate = value;
        }

        public boolean isSetActuate() {
            return (this.actuate!= null);
        }

        /**
         * Gets the value of the network property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getNetwork() {
            return network;
        }

        /**
         * Sets the value of the network property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setNetwork(String value) {
            this.network = value;
        }

        public boolean isSetNetwork() {
            return (this.network!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                String theValue;
                theValue = this.getValue();
                strategy.appendField(locator, this, "value", buffer, theValue, this.isSetValue());
            }
            {
                String theTaskingSystem;
                theTaskingSystem = this.getTaskingSystem();
                strategy.appendField(locator, this, "taskingSystem", buffer, theTaskingSystem, this.isSetTaskingSystem());
            }
            {
                TypeType theType;
                theType = this.getType();
                strategy.appendField(locator, this, "type", buffer, theType, this.isSetType());
            }
            {
                String theHref;
                theHref = this.getHref();
                strategy.appendField(locator, this, "href", buffer, theHref, this.isSetHref());
            }
            {
                String theRole;
                theRole = this.getRole();
                strategy.appendField(locator, this, "role", buffer, theRole, this.isSetRole());
            }
            {
                String theArcrole;
                theArcrole = this.getArcrole();
                strategy.appendField(locator, this, "arcrole", buffer, theArcrole, this.isSetArcrole());
            }
            {
                String theTitle;
                theTitle = this.getTitle();
                strategy.appendField(locator, this, "title", buffer, theTitle, this.isSetTitle());
            }
            {
                ShowType theShow;
                theShow = this.getShow();
                strategy.appendField(locator, this, "show", buffer, theShow, this.isSetShow());
            }
            {
                ActuateType theActuate;
                theActuate = this.getActuate();
                strategy.appendField(locator, this, "actuate", buffer, theActuate, this.isSetActuate());
            }
            {
                String theNetwork;
                theNetwork = this.getNetwork();
                strategy.appendField(locator, this, "network", buffer, theNetwork, this.isSetNetwork());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final TaskingInfoType.TaskID that = ((TaskingInfoType.TaskID) object);
            {
                String lhsValue;
                lhsValue = this.getValue();
                String rhsValue;
                rhsValue = that.getValue();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "value", lhsValue), LocatorUtils.property(thatLocator, "value", rhsValue), lhsValue, rhsValue, this.isSetValue(), that.isSetValue())) {
                    return false;
                }
            }
            {
                String lhsTaskingSystem;
                lhsTaskingSystem = this.getTaskingSystem();
                String rhsTaskingSystem;
                rhsTaskingSystem = that.getTaskingSystem();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "taskingSystem", lhsTaskingSystem), LocatorUtils.property(thatLocator, "taskingSystem", rhsTaskingSystem), lhsTaskingSystem, rhsTaskingSystem, this.isSetTaskingSystem(), that.isSetTaskingSystem())) {
                    return false;
                }
            }
            {
                TypeType lhsType;
                lhsType = this.getType();
                TypeType rhsType;
                rhsType = that.getType();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "type", lhsType), LocatorUtils.property(thatLocator, "type", rhsType), lhsType, rhsType, this.isSetType(), that.isSetType())) {
                    return false;
                }
            }
            {
                String lhsHref;
                lhsHref = this.getHref();
                String rhsHref;
                rhsHref = that.getHref();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "href", lhsHref), LocatorUtils.property(thatLocator, "href", rhsHref), lhsHref, rhsHref, this.isSetHref(), that.isSetHref())) {
                    return false;
                }
            }
            {
                String lhsRole;
                lhsRole = this.getRole();
                String rhsRole;
                rhsRole = that.getRole();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "role", lhsRole), LocatorUtils.property(thatLocator, "role", rhsRole), lhsRole, rhsRole, this.isSetRole(), that.isSetRole())) {
                    return false;
                }
            }
            {
                String lhsArcrole;
                lhsArcrole = this.getArcrole();
                String rhsArcrole;
                rhsArcrole = that.getArcrole();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "arcrole", lhsArcrole), LocatorUtils.property(thatLocator, "arcrole", rhsArcrole), lhsArcrole, rhsArcrole, this.isSetArcrole(), that.isSetArcrole())) {
                    return false;
                }
            }
            {
                String lhsTitle;
                lhsTitle = this.getTitle();
                String rhsTitle;
                rhsTitle = that.getTitle();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "title", lhsTitle), LocatorUtils.property(thatLocator, "title", rhsTitle), lhsTitle, rhsTitle, this.isSetTitle(), that.isSetTitle())) {
                    return false;
                }
            }
            {
                ShowType lhsShow;
                lhsShow = this.getShow();
                ShowType rhsShow;
                rhsShow = that.getShow();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "show", lhsShow), LocatorUtils.property(thatLocator, "show", rhsShow), lhsShow, rhsShow, this.isSetShow(), that.isSetShow())) {
                    return false;
                }
            }
            {
                ActuateType lhsActuate;
                lhsActuate = this.getActuate();
                ActuateType rhsActuate;
                rhsActuate = that.getActuate();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "actuate", lhsActuate), LocatorUtils.property(thatLocator, "actuate", rhsActuate), lhsActuate, rhsActuate, this.isSetActuate(), that.isSetActuate())) {
                    return false;
                }
            }
            {
                String lhsNetwork;
                lhsNetwork = this.getNetwork();
                String rhsNetwork;
                rhsNetwork = that.getNetwork();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "network", lhsNetwork), LocatorUtils.property(thatLocator, "network", rhsNetwork), lhsNetwork, rhsNetwork, this.isSetNetwork(), that.isSetNetwork())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                String theValue;
                theValue = this.getValue();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "value", theValue), currentHashCode, theValue, this.isSetValue());
            }
            {
                String theTaskingSystem;
                theTaskingSystem = this.getTaskingSystem();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "taskingSystem", theTaskingSystem), currentHashCode, theTaskingSystem, this.isSetTaskingSystem());
            }
            {
                TypeType theType;
                theType = this.getType();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "type", theType), currentHashCode, theType, this.isSetType());
            }
            {
                String theHref;
                theHref = this.getHref();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "href", theHref), currentHashCode, theHref, this.isSetHref());
            }
            {
                String theRole;
                theRole = this.getRole();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "role", theRole), currentHashCode, theRole, this.isSetRole());
            }
            {
                String theArcrole;
                theArcrole = this.getArcrole();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "arcrole", theArcrole), currentHashCode, theArcrole, this.isSetArcrole());
            }
            {
                String theTitle;
                theTitle = this.getTitle();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "title", theTitle), currentHashCode, theTitle, this.isSetTitle());
            }
            {
                ShowType theShow;
                theShow = this.getShow();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "show", theShow), currentHashCode, theShow, this.isSetShow());
            }
            {
                ActuateType theActuate;
                theActuate = this.getActuate();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "actuate", theActuate), currentHashCode, theActuate, this.isSetActuate());
            }
            {
                String theNetwork;
                theNetwork = this.getNetwork();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "network", theNetwork), currentHashCode, theNetwork, this.isSetNetwork());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof TaskingInfoType.TaskID) {
                final TaskingInfoType.TaskID copy = ((TaskingInfoType.TaskID) draftCopy);
                {
                    Boolean valueShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetValue());
                    if (valueShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceValue;
                        sourceValue = this.getValue();
                        String copyValue = ((String) strategy.copy(LocatorUtils.property(locator, "value", sourceValue), sourceValue, this.isSetValue()));
                        copy.setValue(copyValue);
                    } else {
                        if (valueShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.value = null;
                        }
                    }
                }
                {
                    Boolean taskingSystemShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTaskingSystem());
                    if (taskingSystemShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceTaskingSystem;
                        sourceTaskingSystem = this.getTaskingSystem();
                        String copyTaskingSystem = ((String) strategy.copy(LocatorUtils.property(locator, "taskingSystem", sourceTaskingSystem), sourceTaskingSystem, this.isSetTaskingSystem()));
                        copy.setTaskingSystem(copyTaskingSystem);
                    } else {
                        if (taskingSystemShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.taskingSystem = null;
                        }
                    }
                }
                {
                    Boolean typeShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetType());
                    if (typeShouldBeCopiedAndSet == Boolean.TRUE) {
                        TypeType sourceType;
                        sourceType = this.getType();
                        TypeType copyType = ((TypeType) strategy.copy(LocatorUtils.property(locator, "type", sourceType), sourceType, this.isSetType()));
                        copy.setType(copyType);
                    } else {
                        if (typeShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.type = null;
                        }
                    }
                }
                {
                    Boolean hrefShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetHref());
                    if (hrefShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceHref;
                        sourceHref = this.getHref();
                        String copyHref = ((String) strategy.copy(LocatorUtils.property(locator, "href", sourceHref), sourceHref, this.isSetHref()));
                        copy.setHref(copyHref);
                    } else {
                        if (hrefShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.href = null;
                        }
                    }
                }
                {
                    Boolean roleShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetRole());
                    if (roleShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceRole;
                        sourceRole = this.getRole();
                        String copyRole = ((String) strategy.copy(LocatorUtils.property(locator, "role", sourceRole), sourceRole, this.isSetRole()));
                        copy.setRole(copyRole);
                    } else {
                        if (roleShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.role = null;
                        }
                    }
                }
                {
                    Boolean arcroleShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetArcrole());
                    if (arcroleShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceArcrole;
                        sourceArcrole = this.getArcrole();
                        String copyArcrole = ((String) strategy.copy(LocatorUtils.property(locator, "arcrole", sourceArcrole), sourceArcrole, this.isSetArcrole()));
                        copy.setArcrole(copyArcrole);
                    } else {
                        if (arcroleShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.arcrole = null;
                        }
                    }
                }
                {
                    Boolean titleShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetTitle());
                    if (titleShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceTitle;
                        sourceTitle = this.getTitle();
                        String copyTitle = ((String) strategy.copy(LocatorUtils.property(locator, "title", sourceTitle), sourceTitle, this.isSetTitle()));
                        copy.setTitle(copyTitle);
                    } else {
                        if (titleShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.title = null;
                        }
                    }
                }
                {
                    Boolean showShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetShow());
                    if (showShouldBeCopiedAndSet == Boolean.TRUE) {
                        ShowType sourceShow;
                        sourceShow = this.getShow();
                        ShowType copyShow = ((ShowType) strategy.copy(LocatorUtils.property(locator, "show", sourceShow), sourceShow, this.isSetShow()));
                        copy.setShow(copyShow);
                    } else {
                        if (showShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.show = null;
                        }
                    }
                }
                {
                    Boolean actuateShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetActuate());
                    if (actuateShouldBeCopiedAndSet == Boolean.TRUE) {
                        ActuateType sourceActuate;
                        sourceActuate = this.getActuate();
                        ActuateType copyActuate = ((ActuateType) strategy.copy(LocatorUtils.property(locator, "actuate", sourceActuate), sourceActuate, this.isSetActuate()));
                        copy.setActuate(copyActuate);
                    } else {
                        if (actuateShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.actuate = null;
                        }
                    }
                }
                {
                    Boolean networkShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetNetwork());
                    if (networkShouldBeCopiedAndSet == Boolean.TRUE) {
                        String sourceNetwork;
                        sourceNetwork = this.getNetwork();
                        String copyNetwork = ((String) strategy.copy(LocatorUtils.property(locator, "network", sourceNetwork), sourceNetwork, this.isSetNetwork()));
                        copy.setNetwork(copyNetwork);
                    } else {
                        if (networkShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.network = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new TaskingInfoType.TaskID();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof TaskingInfoType.TaskID) {
                final TaskingInfoType.TaskID target = this;
                final TaskingInfoType.TaskID leftObject = ((TaskingInfoType.TaskID) left);
                final TaskingInfoType.TaskID rightObject = ((TaskingInfoType.TaskID) right);
                {
                    Boolean valueShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetValue(), rightObject.isSetValue());
                    if (valueShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsValue;
                        lhsValue = leftObject.getValue();
                        String rhsValue;
                        rhsValue = rightObject.getValue();
                        String mergedValue = ((String) strategy.merge(LocatorUtils.property(leftLocator, "value", lhsValue), LocatorUtils.property(rightLocator, "value", rhsValue), lhsValue, rhsValue, leftObject.isSetValue(), rightObject.isSetValue()));
                        target.setValue(mergedValue);
                    } else {
                        if (valueShouldBeMergedAndSet == Boolean.FALSE) {
                            target.value = null;
                        }
                    }
                }
                {
                    Boolean taskingSystemShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTaskingSystem(), rightObject.isSetTaskingSystem());
                    if (taskingSystemShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsTaskingSystem;
                        lhsTaskingSystem = leftObject.getTaskingSystem();
                        String rhsTaskingSystem;
                        rhsTaskingSystem = rightObject.getTaskingSystem();
                        String mergedTaskingSystem = ((String) strategy.merge(LocatorUtils.property(leftLocator, "taskingSystem", lhsTaskingSystem), LocatorUtils.property(rightLocator, "taskingSystem", rhsTaskingSystem), lhsTaskingSystem, rhsTaskingSystem, leftObject.isSetTaskingSystem(), rightObject.isSetTaskingSystem()));
                        target.setTaskingSystem(mergedTaskingSystem);
                    } else {
                        if (taskingSystemShouldBeMergedAndSet == Boolean.FALSE) {
                            target.taskingSystem = null;
                        }
                    }
                }
                {
                    Boolean typeShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetType(), rightObject.isSetType());
                    if (typeShouldBeMergedAndSet == Boolean.TRUE) {
                        TypeType lhsType;
                        lhsType = leftObject.getType();
                        TypeType rhsType;
                        rhsType = rightObject.getType();
                        TypeType mergedType = ((TypeType) strategy.merge(LocatorUtils.property(leftLocator, "type", lhsType), LocatorUtils.property(rightLocator, "type", rhsType), lhsType, rhsType, leftObject.isSetType(), rightObject.isSetType()));
                        target.setType(mergedType);
                    } else {
                        if (typeShouldBeMergedAndSet == Boolean.FALSE) {
                            target.type = null;
                        }
                    }
                }
                {
                    Boolean hrefShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetHref(), rightObject.isSetHref());
                    if (hrefShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsHref;
                        lhsHref = leftObject.getHref();
                        String rhsHref;
                        rhsHref = rightObject.getHref();
                        String mergedHref = ((String) strategy.merge(LocatorUtils.property(leftLocator, "href", lhsHref), LocatorUtils.property(rightLocator, "href", rhsHref), lhsHref, rhsHref, leftObject.isSetHref(), rightObject.isSetHref()));
                        target.setHref(mergedHref);
                    } else {
                        if (hrefShouldBeMergedAndSet == Boolean.FALSE) {
                            target.href = null;
                        }
                    }
                }
                {
                    Boolean roleShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetRole(), rightObject.isSetRole());
                    if (roleShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsRole;
                        lhsRole = leftObject.getRole();
                        String rhsRole;
                        rhsRole = rightObject.getRole();
                        String mergedRole = ((String) strategy.merge(LocatorUtils.property(leftLocator, "role", lhsRole), LocatorUtils.property(rightLocator, "role", rhsRole), lhsRole, rhsRole, leftObject.isSetRole(), rightObject.isSetRole()));
                        target.setRole(mergedRole);
                    } else {
                        if (roleShouldBeMergedAndSet == Boolean.FALSE) {
                            target.role = null;
                        }
                    }
                }
                {
                    Boolean arcroleShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetArcrole(), rightObject.isSetArcrole());
                    if (arcroleShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsArcrole;
                        lhsArcrole = leftObject.getArcrole();
                        String rhsArcrole;
                        rhsArcrole = rightObject.getArcrole();
                        String mergedArcrole = ((String) strategy.merge(LocatorUtils.property(leftLocator, "arcrole", lhsArcrole), LocatorUtils.property(rightLocator, "arcrole", rhsArcrole), lhsArcrole, rhsArcrole, leftObject.isSetArcrole(), rightObject.isSetArcrole()));
                        target.setArcrole(mergedArcrole);
                    } else {
                        if (arcroleShouldBeMergedAndSet == Boolean.FALSE) {
                            target.arcrole = null;
                        }
                    }
                }
                {
                    Boolean titleShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetTitle(), rightObject.isSetTitle());
                    if (titleShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsTitle;
                        lhsTitle = leftObject.getTitle();
                        String rhsTitle;
                        rhsTitle = rightObject.getTitle();
                        String mergedTitle = ((String) strategy.merge(LocatorUtils.property(leftLocator, "title", lhsTitle), LocatorUtils.property(rightLocator, "title", rhsTitle), lhsTitle, rhsTitle, leftObject.isSetTitle(), rightObject.isSetTitle()));
                        target.setTitle(mergedTitle);
                    } else {
                        if (titleShouldBeMergedAndSet == Boolean.FALSE) {
                            target.title = null;
                        }
                    }
                }
                {
                    Boolean showShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetShow(), rightObject.isSetShow());
                    if (showShouldBeMergedAndSet == Boolean.TRUE) {
                        ShowType lhsShow;
                        lhsShow = leftObject.getShow();
                        ShowType rhsShow;
                        rhsShow = rightObject.getShow();
                        ShowType mergedShow = ((ShowType) strategy.merge(LocatorUtils.property(leftLocator, "show", lhsShow), LocatorUtils.property(rightLocator, "show", rhsShow), lhsShow, rhsShow, leftObject.isSetShow(), rightObject.isSetShow()));
                        target.setShow(mergedShow);
                    } else {
                        if (showShouldBeMergedAndSet == Boolean.FALSE) {
                            target.show = null;
                        }
                    }
                }
                {
                    Boolean actuateShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetActuate(), rightObject.isSetActuate());
                    if (actuateShouldBeMergedAndSet == Boolean.TRUE) {
                        ActuateType lhsActuate;
                        lhsActuate = leftObject.getActuate();
                        ActuateType rhsActuate;
                        rhsActuate = rightObject.getActuate();
                        ActuateType mergedActuate = ((ActuateType) strategy.merge(LocatorUtils.property(leftLocator, "actuate", lhsActuate), LocatorUtils.property(rightLocator, "actuate", rhsActuate), lhsActuate, rhsActuate, leftObject.isSetActuate(), rightObject.isSetActuate()));
                        target.setActuate(mergedActuate);
                    } else {
                        if (actuateShouldBeMergedAndSet == Boolean.FALSE) {
                            target.actuate = null;
                        }
                    }
                }
                {
                    Boolean networkShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetNetwork(), rightObject.isSetNetwork());
                    if (networkShouldBeMergedAndSet == Boolean.TRUE) {
                        String lhsNetwork;
                        lhsNetwork = leftObject.getNetwork();
                        String rhsNetwork;
                        rhsNetwork = rightObject.getNetwork();
                        String mergedNetwork = ((String) strategy.merge(LocatorUtils.property(leftLocator, "network", lhsNetwork), LocatorUtils.property(rightLocator, "network", rhsNetwork), lhsNetwork, rhsNetwork, leftObject.isSetNetwork(), rightObject.isSetNetwork()));
                        target.setNetwork(mergedNetwork);
                    } else {
                        if (networkShouldBeMergedAndSet == Boolean.FALSE) {
                            target.network = null;
                        }
                    }
                }
            }
        }

    }

}
