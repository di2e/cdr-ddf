//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.07.27 at 04:06:37 PM EDT 
//


package mil.ces.metadata.mdr.ns.gsip.tspi._2_0.core;

import java.io.Serializable;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import net.opengis.gml.v_3_2_1.AbstractSurfaceType;
import net.opengis.gml.v_3_2_1.DirectPositionType;
import net.opengis.gml.v_3_2_1.PointPropertyType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * Envelope Type: An envelope type, as developed based on ISO 19136:2007 (GML) Envelope for use in the TSPI Schema but extended to include both assessments of the accuracy and/or resolution of the pair of coordinate tuples as well as optional specification of one or more character-oriented presentations of the pair of coordinate tuples based on the sexagesimal, grid-metre, zone-metre, quadrangle and/or numeric-bit location forms. An envelope defines an extent using a pair of positions defining opposite corners in arbitrary dimensions. The first direct position is the "lower corner" (a coordinate position consisting of all the minimal ordinates for each dimension for all points within the envelope), the second one the "upper corner" (a coordinate position consisting of all the maximal ordinates for each dimension for all points within the envelope).
 * 
 * <p>Java class for EnvelopeType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="EnvelopeType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.opengis.net/gml/3.2}AbstractSurfaceType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="lowerCorner"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;choice&gt;
 *                   &lt;element ref="{http://www.opengis.net/gml/3.2}pos"/&gt;
 *                   &lt;element ref="{http://www.opengis.net/gml/3.2}pointProperty"/&gt;
 *                 &lt;/choice&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="upperCorner"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;choice&gt;
 *                   &lt;element ref="{http://www.opengis.net/gml/3.2}pos"/&gt;
 *                   &lt;element ref="{http://www.opengis.net/gml/3.2}pointProperty"/&gt;
 *                 &lt;/choice&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;group ref="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}resolutionGroup"/&gt;
 *         &lt;element name="horizPresentation" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="lowerCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}HorizontalPresentationType"/&gt;
 *                   &lt;element name="upperCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}HorizontalPresentationType"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="vertPresentation" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="lowerCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}VerticalPresentationType"/&gt;
 *                   &lt;element name="upperCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}VerticalPresentationType"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "EnvelopeType", propOrder = {
    "lowerCorner",
    "upperCorner",
    "horizResolutionCategory",
    "vertResolutionCategory",
    "horizPresentation",
    "vertPresentation"
})
public class EnvelopeType
    extends AbstractSurfaceType
    implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
{

    private final static long serialVersionUID = 1L;
    @XmlElement(required = true)
    @NotNull(message = "EnvelopeType.lowerCorner {javax.validation.constraints.NotNull.message}")
    @Valid
    protected EnvelopeType.LowerCorner lowerCorner;
    @XmlElement(required = true)
    @NotNull(message = "EnvelopeType.upperCorner {javax.validation.constraints.NotNull.message}")
    @Valid
    protected EnvelopeType.UpperCorner upperCorner;
    @Valid
    protected HorizontalResolutionType horizResolutionCategory;
    @Valid
    protected VerticalResolutionType vertResolutionCategory;
    @Valid
    protected EnvelopeType.HorizPresentation horizPresentation;
    @Valid
    protected EnvelopeType.VertPresentation vertPresentation;

    /**
     * Gets the value of the lowerCorner property.
     * 
     * @return
     *     possible object is
     *     {@link EnvelopeType.LowerCorner }
     *     
     */
    public EnvelopeType.LowerCorner getLowerCorner() {
        return lowerCorner;
    }

    /**
     * Sets the value of the lowerCorner property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnvelopeType.LowerCorner }
     *     
     */
    public void setLowerCorner(EnvelopeType.LowerCorner value) {
        this.lowerCorner = value;
    }

    public boolean isSetLowerCorner() {
        return (this.lowerCorner!= null);
    }

    /**
     * Gets the value of the upperCorner property.
     * 
     * @return
     *     possible object is
     *     {@link EnvelopeType.UpperCorner }
     *     
     */
    public EnvelopeType.UpperCorner getUpperCorner() {
        return upperCorner;
    }

    /**
     * Sets the value of the upperCorner property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnvelopeType.UpperCorner }
     *     
     */
    public void setUpperCorner(EnvelopeType.UpperCorner value) {
        this.upperCorner = value;
    }

    public boolean isSetUpperCorner() {
        return (this.upperCorner!= null);
    }

    /**
     * Gets the value of the horizResolutionCategory property.
     * 
     * @return
     *     possible object is
     *     {@link HorizontalResolutionType }
     *     
     */
    public HorizontalResolutionType getHorizResolutionCategory() {
        return horizResolutionCategory;
    }

    /**
     * Sets the value of the horizResolutionCategory property.
     * 
     * @param value
     *     allowed object is
     *     {@link HorizontalResolutionType }
     *     
     */
    public void setHorizResolutionCategory(HorizontalResolutionType value) {
        this.horizResolutionCategory = value;
    }

    public boolean isSetHorizResolutionCategory() {
        return (this.horizResolutionCategory!= null);
    }

    /**
     * Gets the value of the vertResolutionCategory property.
     * 
     * @return
     *     possible object is
     *     {@link VerticalResolutionType }
     *     
     */
    public VerticalResolutionType getVertResolutionCategory() {
        return vertResolutionCategory;
    }

    /**
     * Sets the value of the vertResolutionCategory property.
     * 
     * @param value
     *     allowed object is
     *     {@link VerticalResolutionType }
     *     
     */
    public void setVertResolutionCategory(VerticalResolutionType value) {
        this.vertResolutionCategory = value;
    }

    public boolean isSetVertResolutionCategory() {
        return (this.vertResolutionCategory!= null);
    }

    /**
     * Gets the value of the horizPresentation property.
     * 
     * @return
     *     possible object is
     *     {@link EnvelopeType.HorizPresentation }
     *     
     */
    public EnvelopeType.HorizPresentation getHorizPresentation() {
        return horizPresentation;
    }

    /**
     * Sets the value of the horizPresentation property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnvelopeType.HorizPresentation }
     *     
     */
    public void setHorizPresentation(EnvelopeType.HorizPresentation value) {
        this.horizPresentation = value;
    }

    public boolean isSetHorizPresentation() {
        return (this.horizPresentation!= null);
    }

    /**
     * Gets the value of the vertPresentation property.
     * 
     * @return
     *     possible object is
     *     {@link EnvelopeType.VertPresentation }
     *     
     */
    public EnvelopeType.VertPresentation getVertPresentation() {
        return vertPresentation;
    }

    /**
     * Sets the value of the vertPresentation property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnvelopeType.VertPresentation }
     *     
     */
    public void setVertPresentation(EnvelopeType.VertPresentation value) {
        this.vertPresentation = value;
    }

    public boolean isSetVertPresentation() {
        return (this.vertPresentation!= null);
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            EnvelopeType.LowerCorner theLowerCorner;
            theLowerCorner = this.getLowerCorner();
            strategy.appendField(locator, this, "lowerCorner", buffer, theLowerCorner, this.isSetLowerCorner());
        }
        {
            EnvelopeType.UpperCorner theUpperCorner;
            theUpperCorner = this.getUpperCorner();
            strategy.appendField(locator, this, "upperCorner", buffer, theUpperCorner, this.isSetUpperCorner());
        }
        {
            HorizontalResolutionType theHorizResolutionCategory;
            theHorizResolutionCategory = this.getHorizResolutionCategory();
            strategy.appendField(locator, this, "horizResolutionCategory", buffer, theHorizResolutionCategory, this.isSetHorizResolutionCategory());
        }
        {
            VerticalResolutionType theVertResolutionCategory;
            theVertResolutionCategory = this.getVertResolutionCategory();
            strategy.appendField(locator, this, "vertResolutionCategory", buffer, theVertResolutionCategory, this.isSetVertResolutionCategory());
        }
        {
            EnvelopeType.HorizPresentation theHorizPresentation;
            theHorizPresentation = this.getHorizPresentation();
            strategy.appendField(locator, this, "horizPresentation", buffer, theHorizPresentation, this.isSetHorizPresentation());
        }
        {
            EnvelopeType.VertPresentation theVertPresentation;
            theVertPresentation = this.getVertPresentation();
            strategy.appendField(locator, this, "vertPresentation", buffer, theVertPresentation, this.isSetVertPresentation());
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
        if ((object == null)||(this.getClass()!= object.getClass())) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final EnvelopeType that = ((EnvelopeType) object);
        {
            EnvelopeType.LowerCorner lhsLowerCorner;
            lhsLowerCorner = this.getLowerCorner();
            EnvelopeType.LowerCorner rhsLowerCorner;
            rhsLowerCorner = that.getLowerCorner();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(thatLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, this.isSetLowerCorner(), that.isSetLowerCorner())) {
                return false;
            }
        }
        {
            EnvelopeType.UpperCorner lhsUpperCorner;
            lhsUpperCorner = this.getUpperCorner();
            EnvelopeType.UpperCorner rhsUpperCorner;
            rhsUpperCorner = that.getUpperCorner();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(thatLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, this.isSetUpperCorner(), that.isSetUpperCorner())) {
                return false;
            }
        }
        {
            HorizontalResolutionType lhsHorizResolutionCategory;
            lhsHorizResolutionCategory = this.getHorizResolutionCategory();
            HorizontalResolutionType rhsHorizResolutionCategory;
            rhsHorizResolutionCategory = that.getHorizResolutionCategory();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "horizResolutionCategory", lhsHorizResolutionCategory), LocatorUtils.property(thatLocator, "horizResolutionCategory", rhsHorizResolutionCategory), lhsHorizResolutionCategory, rhsHorizResolutionCategory, this.isSetHorizResolutionCategory(), that.isSetHorizResolutionCategory())) {
                return false;
            }
        }
        {
            VerticalResolutionType lhsVertResolutionCategory;
            lhsVertResolutionCategory = this.getVertResolutionCategory();
            VerticalResolutionType rhsVertResolutionCategory;
            rhsVertResolutionCategory = that.getVertResolutionCategory();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "vertResolutionCategory", lhsVertResolutionCategory), LocatorUtils.property(thatLocator, "vertResolutionCategory", rhsVertResolutionCategory), lhsVertResolutionCategory, rhsVertResolutionCategory, this.isSetVertResolutionCategory(), that.isSetVertResolutionCategory())) {
                return false;
            }
        }
        {
            EnvelopeType.HorizPresentation lhsHorizPresentation;
            lhsHorizPresentation = this.getHorizPresentation();
            EnvelopeType.HorizPresentation rhsHorizPresentation;
            rhsHorizPresentation = that.getHorizPresentation();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "horizPresentation", lhsHorizPresentation), LocatorUtils.property(thatLocator, "horizPresentation", rhsHorizPresentation), lhsHorizPresentation, rhsHorizPresentation, this.isSetHorizPresentation(), that.isSetHorizPresentation())) {
                return false;
            }
        }
        {
            EnvelopeType.VertPresentation lhsVertPresentation;
            lhsVertPresentation = this.getVertPresentation();
            EnvelopeType.VertPresentation rhsVertPresentation;
            rhsVertPresentation = that.getVertPresentation();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "vertPresentation", lhsVertPresentation), LocatorUtils.property(thatLocator, "vertPresentation", rhsVertPresentation), lhsVertPresentation, rhsVertPresentation, this.isSetVertPresentation(), that.isSetVertPresentation())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            EnvelopeType.LowerCorner theLowerCorner;
            theLowerCorner = this.getLowerCorner();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lowerCorner", theLowerCorner), currentHashCode, theLowerCorner, this.isSetLowerCorner());
        }
        {
            EnvelopeType.UpperCorner theUpperCorner;
            theUpperCorner = this.getUpperCorner();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "upperCorner", theUpperCorner), currentHashCode, theUpperCorner, this.isSetUpperCorner());
        }
        {
            HorizontalResolutionType theHorizResolutionCategory;
            theHorizResolutionCategory = this.getHorizResolutionCategory();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "horizResolutionCategory", theHorizResolutionCategory), currentHashCode, theHorizResolutionCategory, this.isSetHorizResolutionCategory());
        }
        {
            VerticalResolutionType theVertResolutionCategory;
            theVertResolutionCategory = this.getVertResolutionCategory();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "vertResolutionCategory", theVertResolutionCategory), currentHashCode, theVertResolutionCategory, this.isSetVertResolutionCategory());
        }
        {
            EnvelopeType.HorizPresentation theHorizPresentation;
            theHorizPresentation = this.getHorizPresentation();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "horizPresentation", theHorizPresentation), currentHashCode, theHorizPresentation, this.isSetHorizPresentation());
        }
        {
            EnvelopeType.VertPresentation theVertPresentation;
            theVertPresentation = this.getVertPresentation();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "vertPresentation", theVertPresentation), currentHashCode, theVertPresentation, this.isSetVertPresentation());
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        super.copyTo(locator, draftCopy, strategy);
        if (draftCopy instanceof EnvelopeType) {
            final EnvelopeType copy = ((EnvelopeType) draftCopy);
            {
                Boolean lowerCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetLowerCorner());
                if (lowerCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                    EnvelopeType.LowerCorner sourceLowerCorner;
                    sourceLowerCorner = this.getLowerCorner();
                    EnvelopeType.LowerCorner copyLowerCorner = ((EnvelopeType.LowerCorner) strategy.copy(LocatorUtils.property(locator, "lowerCorner", sourceLowerCorner), sourceLowerCorner, this.isSetLowerCorner()));
                    copy.setLowerCorner(copyLowerCorner);
                } else {
                    if (lowerCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.lowerCorner = null;
                    }
                }
            }
            {
                Boolean upperCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetUpperCorner());
                if (upperCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                    EnvelopeType.UpperCorner sourceUpperCorner;
                    sourceUpperCorner = this.getUpperCorner();
                    EnvelopeType.UpperCorner copyUpperCorner = ((EnvelopeType.UpperCorner) strategy.copy(LocatorUtils.property(locator, "upperCorner", sourceUpperCorner), sourceUpperCorner, this.isSetUpperCorner()));
                    copy.setUpperCorner(copyUpperCorner);
                } else {
                    if (upperCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.upperCorner = null;
                    }
                }
            }
            {
                Boolean horizResolutionCategoryShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetHorizResolutionCategory());
                if (horizResolutionCategoryShouldBeCopiedAndSet == Boolean.TRUE) {
                    HorizontalResolutionType sourceHorizResolutionCategory;
                    sourceHorizResolutionCategory = this.getHorizResolutionCategory();
                    HorizontalResolutionType copyHorizResolutionCategory = ((HorizontalResolutionType) strategy.copy(LocatorUtils.property(locator, "horizResolutionCategory", sourceHorizResolutionCategory), sourceHorizResolutionCategory, this.isSetHorizResolutionCategory()));
                    copy.setHorizResolutionCategory(copyHorizResolutionCategory);
                } else {
                    if (horizResolutionCategoryShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.horizResolutionCategory = null;
                    }
                }
            }
            {
                Boolean vertResolutionCategoryShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetVertResolutionCategory());
                if (vertResolutionCategoryShouldBeCopiedAndSet == Boolean.TRUE) {
                    VerticalResolutionType sourceVertResolutionCategory;
                    sourceVertResolutionCategory = this.getVertResolutionCategory();
                    VerticalResolutionType copyVertResolutionCategory = ((VerticalResolutionType) strategy.copy(LocatorUtils.property(locator, "vertResolutionCategory", sourceVertResolutionCategory), sourceVertResolutionCategory, this.isSetVertResolutionCategory()));
                    copy.setVertResolutionCategory(copyVertResolutionCategory);
                } else {
                    if (vertResolutionCategoryShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.vertResolutionCategory = null;
                    }
                }
            }
            {
                Boolean horizPresentationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetHorizPresentation());
                if (horizPresentationShouldBeCopiedAndSet == Boolean.TRUE) {
                    EnvelopeType.HorizPresentation sourceHorizPresentation;
                    sourceHorizPresentation = this.getHorizPresentation();
                    EnvelopeType.HorizPresentation copyHorizPresentation = ((EnvelopeType.HorizPresentation) strategy.copy(LocatorUtils.property(locator, "horizPresentation", sourceHorizPresentation), sourceHorizPresentation, this.isSetHorizPresentation()));
                    copy.setHorizPresentation(copyHorizPresentation);
                } else {
                    if (horizPresentationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.horizPresentation = null;
                    }
                }
            }
            {
                Boolean vertPresentationShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetVertPresentation());
                if (vertPresentationShouldBeCopiedAndSet == Boolean.TRUE) {
                    EnvelopeType.VertPresentation sourceVertPresentation;
                    sourceVertPresentation = this.getVertPresentation();
                    EnvelopeType.VertPresentation copyVertPresentation = ((EnvelopeType.VertPresentation) strategy.copy(LocatorUtils.property(locator, "vertPresentation", sourceVertPresentation), sourceVertPresentation, this.isSetVertPresentation()));
                    copy.setVertPresentation(copyVertPresentation);
                } else {
                    if (vertPresentationShouldBeCopiedAndSet == Boolean.FALSE) {
                        copy.vertPresentation = null;
                    }
                }
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new EnvelopeType();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
        super.mergeFrom(leftLocator, rightLocator, left, right, strategy);
        if (right instanceof EnvelopeType) {
            final EnvelopeType target = this;
            final EnvelopeType leftObject = ((EnvelopeType) left);
            final EnvelopeType rightObject = ((EnvelopeType) right);
            {
                Boolean lowerCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner());
                if (lowerCornerShouldBeMergedAndSet == Boolean.TRUE) {
                    EnvelopeType.LowerCorner lhsLowerCorner;
                    lhsLowerCorner = leftObject.getLowerCorner();
                    EnvelopeType.LowerCorner rhsLowerCorner;
                    rhsLowerCorner = rightObject.getLowerCorner();
                    EnvelopeType.LowerCorner mergedLowerCorner = ((EnvelopeType.LowerCorner) strategy.merge(LocatorUtils.property(leftLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(rightLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner()));
                    target.setLowerCorner(mergedLowerCorner);
                } else {
                    if (lowerCornerShouldBeMergedAndSet == Boolean.FALSE) {
                        target.lowerCorner = null;
                    }
                }
            }
            {
                Boolean upperCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner());
                if (upperCornerShouldBeMergedAndSet == Boolean.TRUE) {
                    EnvelopeType.UpperCorner lhsUpperCorner;
                    lhsUpperCorner = leftObject.getUpperCorner();
                    EnvelopeType.UpperCorner rhsUpperCorner;
                    rhsUpperCorner = rightObject.getUpperCorner();
                    EnvelopeType.UpperCorner mergedUpperCorner = ((EnvelopeType.UpperCorner) strategy.merge(LocatorUtils.property(leftLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(rightLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner()));
                    target.setUpperCorner(mergedUpperCorner);
                } else {
                    if (upperCornerShouldBeMergedAndSet == Boolean.FALSE) {
                        target.upperCorner = null;
                    }
                }
            }
            {
                Boolean horizResolutionCategoryShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetHorizResolutionCategory(), rightObject.isSetHorizResolutionCategory());
                if (horizResolutionCategoryShouldBeMergedAndSet == Boolean.TRUE) {
                    HorizontalResolutionType lhsHorizResolutionCategory;
                    lhsHorizResolutionCategory = leftObject.getHorizResolutionCategory();
                    HorizontalResolutionType rhsHorizResolutionCategory;
                    rhsHorizResolutionCategory = rightObject.getHorizResolutionCategory();
                    HorizontalResolutionType mergedHorizResolutionCategory = ((HorizontalResolutionType) strategy.merge(LocatorUtils.property(leftLocator, "horizResolutionCategory", lhsHorizResolutionCategory), LocatorUtils.property(rightLocator, "horizResolutionCategory", rhsHorizResolutionCategory), lhsHorizResolutionCategory, rhsHorizResolutionCategory, leftObject.isSetHorizResolutionCategory(), rightObject.isSetHorizResolutionCategory()));
                    target.setHorizResolutionCategory(mergedHorizResolutionCategory);
                } else {
                    if (horizResolutionCategoryShouldBeMergedAndSet == Boolean.FALSE) {
                        target.horizResolutionCategory = null;
                    }
                }
            }
            {
                Boolean vertResolutionCategoryShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetVertResolutionCategory(), rightObject.isSetVertResolutionCategory());
                if (vertResolutionCategoryShouldBeMergedAndSet == Boolean.TRUE) {
                    VerticalResolutionType lhsVertResolutionCategory;
                    lhsVertResolutionCategory = leftObject.getVertResolutionCategory();
                    VerticalResolutionType rhsVertResolutionCategory;
                    rhsVertResolutionCategory = rightObject.getVertResolutionCategory();
                    VerticalResolutionType mergedVertResolutionCategory = ((VerticalResolutionType) strategy.merge(LocatorUtils.property(leftLocator, "vertResolutionCategory", lhsVertResolutionCategory), LocatorUtils.property(rightLocator, "vertResolutionCategory", rhsVertResolutionCategory), lhsVertResolutionCategory, rhsVertResolutionCategory, leftObject.isSetVertResolutionCategory(), rightObject.isSetVertResolutionCategory()));
                    target.setVertResolutionCategory(mergedVertResolutionCategory);
                } else {
                    if (vertResolutionCategoryShouldBeMergedAndSet == Boolean.FALSE) {
                        target.vertResolutionCategory = null;
                    }
                }
            }
            {
                Boolean horizPresentationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetHorizPresentation(), rightObject.isSetHorizPresentation());
                if (horizPresentationShouldBeMergedAndSet == Boolean.TRUE) {
                    EnvelopeType.HorizPresentation lhsHorizPresentation;
                    lhsHorizPresentation = leftObject.getHorizPresentation();
                    EnvelopeType.HorizPresentation rhsHorizPresentation;
                    rhsHorizPresentation = rightObject.getHorizPresentation();
                    EnvelopeType.HorizPresentation mergedHorizPresentation = ((EnvelopeType.HorizPresentation) strategy.merge(LocatorUtils.property(leftLocator, "horizPresentation", lhsHorizPresentation), LocatorUtils.property(rightLocator, "horizPresentation", rhsHorizPresentation), lhsHorizPresentation, rhsHorizPresentation, leftObject.isSetHorizPresentation(), rightObject.isSetHorizPresentation()));
                    target.setHorizPresentation(mergedHorizPresentation);
                } else {
                    if (horizPresentationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.horizPresentation = null;
                    }
                }
            }
            {
                Boolean vertPresentationShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetVertPresentation(), rightObject.isSetVertPresentation());
                if (vertPresentationShouldBeMergedAndSet == Boolean.TRUE) {
                    EnvelopeType.VertPresentation lhsVertPresentation;
                    lhsVertPresentation = leftObject.getVertPresentation();
                    EnvelopeType.VertPresentation rhsVertPresentation;
                    rhsVertPresentation = rightObject.getVertPresentation();
                    EnvelopeType.VertPresentation mergedVertPresentation = ((EnvelopeType.VertPresentation) strategy.merge(LocatorUtils.property(leftLocator, "vertPresentation", lhsVertPresentation), LocatorUtils.property(rightLocator, "vertPresentation", rhsVertPresentation), lhsVertPresentation, rhsVertPresentation, leftObject.isSetVertPresentation(), rightObject.isSetVertPresentation()));
                    target.setVertPresentation(mergedVertPresentation);
                } else {
                    if (vertPresentationShouldBeMergedAndSet == Boolean.FALSE) {
                        target.vertPresentation = null;
                    }
                }
            }
        }
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="lowerCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}HorizontalPresentationType"/&gt;
     *         &lt;element name="upperCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}HorizontalPresentationType"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "lowerCorner",
        "upperCorner"
    })
    public static class HorizPresentation implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlElement(required = true)
        @NotNull(message = "HorizPresentation.lowerCorner {javax.validation.constraints.NotNull.message}")
        @Valid
        protected HorizontalPresentationType lowerCorner;
        @XmlElement(required = true)
        @NotNull(message = "HorizPresentation.upperCorner {javax.validation.constraints.NotNull.message}")
        @Valid
        protected HorizontalPresentationType upperCorner;

        /**
         * Gets the value of the lowerCorner property.
         * 
         * @return
         *     possible object is
         *     {@link HorizontalPresentationType }
         *     
         */
        public HorizontalPresentationType getLowerCorner() {
            return lowerCorner;
        }

        /**
         * Sets the value of the lowerCorner property.
         * 
         * @param value
         *     allowed object is
         *     {@link HorizontalPresentationType }
         *     
         */
        public void setLowerCorner(HorizontalPresentationType value) {
            this.lowerCorner = value;
        }

        public boolean isSetLowerCorner() {
            return (this.lowerCorner!= null);
        }

        /**
         * Gets the value of the upperCorner property.
         * 
         * @return
         *     possible object is
         *     {@link HorizontalPresentationType }
         *     
         */
        public HorizontalPresentationType getUpperCorner() {
            return upperCorner;
        }

        /**
         * Sets the value of the upperCorner property.
         * 
         * @param value
         *     allowed object is
         *     {@link HorizontalPresentationType }
         *     
         */
        public void setUpperCorner(HorizontalPresentationType value) {
            this.upperCorner = value;
        }

        public boolean isSetUpperCorner() {
            return (this.upperCorner!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                HorizontalPresentationType theLowerCorner;
                theLowerCorner = this.getLowerCorner();
                strategy.appendField(locator, this, "lowerCorner", buffer, theLowerCorner, this.isSetLowerCorner());
            }
            {
                HorizontalPresentationType theUpperCorner;
                theUpperCorner = this.getUpperCorner();
                strategy.appendField(locator, this, "upperCorner", buffer, theUpperCorner, this.isSetUpperCorner());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final EnvelopeType.HorizPresentation that = ((EnvelopeType.HorizPresentation) object);
            {
                HorizontalPresentationType lhsLowerCorner;
                lhsLowerCorner = this.getLowerCorner();
                HorizontalPresentationType rhsLowerCorner;
                rhsLowerCorner = that.getLowerCorner();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(thatLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, this.isSetLowerCorner(), that.isSetLowerCorner())) {
                    return false;
                }
            }
            {
                HorizontalPresentationType lhsUpperCorner;
                lhsUpperCorner = this.getUpperCorner();
                HorizontalPresentationType rhsUpperCorner;
                rhsUpperCorner = that.getUpperCorner();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(thatLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, this.isSetUpperCorner(), that.isSetUpperCorner())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                HorizontalPresentationType theLowerCorner;
                theLowerCorner = this.getLowerCorner();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lowerCorner", theLowerCorner), currentHashCode, theLowerCorner, this.isSetLowerCorner());
            }
            {
                HorizontalPresentationType theUpperCorner;
                theUpperCorner = this.getUpperCorner();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "upperCorner", theUpperCorner), currentHashCode, theUpperCorner, this.isSetUpperCorner());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof EnvelopeType.HorizPresentation) {
                final EnvelopeType.HorizPresentation copy = ((EnvelopeType.HorizPresentation) draftCopy);
                {
                    Boolean lowerCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetLowerCorner());
                    if (lowerCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                        HorizontalPresentationType sourceLowerCorner;
                        sourceLowerCorner = this.getLowerCorner();
                        HorizontalPresentationType copyLowerCorner = ((HorizontalPresentationType) strategy.copy(LocatorUtils.property(locator, "lowerCorner", sourceLowerCorner), sourceLowerCorner, this.isSetLowerCorner()));
                        copy.setLowerCorner(copyLowerCorner);
                    } else {
                        if (lowerCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.lowerCorner = null;
                        }
                    }
                }
                {
                    Boolean upperCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetUpperCorner());
                    if (upperCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                        HorizontalPresentationType sourceUpperCorner;
                        sourceUpperCorner = this.getUpperCorner();
                        HorizontalPresentationType copyUpperCorner = ((HorizontalPresentationType) strategy.copy(LocatorUtils.property(locator, "upperCorner", sourceUpperCorner), sourceUpperCorner, this.isSetUpperCorner()));
                        copy.setUpperCorner(copyUpperCorner);
                    } else {
                        if (upperCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.upperCorner = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new EnvelopeType.HorizPresentation();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof EnvelopeType.HorizPresentation) {
                final EnvelopeType.HorizPresentation target = this;
                final EnvelopeType.HorizPresentation leftObject = ((EnvelopeType.HorizPresentation) left);
                final EnvelopeType.HorizPresentation rightObject = ((EnvelopeType.HorizPresentation) right);
                {
                    Boolean lowerCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner());
                    if (lowerCornerShouldBeMergedAndSet == Boolean.TRUE) {
                        HorizontalPresentationType lhsLowerCorner;
                        lhsLowerCorner = leftObject.getLowerCorner();
                        HorizontalPresentationType rhsLowerCorner;
                        rhsLowerCorner = rightObject.getLowerCorner();
                        HorizontalPresentationType mergedLowerCorner = ((HorizontalPresentationType) strategy.merge(LocatorUtils.property(leftLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(rightLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner()));
                        target.setLowerCorner(mergedLowerCorner);
                    } else {
                        if (lowerCornerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.lowerCorner = null;
                        }
                    }
                }
                {
                    Boolean upperCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner());
                    if (upperCornerShouldBeMergedAndSet == Boolean.TRUE) {
                        HorizontalPresentationType lhsUpperCorner;
                        lhsUpperCorner = leftObject.getUpperCorner();
                        HorizontalPresentationType rhsUpperCorner;
                        rhsUpperCorner = rightObject.getUpperCorner();
                        HorizontalPresentationType mergedUpperCorner = ((HorizontalPresentationType) strategy.merge(LocatorUtils.property(leftLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(rightLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner()));
                        target.setUpperCorner(mergedUpperCorner);
                    } else {
                        if (upperCornerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.upperCorner = null;
                        }
                    }
                }
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;choice&gt;
     *         &lt;element ref="{http://www.opengis.net/gml/3.2}pos"/&gt;
     *         &lt;element ref="{http://www.opengis.net/gml/3.2}pointProperty"/&gt;
     *       &lt;/choice&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "pos",
        "pointProperty"
    })
    public static class LowerCorner implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlElement(namespace = "http://www.opengis.net/gml/3.2")
        @Valid
        protected DirectPositionType pos;
        @XmlElement(namespace = "http://www.opengis.net/gml/3.2")
        @Valid
        protected PointPropertyType pointProperty;

        /**
         * Gets the value of the pos property.
         * 
         * @return
         *     possible object is
         *     {@link DirectPositionType }
         *     
         */
        public DirectPositionType getPos() {
            return pos;
        }

        /**
         * Sets the value of the pos property.
         * 
         * @param value
         *     allowed object is
         *     {@link DirectPositionType }
         *     
         */
        public void setPos(DirectPositionType value) {
            this.pos = value;
        }

        public boolean isSetPos() {
            return (this.pos!= null);
        }

        /**
         * Gets the value of the pointProperty property.
         * 
         * @return
         *     possible object is
         *     {@link PointPropertyType }
         *     
         */
        public PointPropertyType getPointProperty() {
            return pointProperty;
        }

        /**
         * Sets the value of the pointProperty property.
         * 
         * @param value
         *     allowed object is
         *     {@link PointPropertyType }
         *     
         */
        public void setPointProperty(PointPropertyType value) {
            this.pointProperty = value;
        }

        public boolean isSetPointProperty() {
            return (this.pointProperty!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                DirectPositionType thePos;
                thePos = this.getPos();
                strategy.appendField(locator, this, "pos", buffer, thePos, this.isSetPos());
            }
            {
                PointPropertyType thePointProperty;
                thePointProperty = this.getPointProperty();
                strategy.appendField(locator, this, "pointProperty", buffer, thePointProperty, this.isSetPointProperty());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final EnvelopeType.LowerCorner that = ((EnvelopeType.LowerCorner) object);
            {
                DirectPositionType lhsPos;
                lhsPos = this.getPos();
                DirectPositionType rhsPos;
                rhsPos = that.getPos();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "pos", lhsPos), LocatorUtils.property(thatLocator, "pos", rhsPos), lhsPos, rhsPos, this.isSetPos(), that.isSetPos())) {
                    return false;
                }
            }
            {
                PointPropertyType lhsPointProperty;
                lhsPointProperty = this.getPointProperty();
                PointPropertyType rhsPointProperty;
                rhsPointProperty = that.getPointProperty();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "pointProperty", lhsPointProperty), LocatorUtils.property(thatLocator, "pointProperty", rhsPointProperty), lhsPointProperty, rhsPointProperty, this.isSetPointProperty(), that.isSetPointProperty())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                DirectPositionType thePos;
                thePos = this.getPos();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pos", thePos), currentHashCode, thePos, this.isSetPos());
            }
            {
                PointPropertyType thePointProperty;
                thePointProperty = this.getPointProperty();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pointProperty", thePointProperty), currentHashCode, thePointProperty, this.isSetPointProperty());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof EnvelopeType.LowerCorner) {
                final EnvelopeType.LowerCorner copy = ((EnvelopeType.LowerCorner) draftCopy);
                {
                    Boolean posShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPos());
                    if (posShouldBeCopiedAndSet == Boolean.TRUE) {
                        DirectPositionType sourcePos;
                        sourcePos = this.getPos();
                        DirectPositionType copyPos = ((DirectPositionType) strategy.copy(LocatorUtils.property(locator, "pos", sourcePos), sourcePos, this.isSetPos()));
                        copy.setPos(copyPos);
                    } else {
                        if (posShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.pos = null;
                        }
                    }
                }
                {
                    Boolean pointPropertyShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPointProperty());
                    if (pointPropertyShouldBeCopiedAndSet == Boolean.TRUE) {
                        PointPropertyType sourcePointProperty;
                        sourcePointProperty = this.getPointProperty();
                        PointPropertyType copyPointProperty = ((PointPropertyType) strategy.copy(LocatorUtils.property(locator, "pointProperty", sourcePointProperty), sourcePointProperty, this.isSetPointProperty()));
                        copy.setPointProperty(copyPointProperty);
                    } else {
                        if (pointPropertyShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.pointProperty = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new EnvelopeType.LowerCorner();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof EnvelopeType.LowerCorner) {
                final EnvelopeType.LowerCorner target = this;
                final EnvelopeType.LowerCorner leftObject = ((EnvelopeType.LowerCorner) left);
                final EnvelopeType.LowerCorner rightObject = ((EnvelopeType.LowerCorner) right);
                {
                    Boolean posShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPos(), rightObject.isSetPos());
                    if (posShouldBeMergedAndSet == Boolean.TRUE) {
                        DirectPositionType lhsPos;
                        lhsPos = leftObject.getPos();
                        DirectPositionType rhsPos;
                        rhsPos = rightObject.getPos();
                        DirectPositionType mergedPos = ((DirectPositionType) strategy.merge(LocatorUtils.property(leftLocator, "pos", lhsPos), LocatorUtils.property(rightLocator, "pos", rhsPos), lhsPos, rhsPos, leftObject.isSetPos(), rightObject.isSetPos()));
                        target.setPos(mergedPos);
                    } else {
                        if (posShouldBeMergedAndSet == Boolean.FALSE) {
                            target.pos = null;
                        }
                    }
                }
                {
                    Boolean pointPropertyShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPointProperty(), rightObject.isSetPointProperty());
                    if (pointPropertyShouldBeMergedAndSet == Boolean.TRUE) {
                        PointPropertyType lhsPointProperty;
                        lhsPointProperty = leftObject.getPointProperty();
                        PointPropertyType rhsPointProperty;
                        rhsPointProperty = rightObject.getPointProperty();
                        PointPropertyType mergedPointProperty = ((PointPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "pointProperty", lhsPointProperty), LocatorUtils.property(rightLocator, "pointProperty", rhsPointProperty), lhsPointProperty, rhsPointProperty, leftObject.isSetPointProperty(), rightObject.isSetPointProperty()));
                        target.setPointProperty(mergedPointProperty);
                    } else {
                        if (pointPropertyShouldBeMergedAndSet == Boolean.FALSE) {
                            target.pointProperty = null;
                        }
                    }
                }
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;choice&gt;
     *         &lt;element ref="{http://www.opengis.net/gml/3.2}pos"/&gt;
     *         &lt;element ref="{http://www.opengis.net/gml/3.2}pointProperty"/&gt;
     *       &lt;/choice&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "pos",
        "pointProperty"
    })
    public static class UpperCorner implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlElement(namespace = "http://www.opengis.net/gml/3.2")
        @Valid
        protected DirectPositionType pos;
        @XmlElement(namespace = "http://www.opengis.net/gml/3.2")
        @Valid
        protected PointPropertyType pointProperty;

        /**
         * Gets the value of the pos property.
         * 
         * @return
         *     possible object is
         *     {@link DirectPositionType }
         *     
         */
        public DirectPositionType getPos() {
            return pos;
        }

        /**
         * Sets the value of the pos property.
         * 
         * @param value
         *     allowed object is
         *     {@link DirectPositionType }
         *     
         */
        public void setPos(DirectPositionType value) {
            this.pos = value;
        }

        public boolean isSetPos() {
            return (this.pos!= null);
        }

        /**
         * Gets the value of the pointProperty property.
         * 
         * @return
         *     possible object is
         *     {@link PointPropertyType }
         *     
         */
        public PointPropertyType getPointProperty() {
            return pointProperty;
        }

        /**
         * Sets the value of the pointProperty property.
         * 
         * @param value
         *     allowed object is
         *     {@link PointPropertyType }
         *     
         */
        public void setPointProperty(PointPropertyType value) {
            this.pointProperty = value;
        }

        public boolean isSetPointProperty() {
            return (this.pointProperty!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                DirectPositionType thePos;
                thePos = this.getPos();
                strategy.appendField(locator, this, "pos", buffer, thePos, this.isSetPos());
            }
            {
                PointPropertyType thePointProperty;
                thePointProperty = this.getPointProperty();
                strategy.appendField(locator, this, "pointProperty", buffer, thePointProperty, this.isSetPointProperty());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final EnvelopeType.UpperCorner that = ((EnvelopeType.UpperCorner) object);
            {
                DirectPositionType lhsPos;
                lhsPos = this.getPos();
                DirectPositionType rhsPos;
                rhsPos = that.getPos();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "pos", lhsPos), LocatorUtils.property(thatLocator, "pos", rhsPos), lhsPos, rhsPos, this.isSetPos(), that.isSetPos())) {
                    return false;
                }
            }
            {
                PointPropertyType lhsPointProperty;
                lhsPointProperty = this.getPointProperty();
                PointPropertyType rhsPointProperty;
                rhsPointProperty = that.getPointProperty();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "pointProperty", lhsPointProperty), LocatorUtils.property(thatLocator, "pointProperty", rhsPointProperty), lhsPointProperty, rhsPointProperty, this.isSetPointProperty(), that.isSetPointProperty())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                DirectPositionType thePos;
                thePos = this.getPos();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pos", thePos), currentHashCode, thePos, this.isSetPos());
            }
            {
                PointPropertyType thePointProperty;
                thePointProperty = this.getPointProperty();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pointProperty", thePointProperty), currentHashCode, thePointProperty, this.isSetPointProperty());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof EnvelopeType.UpperCorner) {
                final EnvelopeType.UpperCorner copy = ((EnvelopeType.UpperCorner) draftCopy);
                {
                    Boolean posShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPos());
                    if (posShouldBeCopiedAndSet == Boolean.TRUE) {
                        DirectPositionType sourcePos;
                        sourcePos = this.getPos();
                        DirectPositionType copyPos = ((DirectPositionType) strategy.copy(LocatorUtils.property(locator, "pos", sourcePos), sourcePos, this.isSetPos()));
                        copy.setPos(copyPos);
                    } else {
                        if (posShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.pos = null;
                        }
                    }
                }
                {
                    Boolean pointPropertyShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetPointProperty());
                    if (pointPropertyShouldBeCopiedAndSet == Boolean.TRUE) {
                        PointPropertyType sourcePointProperty;
                        sourcePointProperty = this.getPointProperty();
                        PointPropertyType copyPointProperty = ((PointPropertyType) strategy.copy(LocatorUtils.property(locator, "pointProperty", sourcePointProperty), sourcePointProperty, this.isSetPointProperty()));
                        copy.setPointProperty(copyPointProperty);
                    } else {
                        if (pointPropertyShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.pointProperty = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new EnvelopeType.UpperCorner();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof EnvelopeType.UpperCorner) {
                final EnvelopeType.UpperCorner target = this;
                final EnvelopeType.UpperCorner leftObject = ((EnvelopeType.UpperCorner) left);
                final EnvelopeType.UpperCorner rightObject = ((EnvelopeType.UpperCorner) right);
                {
                    Boolean posShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPos(), rightObject.isSetPos());
                    if (posShouldBeMergedAndSet == Boolean.TRUE) {
                        DirectPositionType lhsPos;
                        lhsPos = leftObject.getPos();
                        DirectPositionType rhsPos;
                        rhsPos = rightObject.getPos();
                        DirectPositionType mergedPos = ((DirectPositionType) strategy.merge(LocatorUtils.property(leftLocator, "pos", lhsPos), LocatorUtils.property(rightLocator, "pos", rhsPos), lhsPos, rhsPos, leftObject.isSetPos(), rightObject.isSetPos()));
                        target.setPos(mergedPos);
                    } else {
                        if (posShouldBeMergedAndSet == Boolean.FALSE) {
                            target.pos = null;
                        }
                    }
                }
                {
                    Boolean pointPropertyShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetPointProperty(), rightObject.isSetPointProperty());
                    if (pointPropertyShouldBeMergedAndSet == Boolean.TRUE) {
                        PointPropertyType lhsPointProperty;
                        lhsPointProperty = leftObject.getPointProperty();
                        PointPropertyType rhsPointProperty;
                        rhsPointProperty = rightObject.getPointProperty();
                        PointPropertyType mergedPointProperty = ((PointPropertyType) strategy.merge(LocatorUtils.property(leftLocator, "pointProperty", lhsPointProperty), LocatorUtils.property(rightLocator, "pointProperty", rhsPointProperty), lhsPointProperty, rhsPointProperty, leftObject.isSetPointProperty(), rightObject.isSetPointProperty()));
                        target.setPointProperty(mergedPointProperty);
                    } else {
                        if (pointPropertyShouldBeMergedAndSet == Boolean.FALSE) {
                            target.pointProperty = null;
                        }
                    }
                }
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="lowerCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}VerticalPresentationType"/&gt;
     *         &lt;element name="upperCorner" type="{http://metadata.ces.mil/mdr/ns/GSIP/tspi/2.0/core}VerticalPresentationType"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "lowerCorner",
        "upperCorner"
    })
    public static class VertPresentation implements Serializable, Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2
    {

        private final static long serialVersionUID = 1L;
        @XmlElement(required = true)
        @NotNull(message = "VertPresentation.lowerCorner {javax.validation.constraints.NotNull.message}")
        @Valid
        protected VerticalPresentationType lowerCorner;
        @XmlElement(required = true)
        @NotNull(message = "VertPresentation.upperCorner {javax.validation.constraints.NotNull.message}")
        @Valid
        protected VerticalPresentationType upperCorner;

        /**
         * Gets the value of the lowerCorner property.
         * 
         * @return
         *     possible object is
         *     {@link VerticalPresentationType }
         *     
         */
        public VerticalPresentationType getLowerCorner() {
            return lowerCorner;
        }

        /**
         * Sets the value of the lowerCorner property.
         * 
         * @param value
         *     allowed object is
         *     {@link VerticalPresentationType }
         *     
         */
        public void setLowerCorner(VerticalPresentationType value) {
            this.lowerCorner = value;
        }

        public boolean isSetLowerCorner() {
            return (this.lowerCorner!= null);
        }

        /**
         * Gets the value of the upperCorner property.
         * 
         * @return
         *     possible object is
         *     {@link VerticalPresentationType }
         *     
         */
        public VerticalPresentationType getUpperCorner() {
            return upperCorner;
        }

        /**
         * Sets the value of the upperCorner property.
         * 
         * @param value
         *     allowed object is
         *     {@link VerticalPresentationType }
         *     
         */
        public void setUpperCorner(VerticalPresentationType value) {
            this.upperCorner = value;
        }

        public boolean isSetUpperCorner() {
            return (this.upperCorner!= null);
        }

        public String toString() {
            final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
            {
                VerticalPresentationType theLowerCorner;
                theLowerCorner = this.getLowerCorner();
                strategy.appendField(locator, this, "lowerCorner", buffer, theLowerCorner, this.isSetLowerCorner());
            }
            {
                VerticalPresentationType theUpperCorner;
                theUpperCorner = this.getUpperCorner();
                strategy.appendField(locator, this, "upperCorner", buffer, theUpperCorner, this.isSetUpperCorner());
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy2 strategy) {
            if ((object == null)||(this.getClass()!= object.getClass())) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final EnvelopeType.VertPresentation that = ((EnvelopeType.VertPresentation) object);
            {
                VerticalPresentationType lhsLowerCorner;
                lhsLowerCorner = this.getLowerCorner();
                VerticalPresentationType rhsLowerCorner;
                rhsLowerCorner = that.getLowerCorner();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(thatLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, this.isSetLowerCorner(), that.isSetLowerCorner())) {
                    return false;
                }
            }
            {
                VerticalPresentationType lhsUpperCorner;
                lhsUpperCorner = this.getUpperCorner();
                VerticalPresentationType rhsUpperCorner;
                rhsUpperCorner = that.getUpperCorner();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(thatLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, this.isSetUpperCorner(), that.isSetUpperCorner())) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
            int currentHashCode = 1;
            {
                VerticalPresentationType theLowerCorner;
                theLowerCorner = this.getLowerCorner();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lowerCorner", theLowerCorner), currentHashCode, theLowerCorner, this.isSetLowerCorner());
            }
            {
                VerticalPresentationType theUpperCorner;
                theUpperCorner = this.getUpperCorner();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "upperCorner", theUpperCorner), currentHashCode, theUpperCorner, this.isSetUpperCorner());
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof EnvelopeType.VertPresentation) {
                final EnvelopeType.VertPresentation copy = ((EnvelopeType.VertPresentation) draftCopy);
                {
                    Boolean lowerCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetLowerCorner());
                    if (lowerCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                        VerticalPresentationType sourceLowerCorner;
                        sourceLowerCorner = this.getLowerCorner();
                        VerticalPresentationType copyLowerCorner = ((VerticalPresentationType) strategy.copy(LocatorUtils.property(locator, "lowerCorner", sourceLowerCorner), sourceLowerCorner, this.isSetLowerCorner()));
                        copy.setLowerCorner(copyLowerCorner);
                    } else {
                        if (lowerCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.lowerCorner = null;
                        }
                    }
                }
                {
                    Boolean upperCornerShouldBeCopiedAndSet = strategy.shouldBeCopiedAndSet(locator, this.isSetUpperCorner());
                    if (upperCornerShouldBeCopiedAndSet == Boolean.TRUE) {
                        VerticalPresentationType sourceUpperCorner;
                        sourceUpperCorner = this.getUpperCorner();
                        VerticalPresentationType copyUpperCorner = ((VerticalPresentationType) strategy.copy(LocatorUtils.property(locator, "upperCorner", sourceUpperCorner), sourceUpperCorner, this.isSetUpperCorner()));
                        copy.setUpperCorner(copyUpperCorner);
                    } else {
                        if (upperCornerShouldBeCopiedAndSet == Boolean.FALSE) {
                            copy.upperCorner = null;
                        }
                    }
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new EnvelopeType.VertPresentation();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy2 strategy) {
            if (right instanceof EnvelopeType.VertPresentation) {
                final EnvelopeType.VertPresentation target = this;
                final EnvelopeType.VertPresentation leftObject = ((EnvelopeType.VertPresentation) left);
                final EnvelopeType.VertPresentation rightObject = ((EnvelopeType.VertPresentation) right);
                {
                    Boolean lowerCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner());
                    if (lowerCornerShouldBeMergedAndSet == Boolean.TRUE) {
                        VerticalPresentationType lhsLowerCorner;
                        lhsLowerCorner = leftObject.getLowerCorner();
                        VerticalPresentationType rhsLowerCorner;
                        rhsLowerCorner = rightObject.getLowerCorner();
                        VerticalPresentationType mergedLowerCorner = ((VerticalPresentationType) strategy.merge(LocatorUtils.property(leftLocator, "lowerCorner", lhsLowerCorner), LocatorUtils.property(rightLocator, "lowerCorner", rhsLowerCorner), lhsLowerCorner, rhsLowerCorner, leftObject.isSetLowerCorner(), rightObject.isSetLowerCorner()));
                        target.setLowerCorner(mergedLowerCorner);
                    } else {
                        if (lowerCornerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.lowerCorner = null;
                        }
                    }
                }
                {
                    Boolean upperCornerShouldBeMergedAndSet = strategy.shouldBeMergedAndSet(leftLocator, rightLocator, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner());
                    if (upperCornerShouldBeMergedAndSet == Boolean.TRUE) {
                        VerticalPresentationType lhsUpperCorner;
                        lhsUpperCorner = leftObject.getUpperCorner();
                        VerticalPresentationType rhsUpperCorner;
                        rhsUpperCorner = rightObject.getUpperCorner();
                        VerticalPresentationType mergedUpperCorner = ((VerticalPresentationType) strategy.merge(LocatorUtils.property(leftLocator, "upperCorner", lhsUpperCorner), LocatorUtils.property(rightLocator, "upperCorner", rhsUpperCorner), lhsUpperCorner, rhsUpperCorner, leftObject.isSetUpperCorner(), rightObject.isSetUpperCorner()));
                        target.setUpperCorner(mergedUpperCorner);
                    } else {
                        if (upperCornerShouldBeMergedAndSet == Boolean.FALSE) {
                            target.upperCorner = null;
                        }
                    }
                }
            }
        }

    }

}
